Microsoft (R) Macro Assembler Version 6.14.8444		    01/01/24 17:42:58
C:\Users\fjrus\source\repos\Fig-Forth\Fig-Forth.asm	     Page 1 - 1



				;
				.486
				.MODEL flat,stdcall
				option casemap :none   ; case sensitive
				;
				.stack 4096 
				;
				; #########################################################################
				;
				NEXTC macro byte
				   MOV EAX, [EDI]
				   ADD EDI, 4
				   JMP EAX 
				endm
				;
				BRNEXT macro byte
				   mov edi, [edi]
				   mov eax, -4 [edi]
				   jmp [eax]
				endm
				;
				Main   PROTO
				;      
				; #########################################################################
				;
 00000000			.code
				;
 00000000			Forth_Thread:
 00000000  000005A1 R		DD COLD      ; BOOT CALL
 00000004			SCRINIT:
 00000004  0000074D R		DD do_SCRINIT   ; INITIALIZE SCREEN DISPLAY
 00000008			ABORT:
 00000008  000006D6 R		DD do_ABORT     ; USED AFTER COMPLETION OF ACTIONS
 0000000C  00002192 R		DD QUIT      ; ISSUES 'OK' PROMPT
 00000010  00000026 R		DD TI1          ; THE TEXT INTERPRETER
				;
				; ---------------------------------------------------------------------------
				;
 00000014			    Start:
				    .LIST
				      	invoke Main
 00000014  E8 000000C8	   *	    call   Main
				;
 00000019  8D 3D 00000000 R		LEA EDI, Forth_Thread 			; Load DI with Forth_Thread
					NEXTC
 0000001F  8B 07	     1	   MOV EAX, [EDI]
 00000021  83 C7 04	     1	   ADD EDI, 4
 00000024  FF E0	     1	   JMP EAX 
				;
 00000026			TI1: ; Text Interpreter
 00000026			;
 00000026  68 00000030 R	PUSH $ + 10
 0000002B  E9 000015BA		JMP do_DOCOL
 00000030			 @ACCEPT:                                           ; Label
 00000030  00002D5E R		 DD do_BEGIN@                                       ; CYCLE TILL 'bye' IS RECEIVED
 00000034  00002F7A R		 DD do_ACCEPT, do_DROP
	   00000C22 R
 0000003C  00002D5E R		 DD do_BEGIN@                                       ; CYCLE TRHOUGH INPUT STRING
 00000040  000001A3 R		 DD do_POC, do_ZCOUNT, do_PUSH0, do_FILL            ; erase input buffer
	   0000140B R
	   000008D6 R
	   000017CA R
 00000050  00001CA3 R		 DD TIB, do_LIT, 32, do_WORD                          ; INPUT BUFFER, SEARCH DELIMITER, PARSE INPUT STRING
	   00000C07 R
	   00000020
	   0000185D R
 00000060  000013AB R		 DD do_COUNT, do_FIND                               ; GET LENGTH, LOCATE INPUT CHAR STRING IN DICTIONARY
	   00001B38 R
 00000068  00003709 R		 DD do_INTERPRET                                    ; CALL ADDRESS INTERPRETER
 0000006C  0000027C R		 DD do_S_LEN, do_FETCH, do_IN, do_FETCH             ; S_LEN _IN - 1 > 
	   00000922 R
	   0000025F R
	   00000922 R
 0000007C  00000A90 R		 DD do_MINUS, do_PUSH1, do_GT
	   000008A9 R
	   0000109B R
 00000088  00002D85 R		 DD do_UNTIL@ 
 0000008C  000008D6 R		 DD do_PUSH0, do_IN, do_STORE, QUIT             ; 0 _IN !  DISPLAY 'ok'
	   0000025F R
	   00000938 R
	   00002192 R
 0000009C  00002177 R		 DD QBYE
 000000A0  00002D85 R		 DD do_UNTIL@ 
 000000A4  000000A8 R		 DD @@EXIT
 000000A8			 @@EXIT:
 000000A8  8D 05 00000C3F R	 lea eax, crlf$
 000000AE  50			 push eax
 000000AF  E8 00000000 E	 call StdOut
 000000B4  8D 05 00000AEB R	 lea eax, Msg8
 000000BA  50			 push eax
 000000BB  E8 00000000 E	 call StdOut
 000000C0  8D 05 00000BC6 R	 lea eax, Msg20
 000000C6  50			 push eax 
 000000C7  E8 00000000 E	 call StdOut
 000000CC  6A 01		 push LENGTHOF TIB
 000000CE  8D 05 00001CA3 R	 lea eax, TIB
 000000D4  50			 push eax
 000000D5  E8 00000000 E	 call StdIn ; await Enter Key
 000000DA  6A 00		 push 0
 000000DC  E8 00000000 E	 call ExitProcess
				;
 000000E1			EOI:
				; #########################################################################
				;
 000000E1			Main proc
				  ; -------------------------------
				  ; console mode library procedures
				  ; -------------------------------
 000000E1  8D 05 00000AFC R	  lea eax, Msg9
 000000E7  50			  push eax
 000000E8  E8 00000000 E	  call StdOut
				;
 000000ED  C3			ret
				;
 000000EE			Main endp
				;
				; _________________________________________________________________________________
				;  SYSTEM VARIABLES DEFINED ALL VERIFIED
				;
 000000EE			ENDOFLINE:
 000000EE  00000000		DD 0000 
 000000F2  00000101 R		DD do_ENDOFLINE
 000000F6  00 09 45 4E 44	DB 0, 9, 'ENDOFLINE'
	   4F 46 4C 49 4E
	   45
 00000101			do_ENDOFLINE:
				NEXTC
 00000101  8B 07	     1	   MOV EAX, [EDI]
 00000103  83 C7 04	     1	   ADD EDI, 4
 00000106  FF E0	     1	   JMP EAX 
				;
 00000108			_HLD:               
 00000108  000000EE R		DD ENDOFLINE
 0000010C  00000115 R		DD do_HLD
 00000110  00 03 48 4C 44	DB 0, 3, 'HLD'
 00000115			do_HLD:
 00000115  8D 05 00000978 R	LEA EAX, HLD
 0000011B  50			PUSH EAX 
				NEXTC
 0000011C  8B 07	     1	   MOV EAX, [EDI]
 0000011E  83 C7 04	     1	   ADD EDI, 4
 00000121  FF E0	     1	   JMP EAX 
				;
 00000123			_STATE:
 00000123  00000108 R		DD _HLD
 00000127  00000132 R		DD do_STATE
 0000012B  00 05 53 54 41	DB 0, 5, 'STATE'
	   54 45
 00000132			do_STATE:
 00000132  8D 05 000009D8 R	LEA EAX, STATE
 00000138  50			PUSH EAX 
				NEXTC
 00000139  8B 07	     1	   MOV EAX, [EDI]
 0000013B  83 C7 04	     1	   ADD EDI, 4
 0000013E  FF E0	     1	   JMP EAX 
				;
 00000140			_BASE:
 00000140  00000123 R		DD _STATE
 00000144  0000014E R		DD do_BASE
 00000148  00 04 42 41 53	DB 0, 4, 'BASE'
	   45
 0000014E			do_BASE:
 0000014E  8D 05 00000944 R	LEA EAX, BASE
 00000154  50			PUSH EAX 
				NEXTC
 00000155  8B 07	     1	   MOV EAX, [EDI]
 00000157  83 C7 04	     1	   ADD EDI, 4
 0000015A  FF E0	     1	   JMP EAX 
				;
 0000015C			venum: ; negate value flag
 0000015C  00000140 R		DD _BASE
 00000160  0000016C R		DD do_venum
 00000164  00 06 56 45 4E	DB 0, 6, 'VENUM?'
	   55 4D 3F
 0000016C			do_venum:
 0000016C  8D 05 000009EC R	LEA EAX, VENUMQ
 00000172  50			PUSH EAX
				NEXTC
 00000173  8B 07	     1	   MOV EAX, [EDI]
 00000175  83 C7 04	     1	   ADD EDI, 4
 00000178  FF E0	     1	   JMP EAX 
				;
 0000017A			Gone:
 0000017A  0000015C R		DD venum
 0000017E  00000188 R		DD do_Gone
 00000182  00 04 47 4F 4E	DB 0, 4, 'GONE'
	   45
 00000188			do_Gone:
 00000188  8D 05 00000974 R	LEA EAX, gone
 0000018E  50			PUSH EAX
				NEXTC
 0000018F  8B 07	     1	   MOV EAX, [EDI]
 00000191  83 C7 04	     1	   ADD EDI, 4
 00000194  FF E0	     1	   JMP EAX 
				;
 00000196			_POC:
 00000196  0000017A R		DD Gone
 0000019A  000001A3 R		DD do_POC
 0000019E  00 03 50 4F 43	DB 0, 3, 'POC' 
 000001A3			do_POC:
 000001A3  8D 05 00000878 R	LEA EAX, POC
 000001A9  50			PUSH EAX
				NEXTC
 000001AA  8B 07	     1	   MOV EAX, [EDI]
 000001AC  83 C7 04	     1	   ADD EDI, 4
 000001AF  FF E0	     1	   JMP EAX 
				;
 000001B1			_DPR:
 000001B1  00000196 R		DD _POC
 000001B5  000001BE R		DD do_DPR
 000001B9  00 03 44 50 52	DB 0, 3, 'DPR'
 000001BE			do_DPR:
 000001BE  8D 05 00000968 R	LEA EAX, DPR
 000001C4  50			PUSH EAX 
				NEXTC
 000001C5  8B 07	     1	   MOV EAX, [EDI]
 000001C7  83 C7 04	     1	   ADD EDI, 4
 000001CA  FF E0	     1	   JMP EAX 
				;
 000001CC			_FINDFLAG:
 000001CC  000001B1 R		DD _DPR
 000001D0  000001DB R		DD do_FFLAG
 000001D4  00 05 46 46 4C	DB 0, 5, 'FFLAG'
	   41 47
 000001DB			do_FFLAG:
 000001DB  8D 05 00000970 R	LEA EAX, FFLAG
 000001E1  50			PUSH EAX 
				NEXTC
 000001E2  8B 07	     1	   MOV EAX, [EDI]
 000001E4  83 C7 04	     1	   ADD EDI, 4
 000001E7  FF E0	     1	   JMP EAX 
				;
 000001E9			_LFA:
 000001E9  000001CC R		DD _FINDFLAG
 000001ED  000001F6 R		DD do_LFA
 000001F1  00 03 4C 46 41	DB 0, 3, 'LFA'
 000001F6			do_LFA:
 000001F6  8D 05 00000984 R	LEA EAX, LFA
 000001FC  50			PUSH EAX 
				NEXTC
 000001FD  8B 07	     1	   MOV EAX, [EDI]
 000001FF  83 C7 04	     1	   ADD EDI, 4
 00000202  FF E0	     1	   JMP EAX 
				;
 00000204			_NFA:
 00000204  000001E9 R		DD _LFA
 00000208  00000211 R		DD do_NFA
 0000020C  00 03 4E 46 41	DB 0, 3, 'NFA'
 00000211			do_NFA:
 00000211  A1 000009A0 R	MOV EAX, NFA
 00000216  50			PUSH EAX 
				NEXTC
 00000217  8B 07	     1	   MOV EAX, [EDI]
 00000219  83 C7 04	     1	   ADD EDI, 4
 0000021C  FF E0	     1	   JMP EAX 
				;
 0000021E			_CFA:
 0000021E  00000204 R		DD _NFA
 00000222  0000022B R		DD do_CFA
 00000226  00 03 43 46 41	DB 0, 3, 'CFA'
 0000022B			do_CFA:
 0000022B  A1 0000094C R	MOV EAX, CFA
 00000230  50			PUSH EAX 
				NEXTC
 00000231  8B 07	     1	   MOV EAX, [EDI]
 00000233  83 C7 04	     1	   ADD EDI, 4
 00000236  FF E0	     1	   JMP EAX 
				;
 00000238			_PFA:
 00000238  0000021E R		DD _CFA
 0000023C  00000245 R		DD do_PFA
 00000240  00 03 50 46 41	DB 0, 3, 'PFA'
 00000245			do_PFA:
 00000245  A1 000009A4 R	MOV EAX, PFA
 0000024A  50			PUSH EAX 
				NEXTC
 0000024B  8B 07	     1	   MOV EAX, [EDI]
 0000024D  83 C7 04	     1	   ADD EDI, 4
 00000250  FF E0	     1	   JMP EAX 
				;
 00000252			__IN:
 00000252  00000238 R		DD _PFA
 00000256  0000025F R		DD do_IN
 0000025A  00 03 5F 49 4E	DB 0, 3, '_IN'
 0000025F			do_IN:
 0000025F  8D 05 00000930 R	LEA EAX, _IN
 00000265  50			PUSH EAX 
				NEXTC
 00000266  8B 07	     1	   MOV EAX, [EDI]
 00000268  83 C7 04	     1	   ADD EDI, 4
 0000026B  FF E0	     1	   JMP EAX 
				;
 0000026D			_S_LEN:
 0000026D  00000252 R		DD __IN
 00000271  0000027C R		DD do_S_LEN
 00000275  00 05 53 5F 4C	DB 0, 5, 'S_LEN'
	   45 4E
 0000027C			do_S_LEN:
 0000027C  8D 05 000009C4 R	LEA EAX, S_LEN
 00000282  50			PUSH EAX 
				NEXTC
 00000283  8B 07	     1	   MOV EAX, [EDI]
 00000285  83 C7 04	     1	   ADD EDI, 4
 00000288  FF E0	     1	   JMP EAX 
				;
 0000028A			_S_MAX:
 0000028A  0000026D R		DD _S_LEN
 0000028E  00000298 R		DD do_SMAX
 00000292  00 04 53 4D 41	DB 0, 4, 'SMAX'
	   58
 00000298			do_SMAX:
 00000298  8D 05 000009CC R	LEA EAX, SMAX
 0000029E  50			PUSH EAX 
				NEXTC
 0000029F  8B 07	     1	   MOV EAX, [EDI]
 000002A1  83 C7 04	     1	   ADD EDI, 4
 000002A4  FF E0	     1	   JMP EAX 
				;
 000002A6			_S0:
 000002A6  0000028A R		DD _S_MAX
 000002AA  000002B2 R		DD do_S0
 000002AE  00 02 53 30		DB 0, 2, 'S0'
 000002B2			do_S0:
 000002B2  8D 05 000009D0 R	LEA EAX, S0
 000002B8  50			PUSH EAX 
				NEXTC
 000002B9  8B 07	     1	   MOV EAX, [EDI]
 000002BB  83 C7 04	     1	   ADD EDI, 4
 000002BE  FF E0	     1	   JMP EAX 
				;
 000002C0			_TV1:
 000002C0  000002A6 R		DD _S0
 000002C4  000002CD R		DD do_TV1
 000002C8  00 03 54 56 31	DB 0, 3, 'TV1'
 000002CD			do_TV1:
 000002CD  8D 05 000009DC R	LEA EAX, TV1
 000002D3  50			PUSH EAX 
				NEXTC
 000002D4  8B 07	     1	   MOV EAX, [EDI]
 000002D6  83 C7 04	     1	   ADD EDI, 4
 000002D9  FF E0	     1	   JMP EAX 
				;
 000002DB			_TV2:
 000002DB  000002C0 R		DD _TV1
 000002DF  000002E8 R		DD do_TV2
 000002E3  00 03 54 56 32	DB 0, 3, 'TV2'
 000002E8			do_TV2:
 000002E8  8D 05 000009E0 R	LEA EAX, TV2
 000002EE  50			PUSH EAX 
				NEXTC
 000002EF  8B 07	     1	   MOV EAX, [EDI]
 000002F1  83 C7 04	     1	   ADD EDI, 4
 000002F4  FF E0	     1	   JMP EAX 
				;
 000002F6			_TV3:
 000002F6  000002DB R		DD _TV2
 000002FA  00000303 R		DD do_TV3
 000002FE  00 03 54 56 33	DB 0, 3, 'TV3'
 00000303			do_TV3:
 00000303  8D 05 000009E4 R	LEA EAX, TV3
 00000309  50			PUSH EAX 
				NEXTC
 0000030A  8B 07	     1	   MOV EAX, [EDI]
 0000030C  83 C7 04	     1	   ADD EDI, 4
 0000030F  FF E0	     1	   JMP EAX 

				;
 00000311			_DCW:
 00000311  000002F6 R		DD _TV3
 00000315  0000031E R		DD do_DCW
 00000319  00 03 44 43 57	DB 0, 3, 'DCW'
 0000031E			do_DCW:
 0000031E  8D 05 0000095C R	LEA EAX, DCW
 00000324  50			PUSH EAX 
				NEXTC
 00000325  8B 07	     1	   MOV EAX, [EDI]
 00000327  83 C7 04	     1	   ADD EDI, 4
 0000032A  FF E0	     1	   JMP EAX 
				;
 0000032C			_KEYIN:
 0000032C  00000311 R		DD _DCW
 00000330  0000033B R		DD do_KEYIN
 00000334  00 05 4B 45 59	DB 0, 5, 'KEYIN'
	   49 4E
 0000033B			do_KEYIN:
 0000033B  8D 05 0000097C R	LEA EAX, KEYIN
 00000341  50			PUSH EAX 
				NEXTC
 00000342  8B 07	     1	   MOV EAX, [EDI]
 00000344  83 C7 04	     1	   ADD EDI, 4
 00000347  FF E0	     1	   JMP EAX 
				;
 00000349			hMemory:
 00000349  0000032C R		DD _KEYIN
 0000034D  00000357 R		DD do_HMEM
 00000351  00 04 48 4D 45	DB 0, 4, 'HMEM'
	   4D
 00000357			do_HMEM:
 00000357  8D 05 0000092C R	LEA EAX, _hMemory
 0000035D  50			PUSH EAX 
				NEXTC
 0000035E  8B 07	     1	   MOV EAX, [EDI]
 00000360  83 C7 04	     1	   ADD EDI, 4
 00000363  FF E0	     1	   JMP EAX 
				;
 00000365			_pMem:
 00000365  00000349 R		DD hMemory
 00000369  00000373 R		DD do_PMEM
 0000036D  00 04 50 4D 45	DB 0, 4, 'PMEM'
	   4D
 00000373			do_PMEM:
 00000373  8D 05 000009A8 R	LEA EAX, pMem
 00000379  50			PUSH EAX 
				NEXTC
 0000037A  8B 07	     1	   MOV EAX, [EDI]
 0000037C  83 C7 04	     1	   ADD EDI, 4
 0000037F  FF E0	     1	   JMP EAX 
				;
 00000381			_CRLF:
 00000381  00000365 R		DD _pMem
 00000385  0000038F R		DD do_CRLF
 00000389  00 04 43 52 4C	DB 0, 4, 'CRLF'
	   46
 0000038F			do_CRLF:
 0000038F  8D 05 00000C3F R	LEA EAX, crlf$
 00000395  50			PUSH EAX 
				NEXTC
 00000396  8B 07	     1	   MOV EAX, [EDI]
 00000398  83 C7 04	     1	   ADD EDI, 4
 0000039B  FF E0	     1	   JMP EAX 
				;
 0000039D			_MSG3:
 0000039D  00000381 R		DD _CRLF
 000003A1  000003AB R		DD do_MSG3
 000003A5  00 04 4D 53 47	DB 0, 4, 'MSG3'
	   33
 000003AB			do_MSG3:
 000003AB  8D 05 00000A4C R	LEA EAX, Msg3
 000003B1  50			PUSH EAX 
				NEXTC
 000003B2  8B 07	     1	   MOV EAX, [EDI]
 000003B4  83 C7 04	     1	   ADD EDI, 4
 000003B7  FF E0	     1	   JMP EAX 
				;
 000003B9			_MSG4:
 000003B9  0000039D R		DD _MSG3
 000003BD  000003C7 R		DD do_MSG4
 000003C1  00 04 4D 53 47	DB 0, 4, 'MSG4'
	   34
 000003C7			do_MSG4:
 000003C7  8D 05 00000A84 R	LEA EAX, Msg4
 000003CD  50			PUSH EAX 
				NEXTC
 000003CE  8B 07	     1	   MOV EAX, [EDI]
 000003D0  83 C7 04	     1	   ADD EDI, 4
 000003D3  FF E0	     1	   JMP EAX 
				;
 000003D5			_MSG22:
 000003D5  0000039D R		DD _MSG3
 000003D9  000003E4 R		DD do_MSG22
 000003DD  00 05 4D 53 47	DB 0, 5, 'MSG22'
	   32 32
 000003E4			do_MSG22:
 000003E4  8D 05 00000BF8 R	LEA EAX, Msg22
 000003EA  50			PUSH EAX 
				NEXTC
 000003EB  8B 07	     1	   MOV EAX, [EDI]
 000003ED  83 C7 04	     1	   ADD EDI, 4
 000003F0  FF E0	     1	   JMP EAX 
				;
 000003F2			_STACKERROR:
 000003F2  000003D5 R		DD _MSG22
 000003F6  00000406 R		DD do_SERROR
 000003FA  00 0A 53 54 41	DB 0, 10, 'STACKERROR'
	   43 4B 45 52 52
	   4F 52
 00000406			do_SERROR:
 00000406  8D 05 000009D4 R	LEA EAX, STACKERROR
 0000040C  50			PUSH EAX 
				NEXTC
 0000040D  8B 07	     1	   MOV EAX, [EDI]
 0000040F  83 C7 04	     1	   ADD EDI, 4
 00000412  FF E0	     1	   JMP EAX 
				;
 00000414			_ABORTFLAG:
 00000414  000003F2 R		DD _STACKERROR
 00000418  00000427 R		DD do_ABFLG
 0000041C  00 09 41 42 4F	DB 0, 9, 'ABORTFLAG'
	   52 54 46 4C 41
	   47
 00000427			do_ABFLG:
 00000427  8D 05 00000940 R	LEA EAX, ABORTFLAG
 0000042D  50			PUSH EAX
				NEXTC
 0000042E  8B 07	     1	   MOV EAX, [EDI]
 00000430  83 C7 04	     1	   ADD EDI, 4
 00000433  FF E0	     1	   JMP EAX 
				;
 00000435			_SEP1:
 00000435  00000414 R		DD _ABORTFLAG
 00000439  00000444 R		DD do_SEP1
 0000043D  00 05 53 45 50	DB 0, 5,'SEP1$'
	   31 24
 00000444			do_SEP1:
 00000444  8D 05 00000C42 R	LEA EAX, SEP1$
 0000044A  50			PUSH EAX
				NEXTC
 0000044B  8B 07	     1	   MOV EAX, [EDI]
 0000044D  83 C7 04	     1	   ADD EDI, 4
 00000450  FF E0	     1	   JMP EAX 
				;
 00000452			_FCOUNTER:
 00000452  00000435 R		DD _SEP1
 00000456  00000464 R		DD do_FCOUNTER
 0000045A  00 08 46 43 4F	DB 0, 8, 'FCOUNTER'
	   55 4E 54 45 52
 00000464			do_FCOUNTER:
 00000464  8D 05 0000096C R	LEA EAX, FCOUNTER
 0000046A  50			PUSH EAX
				NEXTC
 0000046B  8B 07	     1	   MOV EAX, [EDI]
 0000046D  83 C7 04	     1	   ADD EDI, 4
 00000470  FF E0	     1	   JMP EAX 
				;
 00000472			_MALADDR:
 00000472  00000452 R		DD _FCOUNTER
 00000476  00000487 R		DD do_MALADDR
 0000047A  00 0B 4D 41 4C	DB 0, 11, 'MALLOCHADDR'
	   4C 4F 43 48 41
	   44 44 52
 00000487			do_MALADDR:
 00000487  8D 05 00000988 R	LEA EAX, MALLOCHADDR
 0000048D  50			PUSH EAX
				NEXTC
 0000048E  8B 07	     1	   MOV EAX, [EDI]
 00000490  83 C7 04	     1	   ADD EDI, 4
 00000493  FF E0	     1	   JMP EAX 
				;
 00000495			_S_ADR:
 00000495  00000472 R		DD _MALADDR
 00000499  000004A4 R		DD do_S_ADR
 0000049D  00 05 53 5F 41	DB 0, 5, 'S_ADR'
	   44 52
 000004A4			do_S_ADR:
 000004A4  8D 05 000009B8 R	LEA EAX, S_ADR
 000004AA  50			PUSH EAX
				NEXTC
 000004AB  8B 07	     1	   MOV EAX, [EDI]
 000004AD  83 C7 04	     1	   ADD EDI, 4
 000004B0  FF E0	     1	   JMP EAX 
				;
 000004B2			_RO:
 000004B2  00000495 R		DD _S_ADR
 000004B6  00001665 R		DD do_DOCON
 000004BA  00 03 52 2F 4F	DB 0, 3, 'R/O'
 000004BF  80000000		DD -2147483648
;
 000004C3			_WO:
 000004C3  000004B2 R		DD _RO
 000004C7  00001665 R		DD do_DOCON
 000004CB  00 03 57 2F 4F	DB 0, 3, 'W/O'
 000004D0  40000000		DD 1073741824
				;
 000004D4			_RW:
 000004D4  000004C3 R		DD _WO
 000004D8  00001665 R		DD do_DOCON
 000004DC  00 03 52 2F 57	DB 0, 3, 'R/W'
 000004E1  C0000000		DD -1073741824
				;
 000004E5			_UB:
 000004E5  000004D4 R		DD _RW
 000004E9  000004F7 R		DD do_UB
 000004ED  00 08 55 53 45	DB 0, 8, 'USERBASE'
	   52 42 41 53 45
 000004F7			do_UB:
 000004F7  8D 05 00001ECE R	LEA EAX, USER_BASE
 000004FD  50			PUSH EAX
				NEXTC
 000004FE  8B 07	     1	   MOV EAX, [EDI]
 00000500  83 C7 04	     1	   ADD EDI, 4
 00000503  FF E0	     1	   JMP EAX 
				;
 00000505			_COMPF:
 00000505  000004E5 R		DD _UB
 00000509  00000515 R		DD do_COMPF
 0000050D  00 06 43 4F 4D	DB 0, 6, 'COMPF?'
	   50 46 3F
 00000515			do_COMPF:
 00000515  8D 05 00000950 R	LEA EAX, COMPFQ
 0000051B  50			PUSH EAX
				NEXTC
 0000051C  8B 07	     1	   MOV EAX, [EDI]
 0000051E  83 C7 04	     1	   ADD EDI, 4
 00000521  FF E0	     1	   JMP EAX 
				;
 00000523			_MESSAGES:
 00000523  00000505 R		DD _COMPF
 00000527  00000535 R		DD do_MESSAGES
 0000052B  00 08 4D 45 53	DB 0, 8, 'MESSAGES'
	   53 41 47 45 53
 00000535			do_MESSAGES:
 00000535  8D 05 00000C6D R	LEA EAX, MESSAGES
 0000053B  50			PUSH EAX
				NEXTC
 0000053C  8B 07	     1	   MOV EAX, [EDI]
 0000053E  83 C7 04	     1	   ADD EDI, 4
 00000541  FF E0	     1	   JMP EAX 
				;
 00000543			_MsgF1:
 00000543  00000523 R		dd _MESSAGES
 00000547  00000552 R		dd do_MsgF1
 0000054B  00 05 4D 73 67	db 0, 5, 'MsgF1'
	   46 31
 00000552			do_MsgF1:
 00000552  8D 05 00000C29 R	LEA EAX, MsgF1
 00000558  50			PUSH EAX
				NEXTC
 00000559  8B 07	     1	   MOV EAX, [EDI]
 0000055B  83 C7 04	     1	   ADD EDI, 4
 0000055E  FF E0	     1	   JMP EAX 
				;
 00000560			_LATEST: ; Returns address of the variable LATEST           ; VERIFIED
 00000560  00000543 R		DD _MsgF1
 00000564  00000570 R		DD do_LATEST
 00000568  00 06 4C 41 54	DB 0, 6,'LATEST'
	   45 53 54
 00000570			do_LATEST:
 00000570  8D 05 00000980 R	LEA EAX, LATEST
 00000576  50			PUSH EAX
				NEXTC
 00000577  8B 07	     1	   MOV EAX, [EDI]
 00000579  83 C7 04	     1	   ADD EDI, 4
 0000057C  FF E0	     1	   JMP EAX 
				;
				; ________________________________________________________________
				;                       END OF SYSTEM VARIABLE SECTION
				; ________________________________________________________________
				;                       Dictionary Begins
				; -------------------- PRIMITIVES CORE CODE ----------------------
				;
 0000057E			_NULL:              ; VERIFIED   231224
 0000057E  00000560 R		DD _LATEST
 00000582  0000058C R		DD NULL
 00000586  00 04 4E 55 4C	DB 0, 4, 'NULL'
	   4C
 0000058C			NULL:
				NEXTC
 0000058C  8B 07	     1	   MOV EAX, [EDI]
 0000058E  83 C7 04	     1	   ADD EDI, 4
 00000591  FF E0	     1	   JMP EAX 
				;
 00000593			_COLD:      ; VERIFIED
 00000593  0000057E R		DD _NULL 
 00000597  000005A1 R		DD COLD
 0000059B  00 04 43 4F 4C	DB 0, 4, 'COLD'
	   44
 000005A1			COLD:
 000005A1  54			PUSH ESP
 000005A2  8F 05 000009D0 R	POP S0                          ; Saving Stack Pointer Base 
 000005A8  8B 2D 000009B4 R	MOV EBP, [RSP]                  ; RETURN STACK POINTER
 000005AE  8D 05 00001EBD R	LEA EAX, _EOD                   ; END OF DATA VERY LAST WORD IN DICTIONARY
 000005B4  50			PUSH EAX
 000005B5  8F 05 00000980 R	POP LATEST
 000005BB  8D 05 00001ECE R	LEA EAX, USER_BASE
 000005C1  50			PUSH EAX
 000005C2  8F 05 00000968 R	POP DPR
 000005C8  C7 05 000009D8 R	MOV STATE, 0                    ;  Interpreter mode
	   00000000
 000005D2  8D 05 00001ECE R	    LEA EAX, USER_BASE          ; Calc Data SPACE USED 
 000005D8  8D 0D 00000000 R	    LEA ECX, DSB
 000005DE  2B C1		    SUB EAX, ECX
 000005E0  A3 000009DC R	    MOV TV1, EAX                ; Need to convert value to string & display
 000005E5  B8 000039C3 R	    MOV EAX, EOC                ; Calc Core SPACE USED 
 000005EA  2D 00000000 R	    SUB EAX, Forth_Thread
 000005EF  A3 000009E0 R	    MOV TV2, EAX                ; Need to convert value to string & display
 000005F4  A1 0000099C R	    MOV EAX, MEMLIMIT
 000005F9  2B 05 00000968 R	    SUB EAX, DPR                ; Calc Free Application space 
 000005FF  A3 000009E4 R	    MOV TV3, EAX                ; Need to convert value to string & display
 00000604  8D 05 00001B96 R	    LEA EAX, PAD                ; RESET PAD POINTER
 0000060A  A3 00000978 R	    MOV HLD, EAX
 0000060F  E8 00000000 E	    call GetProcessHeap 
 00000614  A3 00000988 R	    MOV MALLOCHADDR, EAX        ; heap address save in varIABLE
				NEXTC
 00000619  8B 07	     1	   MOV EAX, [EDI]
 0000061B  83 C7 04	     1	   ADD EDI, 4
 0000061E  FF E0	     1	   JMP EAX 
				;
 00000620			_ABT1:              ; USED IN NORMAL STARTUP
 00000620  00000593 R		DD _COLD
 00000624  0000062E R		DD do_ABT1
 00000628  00 04 41 42 54	DB 0, 4, 'ABT1'
	   31
 0000062E			do_ABT1:
 0000062E  68 00000638 R	PUSH $ + 10
 00000633  E9 00000FB2		JMP do_DOCOL
 00000638  00002289 R		DD do_WDCOUNT, PAD, do_DCW, do_FETCH
	   00001B96 R
	   0000031E R
	   00000922 R
 00000648  000021B9 R		DD do_dwtoa, PAD, do_PUSH0, do_STDOUT
	   00001B96 R
	   000008D6 R
	   000021F2 R
 00000658  0000038F R		DD do_CRLF, do_PUSH0, do_STDOUT
	   000008D6 R
	   000021F2 R
 00000664  0000038F R		DD do_CRLF, do_PUSH0, do_STDOUT
	   000008D6 R
	   000021F2 R
 00000670  000008D6 R		DD do_PUSH0, do_ABFLG, do_STORE
	   00000427 R
	   00000938 R
 0000067C  00000862 R		DD do_SEMI
				;
 00000680			_ABT2:              ; USED WHEN ERROR OCCURS
 00000680  00000620 R		DD _ABT1
 00000684  0000068E R		DD do_ABT2
 00000688  00 04 41 42 54	DB 0, 4, 'ABT2'
	   32
 0000068E			do_ABT2:
 0000068E  C7 05 00000940 R	MOV ABORTFLAG, 0    ; RESET ABORTFLAG
	   00000000
 00000698  8B 25 000009D0 R	MOV ESP , S0        ; RESET STACK POINTER
 0000069E  8B 2D 000009B4 R	MOV EBP, [RSP]      ; RESET RETURN STACK POINTER
 000006A4  C7 05 00000930 R	MOV _IN, 0          ; RESET IN BUFFER OFFSET
	   00000000
 000006AE  C7 05 000009C4 R	MOV S_LEN ,0        ; RESET IN BUFFER LENGTH
	   00000000
 000006B8  BF 00000008 R	MOV EDI, ABORT
 000006BD  83 C7 04		ADD EDI, 4          ; EDI POINTS TO do_QUIT IN FORTH THREAD
				NEXTC
 000006C0  8B 07	     1	   MOV EAX, [EDI]
 000006C2  83 C7 04	     1	   ADD EDI, 4
 000006C5  FF E0	     1	   JMP EAX 
				;
 000006C7			_ABORT:             ; VERIFIED
 000006C7  00000680 R		DD _ABT2
 000006CB  000006D6 R		DD do_ABORT
 000006CF  00 05 41 42 4F	DB 0, 5, 'ABORT'
	   52 54
 000006D6			do_ABORT:
 000006D6  68 000006E0 R	PUSH $ + 10
 000006DB  E9 00000F0A		JMP do_DOCOL
 000006E0  0000263B R		DD do_DECIMAL, do_PUSH0, do_STATE, do_STORE
	   000008D6 R
	   00000132 R
	   00000938 R
 000006F0  00000427 R		DD do_ABFLG, do_FETCH, do_EQU0
	   00000922 R
	   00000FCF R
 000006FC  00001F4C R		DD do_IF@, do_ABT1
	   0000062E R
 00000704  00001F88 R		DD do_ELSE@, do_ABT2
	   0000068E R
 0000070C  00001FAC R		DD do_THEN@
 00000710  00000862 R		DD do_SEMI
				;
 00000714			_ABORT@:
 00000714  000006C7 R		DD _ABORT
 00000718  00000725 R		DD do_ABORT@
 0000071C  00 07 28 41 42	DB 0, 7, '(ABORT)'
	   4F 52 54 29
 00000725			do_ABORT@:
 00000725  C7 05 00000940 R	MOV ABORTFLAG, -1
	   FFFFFFFF
 0000072F  8D 3D 00000008 R	LEA EDI, ABORT ; Load DI with Forth_Thread
				NEXTC
 00000735  8B 07	     1	   MOV EAX, [EDI]
 00000737  83 C7 04	     1	   ADD EDI, 4
 0000073A  FF E0	     1	   JMP EAX 
				;
 0000073C			_SCRINIT:
 0000073C  000006C7 R		DD _ABORT
 00000740  0000074D R		DD do_SCRINIT
 00000744  00 07 53 43 52	DB 0, 7, 'SCRINIT'
	   49 4E 49 54
 0000074D			do_SCRINIT:
 0000074D  E8 00000000 E	    call ClearScreen
 00000752  FF 35 000009F4 R	    push ypos
 00000758  FF 35 000009F0 R	    push xpos
 0000075E  E8 00000000 E	    call locate
 00000763  8D 05 000009F8 R	    lea eax, Msg1
 00000769  50			    push eax
 0000076A  E8 00000000 E	    call StdOut
 0000076F  8D 05 00000A14 R	    lea eax, Msg1A
 00000775  50			    push eax 
 00000776  E8 00000000 E	    call StdOut
 0000077B  8D 05 00000A2A R	    lea eax, Msg2
 00000781  50			    push eax
 00000782  E8 00000000 E	    call StdOut
 00000787  8D 05 00000C3F R	    lea eax, crlf$
 0000078D  50			    push eax 
 0000078E  E8 00000000 E	    call StdOut
 00000793  8D 05 00000B31 R	    lea eax, Msg12
 00000799  50			    push eax
 0000079A  E8 00000000 E	    call StdOut
 0000079F  FF 35 00000978 R	    push HLD
 000007A5  FF 35 000009DC R	    push TV1
 000007AB  E8 00000000 E	    call udw2str        ; Convert unsigned DWORD to string
 000007B0  FF 35 00000978 R	    push HLD
 000007B6  E8 00000000 E	    call StdOut
 000007BB  83 05 00000978 R	    ADD HLD, 16
	   10
 000007C2  8D 05 00000B60 R	    lea eax, Msg15 
 000007C8  50			    push eax
 000007C9  E8 00000000 E	    call StdOut
 000007CE  8D 05 00000B42 R	    lea eax, Msg13
 000007D4  50			    push eax
 000007D5  E8 00000000 E	    call StdOut
 000007DA  FF 35 00000978 R	    push HLD
 000007E0  FF 35 000009E0 R	    push TV2
 000007E6  E8 00000000 E	    call udw2str        ; Convert unsigned DWORD to string
 000007EB  FF 35 00000978 R	    push HLD
 000007F1  E8 00000000 E	    call StdOut
 000007F6  83 05 00000978 R	    ADD HLD, 16
	   10
 000007FD  8D 05 00000B60 R	    lea eax, Msg15
 00000803  50			    push eax
 00000804  E8 00000000 E	    call StdOut
 00000809  8D 05 00000B51 R	    lea eax, Msg14
 0000080F  50			    push eax
 00000810  E8 00000000 E	    call StdOut
 00000815  FF 35 00000978 R	    push HLD
 0000081B  FF 35 000009E4 R	    push TV3
 00000821  E8 00000000 E	    call udw2str        ; Convert unsigned DWORD to string
 00000826  FF 35 00000978 R	    push HLD
 0000082C  E8 00000000 E	    call StdOut
 00000831  83 05 00000978 R	    ADD HLD, 16
	   10
 00000838  8D 05 00000B6E R	    lea eax, Msg16
 0000083E  50			    push eax
 0000083F  E8 00000000 E	    call StdOut
 00000844  8D 05 00000B7C R	    lea eax, Msg17
 0000084A  50			    push eax
 0000084B  E8 00000000 E	    call StdOut
				NEXTC
 00000850  8B 07	     1	   MOV EAX, [EDI]
 00000852  83 C7 04	     1	   ADD EDI, 4
 00000855  FF E0	     1	   JMP EAX 
				;
 00000857			_SEMI:      ; VERIFIED  231224
 00000857  0000073C R		DD _SCRINIT
 0000085B  00000862 R		DD do_SEMI
 0000085F  00 01 3B		DB 0, 1, ';'
 00000862			do_SEMI:
 00000862  A1 000009D8 R	MOV EAX, [STATE]
 00000867  83 F8 00		CMP EAX, 0
 0000086A  74 25		JE SEM1
 0000086C  8D 1D 00000862 R	LEA EBX, do_SEMI
 00000872  A1 00000968 R	MOV EAX, [DPR]
 00000877  89 18		MOV [EAX], EBX
 00000879  FF 35 00000968 R	PUSH [DPR]
 0000087F  58			POP EAX
 00000880  83 C0 04		ADD EAX, 4
 00000883  50			PUSH EAX
 00000884  8F 05 00000968 R	POP [DPR]
				NEXTC
 0000088A  8B 07	     1	   MOV EAX, [EDI]
 0000088C  83 C7 04	     1	   ADD EDI, 4
 0000088F  FF E0	     1	   JMP EAX 
 00000891			SEM1:
 00000891  8B 7D 00		MOV EDI, [EBP]
 00000894  83 C5 04		ADD EBP, 4
				NEXTC
 00000897  8B 07	     1	   MOV EAX, [EDI]
 00000899  83 C7 04	     1	   ADD EDI, 4
 0000089C  FF E0	     1	   JMP EAX 
				;
 0000089E			_PUSH1:      ; ( -- 1 ) PUSH 1 onto data stack   ; VERIFIED
 0000089E  00000857 R		DD _SEMI
 000008A2  000008A9 R		DD do_PUSH1
 000008A6  00 01 31		DB 0, 1, '1'    ; Name of Definition counted string name
 000008A9			do_PUSH1: 
 000008A9  6A 01		PUSH 01H
				NEXTC        ; End of definition
 000008AB  8B 07	     1	   MOV EAX, [EDI]
 000008AD  83 C7 04	     1	   ADD EDI, 4
 000008B0  FF E0	     1	   JMP EAX 
				;
 000008B2			_RS:        ; Restore Stack pointer to base (  --  )    VERIFIED
 000008B2  0000089E R		DD _PUSH1
 000008B6  000008BE R		DD do_RS
 000008BA  00 02 2E 2E		DB 0, 2, '..'
 000008BE			do_RS:
 000008BE  8B 25 000009D0 R	MOV ESP , S0
				NEXTC
 000008C4  8B 07	     1	   MOV EAX, [EDI]
 000008C6  83 C7 04	     1	   ADD EDI, 4
 000008C9  FF E0	     1	   JMP EAX 
				;
 000008CB			_PUSH0:     ;( -- 0 ) PUSH 0 onto stack  ; VERIFIED
 000008CB  000008B2 R		DD _RS
 000008CF  000008D6 R		DD do_PUSH0
 000008D3  00 01 30		DB 0, 1, '0'
 000008D6			do_PUSH0:
 000008D6  6A 00		PUSH 0H
				NEXTC
 000008D8  8B 07	     1	   MOV EAX, [EDI]
 000008DA  83 C7 04	     1	   ADD EDI, 4
 000008DD  FF E0	     1	   JMP EAX 
				;
 000008DF			_LAST: ; Returns header addr of Last Word in Dict  VERIFIED 231227
 000008DF  000008CB R		DD _PUSH0
 000008E3  000008ED R		DD do_LAST
 000008E7  00 04 4C 41 53	DB 0, 4,'LAST'
	   54
 000008ED			do_LAST:
 000008ED  A1 00000980 R	MOV EAX, DWORD PTR [LATEST]
 000008F2  50			PUSH EAX
				NEXTC
 000008F3  8B 07	     1	   MOV EAX, [EDI]
 000008F5  83 C7 04	     1	   ADD EDI, 4
 000008F8  FF E0	     1	   JMP EAX 
				;
 000008FA			_COMPILE: ; ( XT -- )    compile xt following
 000008FA  000008DF R		DD _LAST
 000008FE			COMPILE: 
 000008FE  0000090B R		DD do_COMPILE
 00000902  00 07 43 4F 4D	DB 0, 7,'COMPILE'
	   50 49 4C 45
 0000090B			do_COMPILE:
 0000090B  8B 1F		mov  ebx, [edi] ; ip  equ  <edi>  Instruction Pointer for Forth
 0000090D  83 C7 04		add  edi, 4
				NEXTC
 00000910  8B 07	     1	   MOV EAX, [EDI]
 00000912  83 C7 04	     1	   ADD EDI, 4
 00000915  FF E0	     1	   JMP EAX 
				;
				;   -------------------- Memory Operators -------------------------------------
				;
 00000917			FETCH:  ; ( a1 -- n1 )  get the cell n1 from address a1    ; VERIFIED
 00000917  000008FA R		DD _COMPILE 
 0000091B  00000922 R		DD do_FETCH
 0000091F  00 01 40		DB 0, 1, "@"
 00000922			do_FETCH: 
 00000922  5B			    POP EBX 
 00000923  8B 1B		    mov ebx, 0 [ebx]
 00000925  53			    push ebx
				    NEXTC
 00000926  8B 07	     1	   MOV EAX, [EDI]
 00000928  83 C7 04	     1	   ADD EDI, 4
 0000092B  FF E0	     1	   JMP EAX 
				 ; 
 0000092D			h_STORE:  ; ( n1 a1 -- )  store cell n1 into address a1   ; VERIFIED
 0000092D  00000917 R		DD FETCH     
 00000931  00000938 R		DD do_STORE
 00000935  00 01 21		DB 0, 1, "!"
 00000938			do_STORE: 
 00000938  58			    POP EAX 
 00000939  5B			    POP EBX
 0000093A  89 18		    MOV [EAX], EBX
				    NEXTC
 0000093C  8B 07	     1	   MOV EAX, [EDI]
 0000093E  83 C7 04	     1	   ADD EDI, 4
 00000941  FF E0	     1	   JMP EAX 
				 ; 
 00000943			h_PLUSSTORE:      ; ( n1 a1 -- ) add cell n1 to the contents of address a1   ; VERIFIED
 00000943  0000092D R		DD h_STORE  
 00000947  0000094F R		DD do_PLUSSTORE
 0000094B  00 02 2B 21		DB 0, 2, "+!"
 0000094F			do_PLUSSTORE: 
 0000094F  5B			    POP EBX 
 00000950  58			    pop eax
 00000951  01 03		    add 0 [ebx], eax
				    NEXTC
 00000953  8B 07	     1	   MOV EAX, [EDI]
 00000955  83 C7 04	     1	   ADD EDI, 4
 00000958  FF E0	     1	   JMP EAX 
				 ; 
 0000095A			h_MINUSSTORE:      ; ( n1 a1 -- ) add cell n1 to the contents of address a1  ; VERIFIED
 0000095A  00000943 R		DD h_PLUSSTORE  
 0000095E  00000966 R		DD do_MINUSSTORE
 00000962  00 02 2D 21		DB 0, 2, "-!"
 00000966			do_MINUSSTORE: 
 00000966  5B			    POP EBX 
 00000967  58			    pop eax
 00000968  29 03		    SUB 0 [ebx], eax
				    NEXTC
 0000096A  8B 07	     1	   MOV EAX, [EDI]
 0000096C  83 C7 04	     1	   ADD EDI, 4
 0000096F  FF E0	     1	   JMP EAX 
				 ;
 00000971			CFETCH:      ; ( a1 -- c1 )     ;    fetch the character c1 from address a1 VERIFIED
 00000971  0000095A R		DD h_MINUSSTORE 
 00000975  0000097D R		DD do_CFETCH
 00000979  00 02 43 40		DB 0, 2, "C@"
 0000097D			do_CFETCH: 
 0000097D  5B			    POP EBX 
 0000097E  0F B6 1B		    movzx ebx, byte ptr 0 [ebx]
 00000981  53			    push ebx
				    NEXTC
 00000982  8B 07	     1	   MOV EAX, [EDI]
 00000984  83 C7 04	     1	   ADD EDI, 4
 00000987  FF E0	     1	   JMP EAX 
				 ; 
 00000989			CSTORE:      ; ( c1 a1 -- )     ;    store character c1 into address a1     VERIFIED
 00000989  00000971 R		DD CFETCH 
 0000098D  00000995 R		DD do_CSTORE
 00000991  00 02 43 21		DB 0, 2, "C!"
 00000995			do_CSTORE: 
 00000995  5B			    POP EBX 
 00000996  58			    pop eax
 00000997  88 03		    mov 0 [ebx], al
				    ; pop ebx
				    NEXTC
 00000999  8B 07	     1	   MOV EAX, [EDI]
 0000099B  83 C7 04	     1	   ADD EDI, 4
 0000099E  FF E0	     1	   JMP EAX 
				 ; 
 000009A0			CPLUSSTORE:    ; ( c1 a1 -- )     ;    add character c1 to the contents of address a1  VERIFIED
 000009A0  00000989 R		DD CSTORE  
 000009A4  000009AD R		DD do_CPLUSSTORE
 000009A8  00 03 43 2B 21	DB 0, 3, "C+!"
 000009AD			do_CPLUSSTORE: 
 000009AD  5B			    POP EBX 
 000009AE  58			    pop eax
 000009AF  00 03		    add 0 [ebx], al
				    NEXTC
 000009B1  8B 07	     1	   MOV EAX, [EDI]
 000009B3  83 C7 04	     1	   ADD EDI, 4
 000009B6  FF E0	     1	   JMP EAX 
				 ; 
 000009B8			WFETCH:      ; ( a1 -- w1 )     ;    fetch the word ; (16bit) w1 from address a1
 000009B8  000009A0 R		DD CPLUSSTORE
 000009BC  000009C4 R		DD do_WFETCH
 000009C0  00 02 57 40		DB 0, 2, "W@"
 000009C4			do_WFETCH: 
 000009C4  5B			    POP EBX 
 000009C5  0F B7 1B		    movzx ebx, word ptr 0 [ebx]
 000009C8  53			    push ebx
				    NEXTC
 000009C9  8B 07	     1	   MOV EAX, [EDI]
 000009CB  83 C7 04	     1	   ADD EDI, 4
 000009CE  FF E0	     1	   JMP EAX 
				 ; 
 000009D0			SWFETCH:     ; ( a1 -- w1 )     ;    fetch and sign extend the word ; 
 000009D0  000009B8 R		DD WFETCH 
 000009D4  000009DD R		DD do_SWFETCH
 000009D8  00 03 53 57 40	DB 0, 3, "SW@"
 000009DD			do_SWFETCH: 
 000009DD  5B			    POP EBX 
 000009DE  0F BF 1B		    movsx ebx, word ptr 0 [ebx]
 000009E1  53			    push ebx
				    NEXTC
 000009E2  8B 07	     1	   MOV EAX, [EDI]
 000009E4  83 C7 04	     1	   ADD EDI, 4
 000009E7  FF E0	     1	   JMP EAX 
				 ; 
 000009E9			WSTORE:      ; ( w1 a1 -- )     ;    store word ; (16bit) w1 into address a1
 000009E9  000009D0 R		DD SWFETCH 
 000009ED  000009F5 R		DD do_WSTORE
 000009F1  00 02 57 21		DB 0, 2, "W!"
 000009F5			do_WSTORE: 
 000009F5  5B			    POP EBX 
 000009F6  58			    pop eax
 000009F7  66| 89 03		    mov 0 [ebx], ax
 000009FA  5B			    pop ebx
				    NEXTC
 000009FB  8B 07	     1	   MOV EAX, [EDI]
 000009FD  83 C7 04	     1	   ADD EDI, 4
 00000A00  FF E0	     1	   JMP EAX 
				 ; 
 00000A02			WPLUSSTORE:     ; ( w1 a1 -- )     ;    add word ; (16bit) w1 to the contents of address a1
 00000A02  000009E9 R		DD WSTORE
 00000A06  00000A0F R		DD do_WPLUSSTORE
 00000A0A  00 03 57 2B 21	DB 0, 3, "W+!"
 00000A0F			do_WPLUSSTORE: 
 00000A0F  5B			    POP EBX 
 00000A10  58			    pop eax
 00000A11  66| 01 03		    add 0 [ebx], ax
 00000A14  5B			    pop ebx
				    NEXTC
 00000A15  8B 07	     1	   MOV EAX, [EDI]
 00000A17  83 C7 04	     1	   ADD EDI, 4
 00000A1A  FF E0	     1	   JMP EAX 
				; 
 00000A1C			MEMQ:                   ; ( -- n ) Checks memory useage limit  VERIFIED
 00000A1C  00000A02 R		DD WPLUSSTORE
 00000A20  00000A2A R		DD do_MEMQ
 00000A24  00 04 4D 45 4D	DB 0, 4, 'MEM?'
	   3F
 00000A2A			do_MEMQ:
 00000A2A  A1 0000099C R	MOV EAX, MEMLIMIT
 00000A2F  2B 05 00000968 R	SUB EAX, DPR
 00000A35  50			PUSH EAX
				NEXTC
 00000A36  8B 07	     1	   MOV EAX, [EDI]
 00000A38  83 C7 04	     1	   ADD EDI, 4
 00000A3B  FF E0	     1	   JMP EAX 
				;
				;    -------------------- Char Operators ---------------------------------------

 00000A3D			h_CHARS:  ; ( n1 -- n1*char )  ;    multiply n1 by the character size ; (1)  VERIFIED
 00000A3D  00000A1C R		DD MEMQ
 00000A41  00000A4C R		DD do_CHARS
 00000A45  00 05 43 48 41	DB 0, 5, "CHARS"
	   52 53
 00000A4C			do_CHARS: 
				    NEXTC
 00000A4C  8B 07	     1	   MOV EAX, [EDI]
 00000A4E  83 C7 04	     1	   ADD EDI, 4
 00000A51  FF E0	     1	   JMP EAX 
				 ; 
 00000A53			CHARPLUS:  ; ( a1 -- a1+char )  ;    add the characters size in bytes to a1  VERIFIED
 00000A53  00000A3D R		DD h_CHARS 
 00000A57  00000A62 R		DD do_CHARPLUS
 00000A5B  00 05 43 48 41	DB 0, 5, "CHAR+"
	   52 2B
 00000A62			do_CHARPLUS: 
 00000A62  5B			    POP EBX 
 00000A63  83 C3 01		    add ebx, 1
 00000A66  53			    push ebx
				    NEXTC
 00000A67  8B 07	     1	   MOV EAX, [EDI]
 00000A69  83 C7 04	     1	   ADD EDI, 4
 00000A6C  FF E0	     1	   JMP EAX 
				; 
				;    -------------------- Arithmetic Operators ---------------------------------
				;
 00000A6E			_PLUS:   ; ( n1 n2 -- n3 )  add n1 to n2, return sum n3   ; VERIFIED
 00000A6E  00000A53 R		DD CHARPLUS     
 00000A72  00000A79 R		DD do_PLUS
 00000A76  00 01 2B		DB 0, 1, "+"
 00000A79			do_PLUS: 
 00000A79  5B			    POP EBX   ; n2
 00000A7A  58			    pop eax   ; n1
 00000A7B  03 C3		    add eax, ebx   ; N1 + N2
 00000A7D  50			    PUSH EAX
				    NEXTC
 00000A7E  8B 07	     1	   MOV EAX, [EDI]
 00000A80  83 C7 04	     1	   ADD EDI, 4
 00000A83  FF E0	     1	   JMP EAX 
				 ; 
 00000A85			MINUS:   ; ( n1 n2 -- n3 ) subtract n2 from n1, return difference n3   ; VERIFIED
 00000A85  00000A6E R		DD _PLUS 
 00000A89  00000A90 R		DD do_MINUS
 00000A8D  00 01 2D		DB 0, 1, "-"
 00000A90			do_MINUS: 
 00000A90  5B			    POP EBX ; n2
 00000A91  58			    pop eax ; n1
 00000A92  2B C3		    sub eax, ebx ; n1 - n2
 00000A94  50			    push eax
				    NEXTC
 00000A95  8B 07	     1	   MOV EAX, [EDI]
 00000A97  83 C7 04	     1	   ADD EDI, 4
 00000A9A  FF E0	     1	   JMP EAX 
				 ; 
 00000A9C			UNDERPLUS:   ; ( a x b -- a+b x )  ;    add top of stack to third stack item    VERIFIED
 00000A9C  00000A85 R		DD MINUS 
 00000AA0  00000AAC R		DD do_UNDERPLUS
 00000AA4  00 06 55 4E 44	DB 0, 6, "UNDER+"
	   45 52 2B
 00000AAC			do_UNDERPLUS: 
 00000AAC  5B			    POP EBX 
 00000AAD  01 5C 24 04		    add 4 [esp], ebx
				    NEXTC
 00000AB1  8B 07	     1	   MOV EAX, [EDI]
 00000AB3  83 C7 04	     1	   ADD EDI, 4
 00000AB6  FF E0	     1	   JMP EAX 
				 ; 
 00000AB8			_NEGATE:   ; ( n1 -- n2 )  ;    negate n1, returning 2's complement n2  VERIFIED
 00000AB8  00000A9C R		DD UNDERPLUS  
 00000ABC  00000AC8 R		DD do_NEGATE
 00000AC0  00 06 4E 45 47	DB 0, 6, "NEGATE"
	   41 54 45
 00000AC8			do_NEGATE: 
 00000AC8  5B			    POP EBX 
 00000AC9  F7 DB		    neg ebx
 00000ACB  53			    push ebx
				    NEXTC
 00000ACC  8B 07	     1	   MOV EAX, [EDI]
 00000ACE  83 C7 04	     1	   ADD EDI, 4
 00000AD1  FF E0	     1	   JMP EAX 
				 ; 
 00000AD3			_ABS:     ; ( n -- |n| )  ;    return the absolute value of n1 as n2    VERIFIED
 00000AD3  00000AB8 R		DD _NEGATE 
 00000AD7  00000AE0 R		DD do_ABS
 00000ADB  00 03 41 42 53	DB 0, 3, "ABS"
 00000AE0			do_ABS: 
 00000AE0  5B			    POP EBX 
 00000AE1  8B CB		    mov ecx, ebx  ;    save value
 00000AE3  C1 F9 1F		    sar ecx, 31  ;    x < 0 ? 0xffffffff : 0
 00000AE6  33 D9		    xor ebx, ecx  ;    x < 0 ? ~x : x
 00000AE8  2B D9		    sub ebx, ecx  ;    x < 0 ? ; (~x)+1 : x
 00000AEA  53			    push ebx
				    NEXTC
 00000AEB  8B 07	     1	   MOV EAX, [EDI]
 00000AED  83 C7 04	     1	   ADD EDI, 4
 00000AF0  FF E0	     1	   JMP EAX 
				 ; 
 00000AF2			_2TIMES:      ; ( n1 -- n2 )  ;    multiply n1 by two       VERIFIED
 00000AF2  00000AD3 R		DD _ABS 
 00000AF6  00000AFE R		DD do_2TIMES
 00000AFA  00 02 32 2A		DB 0, 2, "2*"
 00000AFE			do_2TIMES: 
 00000AFE  5B			    POP EBX 
 00000AFF  03 DB		    add ebx, ebx
 00000B01  53			    push ebx
				    NEXTC
 00000B02  8B 07	     1	   MOV EAX, [EDI]
 00000B04  83 C7 04	     1	   ADD EDI, 4
 00000B07  FF E0	     1	   JMP EAX 
				 ; 
 00000B09			_2DIVIDE:      ; ( n1 -- n2 )  ;    signed divide n1 by two     VERIFIED
 00000B09  00000AF2 R		DD _2TIMES 
 00000B0D  00000B15 R		DD do_2DIVIDE
 00000B11  00 02 32 2F		DB 0, 2, "2/"
 00000B15			do_2DIVIDE: 
 00000B15  5B			    POP EBX 
 00000B16  D1 FB		    sar ebx, 1
 00000B18  53			    push ebx
				    NEXTC
 00000B19  8B 07	     1	   MOV EAX, [EDI]
 00000B1B  83 C7 04	     1	   ADD EDI, 4
 00000B1E  FF E0	     1	   JMP EAX 
				 ; 
 00000B20			U2DIVIDE:     ; ( n1 -- n2 )  ;    unsigned divide n1 by two
 00000B20  00000B09 R		DD _2DIVIDE 
 00000B24  00000B2D R		DD do_U2DIVIDE
 00000B28  00 03 55 32 2F	DB 0, 3, "U2/"
 00000B2D			do_U2DIVIDE: 
 00000B2D  5B			    POP EBX 
 00000B2E  D1 EB		    shr ebx, 1
 00000B30  53			    PUSH EBX
				    NEXTC
 00000B31  8B 07	     1	   MOV EAX, [EDI]
 00000B33  83 C7 04	     1	   ADD EDI, 4
 00000B36  FF E0	     1	   JMP EAX 
				 ; 
 00000B38			_1PLUS:     ; ( n1 -- n2 )  add one to n1   ; VERIFIED
 00000B38  00000B20 R		DD U2DIVIDE
 00000B3C  00000B44 R		DD do_1PLUS
 00000B40  00 02 31 2B		DB 0, 2, "1+"
 00000B44			do_1PLUS: 
 00000B44  5B			    POP EBX 
 00000B45  83 C3 01		    add ebx, 1
 00000B48  53			    push ebx
				    NEXTC
 00000B49  8B 07	     1	   MOV EAX, [EDI]
 00000B4B  83 C7 04	     1	   ADD EDI, 4
 00000B4E  FF E0	     1	   JMP EAX 
				 ; 
 00000B50			_1MINUS:      ; ( n1 -- n2 )  subtract one from n1    ; VERIFIED
 00000B50  00000B38 R		DD _1PLUS
 00000B54  00000B5C R		DD do_1MINUS
 00000B58  00 02 31 2D		DB 0, 2, "1-"
 00000B5C			do_1MINUS: 
 00000B5C  5B			    POP EBX 
 00000B5D  83 EB 01		    sub ebx, 1
 00000B60  53			    push ebx
				    NEXTC
 00000B61  8B 07	     1	   MOV EAX, [EDI]
 00000B63  83 C7 04	     1	   ADD EDI, 4
 00000B66  FF E0	     1	   JMP EAX 
				 ; 
 00000B68			D2TIMES:     ; ( d1 -- d2 )  ;    multiply the double number d1 by two
 00000B68  00000B50 R		DD _1MINUS
 00000B6C  00000B75 R		DD do_D2TIMES
 00000B70  00 03 44 32 2A	DB 0, 3, "D2*"
 00000B75			do_D2TIMES: 
 00000B75  5B			    POP EBX 
 00000B76  58			    pop eax
 00000B77  D1 E0		    shl eax, 1
 00000B79  D1 D3		    rcl ebx, 1
 00000B7B  50			    push eax
 00000B7C  53			    PUSH EBX
				    NEXTC
 00000B7D  8B 07	     1	   MOV EAX, [EDI]
 00000B7F  83 C7 04	     1	   ADD EDI, 4
 00000B82  FF E0	     1	   JMP EAX 
				 ; 
 00000B84			D2DIVIDE:     ; ( d1 -- d2 )  ;    divide the double number d1 by two
 00000B84  00000B68 R		DD D2TIMES
 00000B88  00000B91 R		DD do_D2DIVIDE
 00000B8C  00 03 44 32 2F	DB 0, 3, "D2/"
 00000B91			do_D2DIVIDE: 
 00000B91  5B			    POP EBX 
 00000B92  58			    pop eax
 00000B93  D1 FB		    sar ebx, 1
 00000B95  D1 D8		    rcr eax, 1
 00000B97  50			    push eax
 00000B98  53			    PUSH EBX
				    NEXTC
 00000B99  8B 07	     1	   MOV EAX, [EDI]
 00000B9B  83 C7 04	     1	   ADD EDI, 4
 00000B9E  FF E0	     1	   JMP EAX 
				 ; 
 00000BA0			RROT32:  	; ( n1 n2 -- ror) ; ( 32 Bit Rotation of word right)
 00000BA0  00000B84 R		DD D2DIVIDE
 00000BA4  00000BB0 R		DD do_RROT32
 00000BA8  00 06 52 52 4F	DB 0, 6, "RROT32"
	   54 33 32
 00000BB0			do_RROT32: 
 00000BB0  59			 POP ECX
 00000BB1  5B			 POP EBX
 00000BB2  D3 CB		 ror ebx, cl
 00000BB4  53			 push ebx
				    NEXTC
 00000BB5  8B 07	     1	   MOV EAX, [EDI]
 00000BB7  83 C7 04	     1	   ADD EDI, 4
 00000BBA  FF E0	     1	   JMP EAX 
				 ; 
 00000BBC			LROT32:  	; ( n1 n2 -- rol) ; ( 32 Bit Rotation of word left)
 00000BBC  00000BA0 R		DD RROT32
 00000BC0  00000BCC R		DD do_LROT32
 00000BC4  00 06 4C 52 4F	DB 0, 6, "LROT32"
	   54 33 32
 00000BCC			do_LROT32: 
 00000BCC  59			 POP ECX 
 00000BCD  5B			 pop ebx
 00000BCE  D3 C3		 rol ebx, cl
 00000BD0  53			 push ebx
				    NEXTC
 00000BD1  8B 07	     1	   MOV EAX, [EDI]
 00000BD3  83 C7 04	     1	   ADD EDI, 4
 00000BD6  FF E0	     1	   JMP EAX 
				 ; 
 00000BD8			_GETADDR:  	; ( addr1, size, count -- addr2 )  ;    for an array
 00000BD8  00000BBC R		DD LROT32 
 00000BDC  00000BE9 R		DD do_GETADDR
 00000BE0  00 07 47 45 54	DB 0, 7, "GETADDR"
	   41 44 44 52
 00000BE9			do_GETADDR: 
 00000BE9  58			    POP EAX 
 00000BEA  5B				pop ebx
 00000BEB  52				push edx
 00000BEC  F7 EB			imul ebx
 00000BEE  5A				pop edx
 00000BEF  5B				pop ebx
 00000BF0  03 C3			add eax, ebx
 00000BF2  50				push eax
				    NEXTC
 00000BF3  8B 07	     1	   MOV EAX, [EDI]
 00000BF5  83 C7 04	     1	   ADD EDI, 4
 00000BF8  FF E0	     1	   JMP EAX 
				;
 00000BFA			LIT:  ; ( -- n )  push the literal value following LIT in the ; VERIFIED
 00000BFA  00000BD8 R		DD _GETADDR
 00000BFE  00000C07 R		DD do_LIT
 00000C02  00 03 4C 49 54	DB 0, 3, "LIT"
 00000C07			do_LIT:              ;  PUSH onto the data stack
 00000C07  8B 1F		    mov ebx, [EDI]
 00000C09  53			    PUSH EBX
 00000C0A  83 C7 04		    ADD EDI , 4
				    NEXTC
 00000C0D  8B 07	     1	   MOV EAX, [EDI]
 00000C0F  83 C7 04	     1	   ADD EDI, 4
 00000C12  FF E0	     1	   JMP EAX 
				 ; 
 00000C14			DROP:  ; ( n -- )   discard top entry on data stack   ; VERIFIED
 00000C14  00000BFA R		DD LIT  
 00000C18  00000C22 R		DD do_DROP
 00000C1C  00 04 44 52 4F	DB 0, 4, "DROP"
	   50
 00000C22			do_DROP: 
 00000C22  5B			    POP EBX 
				    NEXTC
 00000C23  8B 07	     1	   MOV EAX, [EDI]
 00000C25  83 C7 04	     1	   ADD EDI, 4
 00000C28  FF E0	     1	   JMP EAX 
				 ; 
 00000C2A			h_DUP:     ; ( n -- n n )    duplicate top entry on data stack   ; VERIFIED
 00000C2A  00000C14 R		DD DROP  
 00000C2E  00000C37 R		DD do_DUP
 00000C32  00 03 44 55 50	DB 0, 3, "DUP"
 00000C37			do_DUP: 
 00000C37  8B 1C 24		    MOV EBX , 0 [ESP] 
 00000C3A  53			    push ebx
				    NEXTC
 00000C3B  8B 07	     1	   MOV EAX, [EDI]
 00000C3D  83 C7 04	     1	   ADD EDI, 4
 00000C40  FF E0	     1	   JMP EAX 
				 ; 
 00000C42			SWAP:  ; ( n1 n2 -- n2 n1 )  exchange first and second items on data stack  ; VERIFIED
 00000C42  00000C2A R		DD h_DUP  
 00000C46  00000C50 R		DD do_SWAP
 00000C4A  00 04 53 57 41	DB 0, 4, "SWAP"
	   50
 00000C50			do_SWAP: 
 00000C50  5B			    POP EBX 
 00000C51  8B 04 24		    mov eax, [esp]
 00000C54  89 1C 24		    mov [esp], ebx
 00000C57  8B D8		    mov ebx, eax
 00000C59  53			    PUSH EBX
				    NEXTC
 00000C5A  8B 07	     1	   MOV EAX, [EDI]
 00000C5C  83 C7 04	     1	   ADD EDI, 4
 00000C5F  FF E0	     1	   JMP EAX 
				 ; 
 00000C61			OVER:  ; ( n1 n2 -- n1 n2 n1 )  copy second item to top of data stack   ; VERIFIED
 00000C61  00000C42 R		DD SWAP
 00000C65  00000C6F R		DD do_OVER
 00000C69  00 04 4F 56 45	DB 0, 4, "OVER"
	   52
 00000C6F			do_OVER: 
 00000C6F  8B 5C 24 04		    mov ebx, 4 [esp]
 00000C73  53			    PUSH EBX
				    NEXTC
 00000C74  8B 07	     1	   MOV EAX, [EDI]
 00000C76  83 C7 04	     1	   ADD EDI, 4
 00000C79  FF E0	     1	   JMP EAX 
				 ; 
 00000C7B			ROT:     ; ( n1 n2 n3 -- n2 n3 n1 )  rotate third item to top of data stack ; VERIFIED
 00000C7B  00000C61 R		DD OVER 
 00000C7F  00000C88 R		DD do_ROT
 00000C83  00 03 52 4F 54	DB 0, 3, "ROT"
 00000C88			do_ROT: 
 00000C88  5B			    POP EBX 
 00000C89  8B 0C 24		    mov ecx, 0 [esp]
 00000C8C  8B 44 24 04		    mov eax, 4 [esp]
 00000C90  89 1C 24		    mov 0 [esp], ebx
 00000C93  89 4C 24 04		    mov 4 [esp], ecx
 00000C97  8B D8		    mov ebx, eax
 00000C99  53			    PUSH EBX
				    NEXTC
 00000C9A  8B 07	     1	   MOV EAX, [EDI]
 00000C9C  83 C7 04	     1	   ADD EDI, 4
 00000C9F  FF E0	     1	   JMP EAX 
				 ; 
 00000CA1			MINUSROT:  ; ( n1 n2 n3 -- n3 n1 n2 )  ;    rotate top of data stack to third item  VERIFIED
 00000CA1  00000C7B R		DD ROT   
 00000CA5  00000CAF R		DD do_MINUSROT
 00000CA9  00 04 2D 52 4F	DB 0, 4, "-ROT"
	   54
 00000CAF			do_MINUSROT: 
 00000CAF  5B			    POP EBX 
 00000CB0  8B 4C 24 04		    mov ecx, 4 [esp]
 00000CB4  8B 04 24		    mov eax, 0 [esp]
 00000CB7  89 5C 24 04		    mov 4 [esp], ebx
 00000CBB  89 0C 24		    mov 0 [esp], ecx
 00000CBE  8B D8		    mov ebx, eax
 00000CC0  53			    PUSH EBX
				    NEXTC
 00000CC1  8B 07	     1	   MOV EAX, [EDI]
 00000CC3  83 C7 04	     1	   ADD EDI, 4
 00000CC6  FF E0	     1	   JMP EAX 
				 ; 
 00000CC8			IFDUP:  ; ( n -- n [n] )  ;    duplicate top of data stack if non-zero      VERIFIED
 00000CC8  00000CA1 R		DD MINUSROT
 00000CCC  00000CD6 R		DD do_IFDUP
 00000CD0  00 04 3F 44 55	DB 0, 4, "?DUP"
	   50
 00000CD6			do_IFDUP: 
 00000CD6  5B			    POP EBX 
 00000CD7  53			    PUSH EBX
 00000CD8  85 DB		    test    ebx, ebx
 00000CDA  74 01		    je short @@1A
 00000CDC  53			    push    ebx
 00000CDD			@@1A:
				    NEXTC
 00000CDD  8B 07	     1	   MOV EAX, [EDI]
 00000CDF  83 C7 04	     1	   ADD EDI, 4
 00000CE2  FF E0	     1	   JMP EAX 
				 ; 
 00000CE4			NIP:     ; ( n1 n2 -- n2 )  ;    discard second item on data stack      VERIFIED
 00000CE4  00000CC8 R		DD IFDUP 
 00000CE8  00000CF1 R		DD do_NIP
 00000CEC  00 03 4E 49 50	DB 0, 3, "NIP"
 00000CF1			do_NIP: 
 00000CF1  5B			    POP EBX 
 00000CF2  58			    POP EAX
 00000CF3  53			    PUSH EBX
				    NEXTC
 00000CF4  8B 07	     1	   MOV EAX, [EDI]
 00000CF6  83 C7 04	     1	   ADD EDI, 4
 00000CF9  FF E0	     1	   JMP EAX 
				 ; 
 00000CFB			TUCK:  ; ( n1 n2 -- n2 n1 n2 )  ;    copy top data stack to under second item      VERIFIED 
 00000CFB  00000CE4 R		DD NIP       ; SWAP OVER
 00000CFF  00000D09 R		DD do_TUCK
 00000D03  00 04 54 55 43	DB 0, 4, "TUCK"
	   4B
 00000D09			do_TUCK: 
 00000D09  5B			    POP EBX
 00000D0A  FF 34 24		    PUSH 0 [ESP]
 00000D0D  89 5C 24 04		    MOV 4 [ESP], EBX
 00000D11  53			    PUSH EBX
				    NEXTC
 00000D12  8B 07	     1	   MOV EAX, [EDI]
 00000D14  83 C7 04	     1	   ADD EDI, 4
 00000D17  FF E0	     1	   JMP EAX 
				 ; 
 00000D19			h_PICK:  ; ( ... k -- ... n[k] )   VERIFIED     
 00000D19  00000CFB R		DD TUCK 
 00000D1D  00000D27 R		DD do_PICK
 00000D21  00 04 50 49 43	DB 0, 4, "PICK"
	   4B
 00000D27			do_PICK: 
 00000D27  5B			    POP EBX 
 00000D28  8B 1C 9C		    mov ebx, 0 [esp] [ebx*4]  ;    just like that!
 00000D2B  53			    PUSH EBX
				    NEXTC
 00000D2C  8B 07	     1	   MOV EAX, [EDI]
 00000D2E  83 C7 04	     1	   ADD EDI, 4
 00000D31  FF E0	     1	   JMP EAX 
				; 
				;   -------------------- Double Arithmetic Operators --------------------------
 00000D33			StoD:       ; ( n1 -- d1 )   convert single signed single n1 to a signed double d1
 00000D33  00000D19 R		DD h_PICK 
 00000D37  00000D40 R		DD do_StoD
 00000D3B  00 03 53 3E 44	DB 0, 3, 'S>D'
 00000D40			do_StoD:
 00000D40  5B			    pop     ebx
 00000D41  53			    push    ebx
 00000D42  D1 E3		    shl     ebx, 1         ;   put sign bit into carry
 00000D44  1B DB		    sbb     ebx, ebx
 00000D46  53			    push    ebx
				    NEXTC
 00000D47  8B 07	     1	   MOV EAX, [EDI]
 00000D49  83 C7 04	     1	   ADD EDI, 4
 00000D4C  FF E0	     1	   JMP EAX 
				;
				;    -------------------- Cell Operators ---------------------------------------

 00000D4E			_CELL:  ; ( -- 4 ) cell size        ; VERIFIED
 00000D4E  00000D33 R		DD StoD  
 00000D52  00000D5C R		DD do_CELL
 00000D56  00 04 43 45 4C	DB 0, 4, "CELL"
	   4C
 00000D5C			do_CELL: 
 00000D5C  6A 04		    PUSH 4
				    NEXTC
 00000D5E  8B 07	     1	   MOV EAX, [EDI]
 00000D60  83 C7 04	     1	   ADD EDI, 4
 00000D63  FF E0	     1	   JMP EAX 
				 ; 
 00000D65			_CELLS:  ; ( n1 -- n1*cell )  ;    multiply n1 by the cell size     ; VERIFIED
 00000D65  00000D4E R		DD _CELL 
 00000D69  00000D74 R		DD do_CELLS
 00000D6D  00 05 43 45 4C	DB 0, 5, "CELLS"
	   4C 53
 00000D74			do_CELLS: 
 00000D74  5B			    POP EBX 
 00000D75  C1 E3 02		    shl ebx, 2
 00000D78  53			    PUSH EBX
				    NEXTC
 00000D79  8B 07	     1	   MOV EAX, [EDI]
 00000D7B  83 C7 04	     1	   ADD EDI, 4
 00000D7E  FF E0	     1	   JMP EAX 
				 ; 
 00000D80			CELLSPLUS:  ; ( a1 n1 -- a1+n1*cell )  ;    multiply n1 by the cell size and add  ; VERIFIED
 00000D80  00000D65 R		DD _CELLS  
 00000D84  00000D90 R		DD do_CELLSPLUS
 00000D88  00 06 43 45 4C	DB 0, 6, "CELLS+"
	   4C 53 2B
 00000D90			do_CELLSPLUS: 
 00000D90  5B			    POP EBX 
				     ;    the result to address a1
 00000D91  58			    pop eax
 00000D92  8D 1C 98		    lea ebx, 0 [ebx*4] [eax]
 00000D95  53			    PUSH EBX
				    NEXTC
 00000D96  8B 07	     1	   MOV EAX, [EDI]
 00000D98  83 C7 04	     1	   ADD EDI, 4
 00000D9B  FF E0	     1	   JMP EAX 
				 ; 
 00000D9D			CELLSMINUS:  ; ( a1 n1 -- a1-n1*cell )  ;    multiply n1 by the cell size and subtract  ; VERIFIED
 00000D9D  00000D80 R		DD CELLSPLUS 
 00000DA1  00000DAD R		DD do_CELLSMINUS
 00000DA5  00 06 43 45 4C	DB 0, 6, "CELLS-"
	   4C 53 2D
 00000DAD			do_CELLSMINUS: 
 00000DAD  5B			    POP EBX 
				     ;    the result from address a1
 00000DAE  8D 04 9D		    lea eax, 0 [ebx*4]
	   00000000
 00000DB5  5B			    pop ebx
 00000DB6  2B D8		    sub ebx, eax
 00000DB8  53			    PUSH EBX
				    NEXTC
 00000DB9  8B 07	     1	   MOV EAX, [EDI]
 00000DBB  83 C7 04	     1	   ADD EDI, 4
 00000DBE  FF E0	     1	   JMP EAX 
				 ; 
 00000DC0			CELLPLUS:  ; ( a1 -- a1+cell )  ;    add a cell to a1  ; VERIFIED
 00000DC0  00000D9D R		DD CELLSMINUS  
 00000DC4  00000DCF R		DD do_CELLPLUS
 00000DC8  00 05 43 45 4C	DB 0, 5, "CELL+"
	   4C 2B
 00000DCF			do_CELLPLUS: 
 00000DCF  5B			    POP EBX 
 00000DD0  83 C3 04		    add ebx, 4
 00000DD3  53			    PUSH EBX
				    NEXTC
 00000DD4  8B 07	     1	   MOV EAX, [EDI]
 00000DD6  83 C7 04	     1	   ADD EDI, 4
 00000DD9  FF E0	     1	   JMP EAX 
				 ; 
 00000DDB			CELLMINUS:  ; ( a1 -- a1-cell )  ;    subtract a cell from a1  ; VERIFIED
 00000DDB  00000DC0 R		DD CELLPLUS 
 00000DDF  00000DEA R		DD do_CELLMINUS
 00000DE3  00 05 43 45 4C	DB 0, 5, "CELL-"
	   4C 2D
 00000DEA			do_CELLMINUS: 
 00000DEA  5B			    POP EBX 
 00000DEB  83 EB 04		    sub ebx, 4
 00000DEE  53			    PUSH EBX
				    NEXTC
 00000DEF  8B 07	     1	   MOV EAX, [EDI]
 00000DF1  83 C7 04	     1	   ADD EDI, 4
 00000DF4  FF E0	     1	   JMP EAX 
				 ; 
 00000DF6			PLUSCELLS:  ; ( n1 a1 -- n1*cell+a1 )  ;    multiply n1 by the cell size and add ; VERIFIED
 00000DF6  00000DDB R		DD CELLMINUS  
 00000DFA  00000E06 R		DD do_PLUSCELLS
 00000DFE  00 06 2B 43 45	DB 0, 6, "+CELLS"
	   4C 4C 53
 00000E06			do_PLUSCELLS: 
 00000E06  5B			    POP EBX 
				     ;    the result to address a1
 00000E07  58			    pop eax
 00000E08  8D 1C 83		    lea ebx, 0 [eax*4] [ebx]
 00000E0B  53			    PUSH EBX
				    NEXTC
 00000E0C  8B 07	     1	   MOV EAX, [EDI]
 00000E0E  83 C7 04	     1	   ADD EDI, 4
 00000E11  FF E0	     1	   JMP EAX 
				 ; 
 00000E13			MINUSCELLS:  ; ( n1 a1 -- a1-n1*cell )  ;    multiply n1 by the cell size and ; VERIFIED
 00000E13  00000DF6 R		DD PLUSCELLS  
 00000E17  00000E23 R		DD do_MINUSCELLS
 00000E1B  00 06 2D 43 45	DB 0, 6, "-CELLS"
	   4C 4C 53
 00000E23			do_MINUSCELLS: 
 00000E23  5B			    POP EBX 
				     ;    subtract the result from address a1
 00000E24  58			    pop eax
 00000E25  C1 E0 02		    shl eax, 2
 00000E28  2B D8		    sub ebx, eax
 00000E2A  53			    PUSH EBX
				    NEXTC
 00000E2B  8B 07	     1	   MOV EAX, [EDI]
 00000E2D  83 C7 04	     1	   ADD EDI, 4
 00000E30  FF E0	     1	   JMP EAX 
				; 
				;    -------------------- Stack Operations -------------------------------------
				;
 00000E32			_DEPTH:         ; ( -- n ) return the current data stack depth (n excluded)  ; VERIFIED
 00000E32  00000E13 R		DD MINUSCELLS
 00000E36  00000E41 R		DD do_DEPTH
 00000E3A  00 05 44 45 50	DB 0, 5, 'DEPTH'
	   54 48
 00000E41			do_DEPTH:
 00000E41  8B 1D 000009D0 R	    mov     ebx, S0 
 00000E47  2B DC		    sub     ebx, esp
 00000E49  C1 FB 02		    sar     ebx, 2  ; shift right two is divide by 4
 00000E4C  53			    PUSH EBX
				    NEXTC
 00000E4D  8B 07	     1	   MOV EAX, [EDI]
 00000E4F  83 C7 04	     1	   ADD EDI, 4
 00000E52  FF E0	     1	   JMP EAX 
				;
 00000E54			SPFETCH:     ; ( -- addr )  ;    get addr, the pointer to the top item on data stack  ; VERIFIED
 00000E54  00000E32 R		DD _DEPTH    
 00000E58  00000E61 R		DD do_SPFETCH
 00000E5C  00 03 53 50 40	DB 0, 3, "SP@"
 00000E61			do_SPFETCH: 
 00000E61  54			    PUSH ESP
				    NEXTC
 00000E62  8B 07	     1	   MOV EAX, [EDI]
 00000E64  83 C7 04	     1	   ADD EDI, 4
 00000E67  FF E0	     1	   JMP EAX 
				 ;  
 00000E69			SPSTORE:     ; ( addr -- )  ;    set the data stack to point to addr   ; VERIFIED
 00000E69  00000E54 R		DD SPFETCH  
 00000E6D  00000E76 R		DD do_SPSTORE
 00000E71  00 03 53 50 21	DB 0, 3, "SP!"
 00000E76			do_SPSTORE: 
 00000E76  5B			    POP EBX 
 00000E77  8B E3		    mov esp, ebx
				    NEXTC
 00000E79  8B 07	     1	   MOV EAX, [EDI]
 00000E7B  83 C7 04	     1	   ADD EDI, 4
 00000E7E  FF E0	     1	   JMP EAX 
				 ; 
 00000E80			RPFETCH:     ; ( -- a1 )  ;    get a1 the address of the return stack   ; VERIFIED
 00000E80  00000E69 R		DD SPSTORE     
 00000E84  00000E8D R		DD do_RPFETCH
 00000E88  00 03 52 50 40	DB 0, 3, "RP@"
 00000E8D			do_RPFETCH: 
 00000E8D  55			    PUSH EBP
				    NEXTC
 00000E8E  8B 07	     1	   MOV EAX, [EDI]
 00000E90  83 C7 04	     1	   ADD EDI, 4
 00000E93  FF E0	     1	   JMP EAX 
				 ; 
 00000E95			RPSTORE:     ; ( a1 -- )  ;    set the address of the return stack   ; VERIFIED
 00000E95  00000E80 R		DD RPFETCH 
 00000E99  00000EA2 R		DD do_RPSTORE
 00000E9D  00 03 52 50 21	DB 0, 3, "RP!"
 00000EA2			do_RPSTORE: 
 00000EA2  5B			    POP EBX 
 00000EA3  8B EB		    mov EBP, ebx
				    NEXTC
 00000EA5  8B 07	     1	   MOV EAX, [EDI]
 00000EA7  83 C7 04	     1	   ADD EDI, 4
 00000EAA  FF E0	     1	   JMP EAX 
				 ; 
 00000EAC			TOR:      ; ( n1 -- ) ; ( R: -- n1 )  push n1 onto the return stack   ; VERIFIED
 00000EAC  00000E95 R		DD RPSTORE  
 00000EB0  00000EB8 R		DD do_TOR
 00000EB4  00 02 3E 52		DB 0, 2, ">R"
 00000EB8			do_TOR: 
 00000EB8  58			POP EAX
 00000EB9  83 ED 04		SUB EBP, 4
 00000EBC  89 45 00		MOV [EBP], EAX
				NEXTC
 00000EBF  8B 07	     1	   MOV EAX, [EDI]
 00000EC1  83 C7 04	     1	   ADD EDI, 4
 00000EC4  FF E0	     1	   JMP EAX 
				 ; 
 00000EC6			FROMR:      ; ( -- n1 ) ; ( R: n1 -- )  ;    pop n1 off the return stack  ; VERIFIED
 00000EC6  00000EAC R		DD TOR      
 00000ECA  00000ED2 R		DD do_FROMR
 00000ECE  00 02 52 3E		DB 0, 2, "R>"
 00000ED2			do_FROMR: 
 00000ED2  8B 45 00		MOV EAX, [EBP] 
 00000ED5  50			PUSH EAX
 00000ED6  83 C5 04		ADD EBP, 4
				NEXTC
 00000ED9  8B 07	     1	   MOV EAX, [EDI]
 00000EDB  83 C7 04	     1	   ADD EDI, 4
 00000EDE  FF E0	     1	   JMP EAX 
				 ; 
 00000EE0			RFETCH:      ; ( -- n1 ) ; ( R: n1 -- n1 )  ;    get a copy of the top of the return stack  ; VERIFIED
 00000EE0  00000EC6 R		DD FROMR
 00000EE4  00000EEC R		DD do_RFETCH
 00000EE8  00 02 52 40		DB 0, 2, "R@"
 00000EEC			do_RFETCH: 
 00000EEC  8B 45 00		MOV EAX, [EBP]
 00000EEF  50			PUSH EAX
				NEXTC
 00000EF0  8B 07	     1	   MOV EAX, [EDI]
 00000EF2  83 C7 04	     1	   ADD EDI, 4
 00000EF5  FF E0	     1	   JMP EAX 
				 ; 
 00000EF7			DUPTOR:  ; ( n1 -- n1 ) ; ( R: -- n1 )  ;    push a copy of n1 onto the return stack  ; VERIFIED
 00000EF7  00000EE0 R		DD RFETCH 
 00000EFB  00000F06 R		DD do_DUPTOR
 00000EFF  00 05 44 55 50	DB 0, 5, "DUP>R"
	   3E 52
 00000F06			do_DUPTOR: 
 00000F06  8B 1C 24		    mov ebx, [ESP]
 00000F09  83 ED 04		    SUB EBP, 4
 00000F0C  89 5D 00		    mov [EBP], ebx
				    NEXTC
 00000F0F  8B 07	     1	   MOV EAX, [EDI]
 00000F11  83 C7 04	     1	   ADD EDI, 4
 00000F14  FF E0	     1	   JMP EAX 
				 ; 
 00000F16			RFROMDROP:  ; ( -- ) ; ( R: n1 -- )  ;    discard one item off of the return stack  ; VERIFIED
 00000F16  00000EF7 R		DD DUPTOR     
 00000F1A  00000F26 R		DD do_RFROMDROP
 00000F1E  00 06 52 3E 44	DB 0, 6, "R>DROP"
	   52 4F 50
 00000F26			do_RFROMDROP: 
 00000F26  83 C5 04		    ADD EBP, 4
				    NEXTC
 00000F29  8B 07	     1	   MOV EAX, [EDI]
 00000F2B  83 C7 04	     1	   ADD EDI, 4
 00000F2E  FF E0	     1	   JMP EAX 
				 ; 
 00000F30			_2TOR:     ; ( n1 n2 -- ) ; ( R: -- n1 n2 )  ;    push two items onto the return stack  ; VERIFIED
 00000F30  00000F16 R		DD RFROMDROP 
 00000F34  00000F3D R		DD do_2TOR
 00000F38  00 03 32 3E 52	DB 0, 3, "2>R"
 00000F3D			do_2TOR: 
 00000F3D  5B			    POP EBX
 00000F3E  83 ED 04		    SUB EBP, 4
 00000F41  89 5D 00		    MOV [EBP], EBX
 00000F44  5B			    POP EBX
 00000F45  83 ED 04		    SUB EBP, 4
 00000F48  89 5D 00		    MOV [EBP], EBX
				    NEXTC
 00000F4B  8B 07	     1	   MOV EAX, [EDI]
 00000F4D  83 C7 04	     1	   ADD EDI, 4
 00000F50  FF E0	     1	   JMP EAX 
				 ; 
 00000F52			_2RFROM:    ; ( -- n1 n2 ) ; ( R: n1 n2 -- )  ;    pop two items off the return stack  ; VERIFIED
 00000F52  00000F30 R		DD _2TOR  
 00000F56  00000F5F R		DD do_2RFROM
 00000F5A  00 03 32 52 3E	DB 0, 3, "2R>"
 00000F5F			do_2RFROM: 
 00000F5F  FF 75 00		    PUSH [EBP]
 00000F62  83 C5 04		    ADD EBP, 4
 00000F65  FF 75 00		    PUSH [EBP]
 00000F68  83 C5 04		    ADD EBP, 4
				    NEXTC
 00000F6B  8B 07	     1	   MOV EAX, [EDI]
 00000F6D  83 C7 04	     1	   ADD EDI, 4
 00000F70  FF E0	     1	   JMP EAX 
				 ; 
 00000F72			_2RFETCH:     ; ( -- n1 n2 )     ;    get a copy of the top two items on the return stack  ; VERIFIED
 00000F72  00000F52 R		DD _2RFROM  
 00000F76  00000F7F R		DD do_2RFETCH
 00000F7A  00 03 32 52 40	DB 0, 3, "2R@"
 00000F7F			do_2RFETCH: 
 00000F7F  FF 75 00		   PUSH [EBP]
 00000F82  FF 75 04		   PUSH [EBP+4]
				   NEXTC
 00000F85  8B 07	     1	   MOV EAX, [EDI]
 00000F87  83 C7 04	     1	   ADD EDI, 4
 00000F8A  FF E0	     1	   JMP EAX 
				 ; 
 00000F8C			_2DUP:     ; ( N1 N2 -- N1 N2 n1 n2 )  DUPLICATE TOP 2 ITEMS ON STACK       ; VERIFIED
 00000F8C  00000F72 R		DD _2RFETCH  
 00000F90  00000F9A R		DD do_2DUP
 00000F94  00 04 32 44 55	DB 0, 4, "2DUP"
	   50
 00000F9A			do_2DUP: 
 00000F9A  8B 5C 24 04		    MOV EBX , 4 [ESP]
 00000F9E  8B 04 24		    MOV EAX , 0 [ESP]
 00000FA1  53			    PUSH EBX
 00000FA2  50			    PUSH EAX
				    NEXTC
 00000FA3  8B 07	     1	   MOV EAX, [EDI]
 00000FA5  83 C7 04	     1	   ADD EDI, 4
 00000FA8  FF E0	     1	   JMP EAX 
				 ; 
 00000FAA			_2DROP:     ; ( n1 n2 -- )  DROP TOP 2 ITEMS ON STACK ; VERIFIED
 00000FAA  00000F8C R		DD _2DUP 
 00000FAE  00000FB9 R		DD do_2DROP
 00000FB2  00 05 32 44 52	DB 0, 5, "2DROP"
	   4F 50
 00000FB9			do_2DROP: 
 00000FB9  83 C4 08		    ADD ESP, 8
				    NEXTC
 00000FBC  8B 07	     1	   MOV EAX, [EDI]
 00000FBE  83 C7 04	     1	   ADD EDI, 4
 00000FC1  FF E0	     1	   JMP EAX 
				;
				;   -------------------- Comparison Operators ---------------------------------

 00000FC3			EQU0:          ; ( n1 -- f1 )      return true if n1 equals zero  ; VERIFIED
 00000FC3  00000FAA R		DD _2DROP
 00000FC7  00000FCF R		DD do_EQU0
 00000FCB  00 02 30 3D		DB 0, 2, "0="
 00000FCF			do_EQU0:
 00000FCF  5B			    POP EBX
 00000FD0  83 EB 01		    sub     ebx,  1
 00000FD3  1B DB		    sbb     ebx, ebx
 00000FD5  53				push ebx
				    NEXTC
 00000FD6  8B 07	     1	   MOV EAX, [EDI]
 00000FD8  83 C7 04	     1	   ADD EDI, 4
 00000FDB  FF E0	     1	   JMP EAX 
				 ;
 00000FDD			_0NE:         ; v( n1 -- f1 )      return true if n1 is not equal to zero  ; VERIFIED
 00000FDD  00000FC3 R		DD EQU0
 00000FE1  00000FEA R		DD do_0NE
 00000FE5  00 03 30 3C 3E	DB 0, 3, "0<>"
 00000FEA			do_0NE:
 00000FEA  5B			    POP EBX
 00000FEB  83 EB 01		    sub     ebx, 1
 00000FEE  1B DB		    sbb     ebx, ebx
 00000FF0  F7 D3		    not     ebx
 00000FF2  53				push ebx
				    NEXTC
 00000FF3  8B 07	     1	   MOV EAX, [EDI]
 00000FF5  83 C7 04	     1	   ADD EDI, 4
 00000FF8  FF E0	     1	   JMP EAX 
				 ;
 00000FFA			_0LT:         ; ( n1 -- f1 )      return true if n1 is less than zero  ; VERIFIED
 00000FFA  00000FDD R		DD _0NE
 00000FFE  00001006 R		DD do_0LT
 00001002  00 02 30 3C		DB 0, 2, "0<"
 00001006			do_0LT:
 00001006  5B			    POP EBX
 00001007  C1 FB 1F		    sar ebx,  31
 0000100A  53				push ebx
				    NEXTC
 0000100B  8B 07	     1	   MOV EAX, [EDI]
 0000100D  83 C7 04	     1	   ADD EDI, 4
 00001010  FF E0	     1	   JMP EAX 
				 ;
 00001012			_0GT:          ; ( n1 -- f1 )      return true (-1) if n1 is greater than zero  ; VERIFIED
 00001012  00000FFA R		DD _0LT
 00001016  0000101E R		DD do_0GT
 0000101A  00 02 30 3E		DB 0, 2, "0>"
 0000101E			do_0GT:
 0000101E  5B			    POP EBX
 0000101F  4B			    dec     ebx
 00001020  81 FB 7FFFFFFF	    cmp     ebx, 7fffffffh
 00001026  1B DB		    sbb     ebx, ebx
 00001028  53				push ebx
				    NEXTC
 00001029  8B 07	     1	   MOV EAX, [EDI]
 0000102B  83 C7 04	     1	   ADD EDI, 4
 0000102E  FF E0	     1	   JMP EAX 
				 ;
 00001030			_EQU:          ; ( n1 n2 -- f1 )   return true (-1) if n1 is equal to n2  ; VERIFIED
 00001030  00001012 R		DD _0GT
 00001034  0000103B R		DD do_EQU
 00001038  00 01 3D		DB 0, 1, "="
 0000103B			do_EQU:
 0000103B  5B			    POP EBX
 0000103C  58			    pop     eax
 0000103D  2B D8		    sub     ebx, eax
 0000103F  83 EB 01		    sub     ebx, 1
 00001042  1B DB		    sbb     ebx, ebx
 00001044  53				push ebx
				    NEXTC
 00001045  8B 07	     1	   MOV EAX, [EDI]
 00001047  83 C7 04	     1	   ADD EDI, 4
 0000104A  FF E0	     1	   JMP EAX 
				 ;
 0000104C			_NEQ:         ; ( n1 n2 -- f1 )   return true if (-1) n1 is not equal to n2  ; VERIFIED
 0000104C  00001030 R		DD _EQU
 00001050  00001058 R		DD do_NEQ
 00001054  00 02 3C 3E		DB 0, 2, "<>"
 00001058			do_NEQ:
 00001058  5B			    POP EBX
 00001059  58			    pop     eax
 0000105A  2B C3		    sub     eax, ebx
 0000105C  F7 D8		    neg     eax
 0000105E  1B DB		    sbb     ebx, ebx
 00001060  53				push ebx
				    NEXTC
 00001061  8B 07	     1	   MOV EAX, [EDI]
 00001063  83 C7 04	     1	   ADD EDI, 4
 00001066  FF E0	     1	   JMP EAX 
				 ;
 00001068			_LT:          ; ( n1 n2 -- f1 )   return true if n1 is less than n2   ; VERIFIED
 00001068  0000104C R		DD _NEQ
 0000106C  00001073 R		DD do_LT
 00001070  00 01 3C		DB 0, 1, "<"
 00001073			do_LT:
 00001073  5B			    POP EBX
 00001074  58			    pop eax
 00001075  3B C3		    cmp eax, ebx
 00001077  7C 0A		    jl short @@1
 00001079  33 DB		    xor ebx, ebx
 0000107B  53				push ebx
				    NEXTC
 0000107C  8B 07	     1	   MOV EAX, [EDI]
 0000107E  83 C7 04	     1	   ADD EDI, 4
 00001081  FF E0	     1	   JMP EAX 
 00001083			@@1:       
 00001083  BB FFFFFFFF		    mov ebx, -1
 00001088  53				push ebx
				    NEXTC
 00001089  8B 07	     1	   MOV EAX, [EDI]
 0000108B  83 C7 04	     1	   ADD EDI, 4
 0000108E  FF E0	     1	   JMP EAX 
				 ;
 00001090			_GT:          ; ( n1 n2 -- f1 )   return true if n1 is greater than n2  ; VERIFIED
 00001090  00001068 R		DD _LT
 00001094  0000109B R		DD do_GT
 00001098  00 01 3E		DB 0, 1, ">"
 0000109B			do_GT:
 0000109B  5B			    POP EBX
 0000109C  58			    pop eax
 0000109D  3B C3		    cmp eax, ebx
 0000109F  7F E2		    jg  short @@1
 000010A1  33 DB		    xor ebx, ebx
 000010A3  53				push ebx
				    NEXTC
 000010A4  8B 07	     1	   MOV EAX, [EDI]
 000010A6  83 C7 04	     1	   ADD EDI, 4
 000010A9  FF E0	     1	   JMP EAX 
				 ;
 000010AB			_LTE:         ; ( n1 n2 -- f1 )   return true if n1 is less than n2  ; VERIFIED 
 000010AB  00001090 R		DD _GT
 000010AF  000010B7 R		DD do_LTE
 000010B3  00 02 3C 3D		DB 0, 2, "<="
 000010B7			do_LTE:
 000010B7  5B			    POP EBX
 000010B8  58			    pop eax
 000010B9  3B C3		    cmp eax, ebx
 000010BB  7E C6		    jle short @@1
 000010BD  33 DB		    xor ebx, ebx
 000010BF  53				push ebx
				    NEXTC
 000010C0  8B 07	     1	   MOV EAX, [EDI]
 000010C2  83 C7 04	     1	   ADD EDI, 4
 000010C5  FF E0	     1	   JMP EAX 
				;
 000010C7			_GTE:        ;  ( n1 n2 -- f1 )   return true if n1 is greater than n2   ; VERIFIED
 000010C7  000010AB R		DD _LTE
 000010CB  000010D3 R		DD do_GTE
 000010CF  00 02 3E 3D		DB 0, 2, ">="
 000010D3			do_GTE:
 000010D3  5B			    POP EBX
 000010D4  58			    pop eax
 000010D5  3B C3		    cmp eax, ebx
 000010D7  7D AA		    jge short @@1
 000010D9  33 DB		    xor ebx, ebx
 000010DB  53				push ebx
				    NEXTC
 000010DC  8B 07	     1	   MOV EAX, [EDI]
 000010DE  83 C7 04	     1	   ADD EDI, 4
 000010E1  FF E0	     1	   JMP EAX 
				 ;
 000010E3			ULT:        ;  ( u1 u2 -- f1 )   return true if unsigned u1 is less than  
 000010E3  000010C7 R		DD _GTE
 000010E7  000010EF R		DD do_ULT
 000010EB  00 02 55 3C		DB 0, 2, "U<"
 000010EF			do_ULT:
 000010EF  5B			    POP EBX  ;   unsigned u2
 000010F0  58			    pop eax
 000010F1  3B C3		    cmp eax, ebx
 000010F3  1B DB		    sbb ebx, ebx
 000010F5  53				push ebx
				    NEXTC
 000010F6  8B 07	     1	   MOV EAX, [EDI]
 000010F8  83 C7 04	     1	   ADD EDI, 4
 000010FB  FF E0	     1	   JMP EAX 
				 ;
 000010FD			UGT:         ; ( u1 u2 -- f1 )   return true if unsigned u1 is greater than
 000010FD  000010E3 R		DD ULT
 00001101  00001109 R		DD do_UGT
 00001105  00 02 55 3E		DB 0, 2, "U>"
 00001109			do_UGT:
 00001109  5B			    POP EBX   ;   unsigned n2
 0000110A  58			    pop eax
 0000110B  3B D8		    cmp ebx, eax
 0000110D  1B DB		    sbb ebx, ebx
 0000110F  53				push ebx
				    NEXTC
 00001110  8B 07	     1	   MOV EAX, [EDI]
 00001112  83 C7 04	     1	   ADD EDI, 4
 00001115  FF E0	     1	   JMP EAX 
				 ;
 00001117			DULT:        ; ( ud1 ud2 -- f1 )   return true if unsigned double ud1 is
 00001117  000010FD R		DD UGT
 0000111B  00001124 R		DD do_DULT
 0000111F  00 03 44 55 3C	DB 0, 3, "DU<"
 00001124			do_DULT:
 00001124  5B			    POP EBX ;   less than unsigned double ud2
 00001125  58			    pop     eax
 00001126  59			    pop     ecx
 00001127  87 14 24		    xchg    edx, 0 [esp]    ;  save UP
 0000112A  2B D0		    sub     edx, eax
 0000112C  1B CB		    sbb     ecx, ebx
 0000112E  1B DB		    sbb     ebx, ebx
 00001130  5A			    pop     edx             ;  restore UP
 00001131  53				push ebx
				    NEXTC
 00001132  8B 07	     1	   MOV EAX, [EDI]
 00001134  83 C7 04	     1	   ADD EDI, 4
 00001137  FF E0	     1	   JMP EAX 
				 ;
 00001139			UMIN:       ; ( u1 u2 -- n3 )   return the lesser of unsigned u1 and
 00001139  00001117 R		DD DULT
 0000113D  00001147 R		DD do_UMIN
 00001141  00 04 55 4D 49	DB 0, 4, "UMIN"
	   4E
 00001147			do_UMIN:
 00001147  5B			    POP EBX ;  unsigned u2
 00001148  58			    pop     eax
 00001149  3B D8		    cmp     ebx, eax
 0000114B  72 02		    jb      @@1UMN
 0000114D  8B D8		    mov     ebx, eax
 0000114F			@@1UMN:
 0000114F  53				push ebx
				    NEXTC
 00001150  8B 07	     1	   MOV EAX, [EDI]
 00001152  83 C7 04	     1	   ADD EDI, 4
 00001155  FF E0	     1	   JMP EAX 
				 ;
 00001157			_MIN:        ; ( n1 n2 -- n3 )   return the lesser of n1 and n2  ; VERIFIED
 00001157  00001139 R		DD UMIN
 0000115B  00001164 R		DD do_MIN
 0000115F  00 03 4D 49 4E	DB 0, 3, "MIN"
 00001164			do_MIN:
 00001164  5B			    POP     EBX
 00001165  58			    pop     eax
 00001166  3B D8		    cmp     ebx, eax
 00001168  7C 02		    jl      @@1MN
 0000116A  8B D8		    mov     ebx, eax
 0000116C			@@1MN:
 0000116C  53				push    ebx
				    NEXTC
 0000116D  8B 07	     1	   MOV EAX, [EDI]
 0000116F  83 C7 04	     1	   ADD EDI, 4
 00001172  FF E0	     1	   JMP EAX 
				 ;
 00001174			_UMAX:       ; ( u1 u2 -- n3 )   return the greater of unsigned u1 and U2   ; VERIFIED
 00001174  00001157 R		DD _MIN
 00001178  00001182 R		DD do_UMAX
 0000117C  00 04 55 4D 41	DB 0, 4, "UMAX"
	   58
 00001182			do_UMAX:
 00001182  5B			    POP EBX ;  unsigned u2
 00001183  58			     pop     eax
 00001184  3B D8		     cmp     ebx, eax
 00001186  77 02		     ja      @@1UMX
 00001188  8B D8		     mov     ebx, eax
 0000118A			@@1UMX:
 0000118A  53				 push ebx
				    NEXTC
 0000118B  8B 07	     1	   MOV EAX, [EDI]
 0000118D  83 C7 04	     1	   ADD EDI, 4
 00001190  FF E0	     1	   JMP EAX 
				 ;
 00001192			_MAX:       ;  ( n1 n2 -- n3 )   return the greater of n1 and n2   ; VERIFIED
 00001192  00001174 R		DD _UMAX
 00001196  0000119F R		DD do_MAX
 0000119A  00 03 4D 41 58	DB 0, 3, "MAX"
 0000119F			do_MAX:
 0000119F  5B			    POP EBX
 000011A0  58			    pop     eax
 000011A1  3B D8		    cmp     ebx, eax
 000011A3  7F 02		    jg      @@1MX
 000011A5  8B D8		    mov     ebx, eax
 000011A7			@@1MX:
 000011A7  53				push ebx
				    NEXTC
 000011A8  8B 07	     1	   MOV EAX, [EDI]
 000011AA  83 C7 04	     1	   ADD EDI, 4
 000011AD  FF E0	     1	   JMP EAX 
				 ;
 000011AF			_0MAX:       ; ( n1 -- n2 )   return n2 the greater of n1 and zero   ; VERIFIED
 000011AF  00001192 R		DD _MAX
 000011B3  000011BD R		DD do_0MAX
 000011B7  00 04 30 4D 41	DB 0, 4, "0MAX"
	   58
 000011BD			do_0MAX:
 000011BD  5B			    POP EBX
 000011BE  83 FB 00		    cmp     ebx, 0
 000011C1  7F 02		    jg      @@10MX
 000011C3  33 DB		    xor     ebx, ebx
 000011C5			@@10MX:
 000011C5  53				push ebx
				    NEXTC
 000011C6  8B 07	     1	   MOV EAX, [EDI]
 000011C8  83 C7 04	     1	   ADD EDI, 4
 000011CB  FF E0	     1	   JMP EAX 
				 ;
 000011CD			_WITHIN:     ; ( n1 low high -- f1 )   f1=true if ( (n1 >= low) and (n1 < high) )   ; VERIFIED
 000011CD  000011AF R		DD _0MAX
 000011D1  000011DD R		DD do_WITHIN
 000011D5  00 06 57 49 54	DB 0, 6, "WITHIN"
	   48 49 4E
 000011DD			do_WITHIN:
 000011DD  5B			    POP EBX
 000011DE  58			    pop     eax
 000011DF  59			    pop     ecx
 000011E0  2B D8		    sub     ebx, eax
 000011E2  2B C8		    sub     ecx, eax
 000011E4  2B CB		    sub     ecx, ebx
 000011E6  1B DB		    sbb     ebx, ebx
 000011E8  53				push ebx
				    NEXTC
 000011E9  8B 07	     1	   MOV EAX, [EDI]
 000011EB  83 C7 04	     1	   ADD EDI, 4
 000011EE  FF E0	     1	   JMP EAX 
				 ;
 000011F0			_BETWEEN:     ; ( n1 low high -- f1 )   f1=true if ( (n1 >= low) and (n1 <= high) )   ; VERIFIED
 000011F0  000011CD R		DD _WITHIN
 000011F4  00001201 R		DD do_BETWEEN
 000011F8  00 07 42 45 54	DB 0, 7, "BETWEEN"
	   57 45 45 4E
 00001201			do_BETWEEN:
 00001201  5B			    POP EBX
 00001202  83 C3 01		    add     ebx, 1      ;  bump high
 00001205  58			    pop     eax
 00001206  59			    pop     ecx
 00001207  2B D8		    sub     ebx, eax
 00001209  2B C8		    sub     ecx, eax
 0000120B  2B CB		    sub     ecx, ebx
 0000120D  1B DB		    sbb     ebx, ebx
 0000120F  53				push ebx
				    NEXTC
 00001210  8B 07	     1	   MOV EAX, [EDI]
 00001212  83 C7 04	     1	   ADD EDI, 4
 00001215  FF E0	     1	   JMP EAX 
				;

				;   -------------------- Double memory Operators ------------------------------

 00001217			_2FETCH:          ; ( a1 -- d1 )   fetch the double number d1 from address a1
 00001217  000011F0 R		DD _BETWEEN
 0000121B  00001223 R		DD do_2FETCH
 0000121F  00 02 32 40		DB 0, 2, "2@"
 00001223			do_2FETCH:
 00001223  5B			    POP EBX
 00001224  FF 73 04		    push    4 [ebx]
 00001227  8B 1B		     mov     ebx, 0 [ebx]
 00001229  53				push ebx
				    NEXTC
 0000122A  8B 07	     1	   MOV EAX, [EDI]
 0000122C  83 C7 04	     1	   ADD EDI, 4
 0000122F  FF E0	     1	   JMP EAX 
				 ;
 00001231			_2STORE:          ; ( d1 a1 -- )   store the double number d1 into address a1
 00001231  00001217 R		DD _2FETCH
 00001235  0000123D R		DD do_2STORE
 00001239  00 02 32 21		DB 0, 2, "2!"
 0000123D			do_2STORE:
 0000123D  5B			    POP EBX
 0000123E  8F 03		    pop     0 [ebx]
 00001240  8F 43 04		    pop     4 [ebx]
 00001243  5B			    pop     ebx
				    NEXTC
 00001244  8B 07	     1	   MOV EAX, [EDI]
 00001246  83 C7 04	     1	   ADD EDI, 4
 00001249  FF E0	     1	   JMP EAX 
				;

				;   -------------------- Double Stack Operators -------------------------------

 0000124B			_2NIP:       ;  ( n1 n2 n3 n4 -- n3 n4 )   discard third and fourth items from data stack  ; VERIFIED
 0000124B  00001231 R		DD _2STORE
 0000124F  00001259 R		DD do_2NIP
 00001253  00 04 32 4E 49	DB 0, 4, "2NIP"
	   50
 00001259			do_2NIP:
 00001259  5B			    POP EBX
 0000125A  58			    pop     eax
 0000125B  89 44 24 04		    mov     4 [esp], eax
 0000125F  58			    pop     eax
 00001260  53				push ebx
				    NEXTC
 00001261  8B 07	     1	   MOV EAX, [EDI]
 00001263  83 C7 04	     1	   ADD EDI, 4
 00001266  FF E0	     1	   JMP EAX 
				 ;
 00001268			_2SWAP:      ; ( n1 n2 n3 n4 -- n3 n4 n1 n2 )   exchange the two topmost doubles  ; VERIFIED
 00001268  0000124B R		DD _2NIP
 0000126C  00001277 R		DD do_2SWAP
 00001270  00 05 32 53 57	DB 0, 5, "2SWAP"
	   41 50
 00001277			do_2SWAP:
 00001277  5B			    POP EBX
 00001278  8B 44 24 04		    mov     eax, 4 [esp]      ;  eax=n2
 0000127C  8B 4C 24 08		    mov     ecx, 8 [esp]      ;  ecx=n1
 00001280  89 5C 24 04		    mov     4 [esp], ebx      ;  n1 n4 n3 eax=n2 ecx=n1 ebx=n4
 00001284  8B 1C 24		    mov     ebx, 0 [esp]      ;  ebx=3
 00001287  89 0C 24		    mov     0 [esp], ecx      ;  n3 n4 n1
 0000128A  89 5C 24 08		    mov     8 [esp], ebx      ;  n3 n4 n3
 0000128E  8B D8		    mov     ebx, eax          ;  n3 n4 n1 n2
 00001290  53				push ebx
				    NEXTC
 00001291  8B 07	     1	   MOV EAX, [EDI]
 00001293  83 C7 04	     1	   ADD EDI, 4
 00001296  FF E0	     1	   JMP EAX 
				 ;
 00001298			_2OVER:      ; ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )   copy second double on top  ; VERIFIED
 00001298  00001268 R		DD _2SWAP
 0000129C  000012A7 R		DD do_2OVER
 000012A0  00 05 32 4F 56	DB 0, 5, "2OVER"
	   45 52
 000012A7			do_2OVER:
 000012A7  5B			    POP EBX
 000012A8  8B 44 24 08		                mov     eax, 8 [esp]
 000012AC  53			                push    ebx
 000012AD  50			                push    eax
 000012AE  8B 5C 24 0C		                mov     ebx, 12 [esp]
 000012B2  53					push ebx
				    NEXTC
 000012B3  8B 07	     1	   MOV EAX, [EDI]
 000012B5  83 C7 04	     1	   ADD EDI, 4
 000012B8  FF E0	     1	   JMP EAX 
				 ;
 000012BA			_2ROT:       ; ( n1 n2 n3 n4 n5 n6 -- n3 n4 n5 n6 n1 n2 )   VERIFIED
 000012BA  00001298 R		DD _2OVER
 000012BE  000012C8 R		DD do_2ROT
 000012C2  00 04 32 52 4F	DB 0, 4, "2ROT"
	   54
 000012C8			do_2ROT:
 000012C8  5B			    POP EBX
 000012C9  58			                pop     eax
 000012CA  87 1C 24		                xchg    ebx, 0 [esp]
 000012CD  87 44 24 04		                xchg    eax, 4 [esp]
 000012D1  87 5C 24 08		                xchg    ebx, 8 [esp]
 000012D5  87 44 24 0C		                xchg    eax, 12 [esp]
 000012D9  50			                push    eax
 000012DA  53					push ebx
				    NEXTC
 000012DB  8B 07	     1	   MOV EAX, [EDI]
 000012DD  83 C7 04	     1	   ADD EDI, 4
 000012E0  FF E0	     1	   JMP EAX 
				 ;
 000012E2			_3DROP:      ; ( n1 n2 n3 -- )   discard three items from the data stack  ; VERIFIED 
 000012E2  000012BA R		DD _2ROT
 000012E6  000012F1 R		DD do_3DROP
 000012EA  00 05 33 44 52	DB 0, 5, "3DROP"
	   4F 50
 000012F1			do_3DROP:
 000012F1  83 C4 0C		    add     esp, 12
				    NEXTC
 000012F4  8B 07	     1	   MOV EAX, [EDI]
 000012F6  83 C7 04	     1	   ADD EDI, 4
 000012F9  FF E0	     1	   JMP EAX 
				 ;
 000012FB			_4DROP:      ; ( n1 n2 n3 n4 -- )   discard four items from the data stack   ; VERIFIED
 000012FB  000012E2 R		DD _3DROP
 000012FF  0000130A R		DD do_4DROP
 00001303  00 05 34 44 52	DB 0, 5, "4DROP"
	   4F 50
 0000130A			do_4DROP:
 0000130A  83 C4 10		    add     esp, 16
				    NEXTC
 0000130D  8B 07	     1	   MOV EAX, [EDI]
 0000130F  83 C7 04	     1	   ADD EDI, 4
 00001312  FF E0	     1	   JMP EAX 
				 ;
 00001314			_3DUP:       ; ( n1 n2 n3 -- n1 n2 n3 n1 n2 n3 )   duplicate 3 topmost cells  ; VERIFIED
 00001314  000012FB R		DD _4DROP
 00001318  00001322 R		DD do_3DUP
 0000131C  00 04 33 44 55	DB 0, 4, "3DUP"
	   50
 00001322			do_3DUP:
 00001322  5B			    POP EBX
 00001323  8B 04 24		                mov     eax, 0 [esp]      ;  n2
 00001326  8B 4C 24 04		                mov     ecx, 4 [esp]      ;  n1
 0000132A  53			                push    ebx               ;  n3
 0000132B  51			                push    ecx               ;  n1
 0000132C  50			                push    eax               ;  n2
 0000132D  53					push ebx
				    NEXTC
 0000132E  8B 07	     1	   MOV EAX, [EDI]
 00001330  83 C7 04	     1	   ADD EDI, 4
 00001333  FF E0	     1	   JMP EAX 
				 ;
 00001335			_4DUP:       ; ( a b c d -- a b c d a b c d )   duplicate 4 topmost cells  ; VERIFIED
 00001335  00001314 R		DD _3DUP
 00001339  00001343 R		DD do_4DUP
 0000133D  00 04 34 44 55	DB 0, 4, "4DUP"
	   50
 00001343			do_4DUP:
 00001343  5B			    POP EBX
 00001344  8B 44 24 08		    mov     eax, 8 [esp]
 00001348  53			    push    ebx
 00001349  50			    push    eax
 0000134A  8B 5C 24 0C		    mov     ebx, 12 [esp]
 0000134E  8B 44 24 08		    mov     eax, 8 [esp]
 00001352  53			    push    ebx
 00001353  50			    push    eax
 00001354  8B 5C 24 0C		    mov     ebx, 12 [esp]
 00001358  53				push ebx
				    NEXTC
 00001359  8B 07	     1	   MOV EAX, [EDI]
 0000135B  83 C7 04	     1	   ADD EDI, 4
 0000135E  FF E0	     1	   JMP EAX 
				;
				; \ -------------------- Signed Multiply & Divide -----------------------------

 00001360			_MMULT:           ; CODE M*         ( n1 n2 -- d1 )     VERIFIED 231202
 00001360  00001335 R		DD _4DUP          ; \ multiply n1 by n2, return double result d1
 00001364  0000136C R		DD do_MMULT
 00001368  00 02 4D 2A		DB 0, 2, 'M*'
 0000136C			do_MMULT:
 0000136C  5B			   POP EBX
 0000136D  8B CA		   mov     ecx, edx        ;\ save UP
 0000136F  58			   pop     eax
 00001370  F7 EB		   imul    ebx
 00001372  50			   push    eax
 00001373  8B DA		   mov     ebx, edx
 00001375  8B D1		   mov     edx, ecx        ;\ restore UP
 00001377  53			   PUSH EBX
				   NEXTC
 00001378  8B 07	     1	   MOV EAX, [EDI]
 0000137A  83 C7 04	     1	   ADD EDI, 4
 0000137D  FF E0	     1	   JMP EAX 
				;
 0000137F			_MULT:                      ; CODE *          ( n1 n2 -- n3 )   VERIFIED 231202
 0000137F  00001360 R		DD _MMULT                   ; \ multiply n1 by n2, return single result n3
 00001383  0000138A R		DD do_MULT
 00001387  00 01 2A		DB 0, 1, '*'
 0000138A			do_MULT:
 0000138A  5B			   POP EBX
 0000138B  8B CA		   mov     ecx, edx       ; \ save UP
 0000138D  58			   pop     eax
 0000138E  F7 E3		   mul     ebx
 00001390  8B D8		   mov     ebx, eax
 00001392  8B D1		   mov     edx, ecx       ; \ restore UP
 00001394  53			   PUSH EBX
				   NEXTC
 00001395  8B 07	     1	   MOV EAX, [EDI]
 00001397  83 C7 04	     1	   ADD EDI, 4
 0000139A  FF E0	     1	   JMP EAX 
				;
				;   ------------------------ String counting -----------------------
				;
 0000139C			COUNT:      ; ( str -- addr len ) byte counted strings      ; VERIFIED
 0000139C  0000137F R		DD _MULT
 000013A0  000013AB R		DD do_COUNT
 000013A4  00 05 43 4F 55	DB 0, 5, "COUNT"
	   4E 54
 000013AB			do_COUNT:
 000013AB  8B 1C 24		   MOV EBX, [ESP]
 000013AE  0F B6 5B FF		   movzx   ebx, byte ptr  [ebx-1]
 000013B2  53			   push    ebx
				   NEXTC
 000013B3  8B 07	     1	   MOV EAX, [EDI]
 000013B5  83 C7 04	     1	   ADD EDI, 4
 000013B8  FF E0	     1	   JMP EAX 
				 ;
 000013BA			WCOUNT:    ;  ( str -- addr len )    word (2 bytes) counted strings
 000013BA  0000139C R		DD COUNT
 000013BE  000013CA R		DD do_WCOUNT
 000013C2  00 06 57 43 4F	DB 0, 6, "WCOUNT"
	   55 4E 54
 000013CA			do_WCOUNT:
 000013CA  5B			    POP EBX
 000013CB  83 C3 02		    add     ebx, 2
 000013CE  53			    push    ebx
 000013CF  0F B7 5B FE		    movzx   ebx, word ptr [ebx-2]
 000013D3  53				push ebx
				    NEXTC
 000013D4  8B 07	     1	   MOV EAX, [EDI]
 000013D6  83 C7 04	     1	   ADD EDI, 4
 000013D9  FF E0	     1	   JMP EAX 
				 ;
 000013DB			LCOUNT:    ;  ( str -- addr len )    long (4 bytes) counted strings
 000013DB  000013BA R		DD WCOUNT
 000013DF  000013EB R		DD do_LCOUNT
 000013E3  00 06 4C 43 4F	DB 0, 6, "LCOUNT"
	   55 4E 54
 000013EB			do_LCOUNT:
 000013EB  5B			    POP EBX
 000013EC  83 C3 04		    add  ebx, 4
 000013EF  53			    push ebx
 000013F0  8B 5B FC		    mov  ebx,  [ebx-4]
 000013F3  53				push ebx
				    NEXTC
 000013F4  8B 07	     1	   MOV EAX, [EDI]
 000013F6  83 C7 04	     1	   ADD EDI, 4
 000013F9  FF E0	     1	   JMP EAX 
				 ;
 000013FB			ZCOUNT:     ; ( str -- addr len ) null terminated string, whose 1st char is at addr   ; VERIFIED
 000013FB  000013DB R		DD LCOUNT
 000013FF  0000140B R		DD do_ZCOUNT
 00001403  00 06 5A 43 4F	DB 0, 6, "ZCOUNT"
	   55 4E 54
 0000140B			do_ZCOUNT:
 0000140B  8B 1C 24		        MOV     EBX, [ESP]
 0000140E  57			        PUSH    EDI
 0000140F  B9 FFFFFFFF		        mov     ecx, -1                 ;  scan way on up there... it had better stop!
 00001414  33 C0		        xor     eax, eax                ;  look for null
 00001416  8B FB		        mov     edi, ebx                ;  edi = absolute address of string
 00001418  F2/ AE		        repnz   scasb
 0000141A  83 C1 02		        add     ecx, 2
 0000141D  F7 D9		        neg     ecx
 0000141F  5F			        POP     EDI
 00001420  51				    push    ecx
				    NEXTC
 00001421  8B 07	     1	   MOV EAX, [EDI]
 00001423  83 C7 04	     1	   ADD EDI, 4
 00001426  FF E0	     1	   JMP EAX 
				;
 00001428			_STRINGADJ:    ; ( c-addr1 u1 n -- c-addr2 u2 )    ; VERIFIED
				; /STRING is used to remove or add characters relative to the left end of the
				; ** character string. Positive values of n will exclude characters from the string
				; ** while negative values of n will include characters to the left of the string.
 00001428  000013FB R		DD ZCOUNT
 0000142C  00001439 R		DD do_STRINGADJ
 00001430  00 07 2F 53 54	DB 0, 7, '/STRING'
	   52 49 4E 47
 00001439			do_STRINGADJ:
 00001439  5B			                POP     EBX
 0000143A  58			                pop     eax
 0000143B  85 DB		                test    ebx, ebx       ; Added two lines to allow a negative argument
 0000143D  7E 06		                jle     short @@1SDJ   ; to be passed to /STRING, so the string will
 0000143F  3B D8		                cmp     ebx, eax       ; be expanded.
 00001441  76 02		                jbe     short @@1SDJ   
 00001443  8B D8		                mov     ebx, eax
 00001445  01 1C 24		@@1SDJ:         add     0 [esp], ebx
 00001448  2B C3		                sub     eax, ebx
 0000144A  8B D8		                mov     ebx, eax
 0000144C  53			                PUSH    EBX
				NEXTC
 0000144D  8B 07	     1	   MOV EAX, [EDI]
 0000144F  83 C7 04	     1	   ADD EDI, 4
 00001452  FF E0	     1	   JMP EAX 
				;
 00001454			ADDNULL:     ; ( c-addr -- )  Append a NULL to the counted string.    ; VERIFIED
 00001454  00001428 R		DD _STRINGADJ
 00001458  00001463 R		DD do_ADDNULL
 0000145C  00 05 2B 4E 55	DB 0, 5, '+NULL'
	   4C 4C
 00001463			do_ADDNULL:
 00001463  5B			   POP     EBX
 00001464  8A 4B FF		   mov     CL, BYTE PTR [ebx-1]         ; length
 00001467  81 E1 000000FF	   AND     ECX, 00FFH
 0000146D  03 D9		   ADD     EBX, ECX
 0000146F  C6 03 00		   mov     BYTE PTR [EBX], 0                 ; zero the char
				   NEXTC
 00001472  8B 07	     1	   MOV EAX, [EDI]
 00001474  83 C7 04	     1	   ADD EDI, 4
 00001477  FF E0	     1	   JMP EAX 
				;
				;    -------------------- Logical Operators ------------------------------------

 00001479			_AND:     ; ( n1 n2 -- n3 )  ;    perform bitwise AND of n1,n2, return result n3     ; VERIFIED
 00001479  00001454 R		DD ADDNULL
 0000147D  00001486 R		DD do_AND
 00001481  00 03 41 4E 44	DB 0, 3, "AND"
 00001486			do_AND:
 00001486  5B			    POP EBX
 00001487  59			    pop ecx
 00001488  23 D9		    and ebx, ecx
 0000148A  53			    push ebx
				    NEXTC
 0000148B  8B 07	     1	   MOV EAX, [EDI]
 0000148D  83 C7 04	     1	   ADD EDI, 4
 00001490  FF E0	     1	   JMP EAX 
				 ;
 00001492			_OR:      ; ( n1 n2 -- n3 )  ;    perform bitwise OR of n1,n2, return result n3    ; VERIFIED
 00001492  00001479 R		DD _AND
 00001496  0000149E R		DD do_OR
 0000149A  00 02 4F 52		DB 0, 2, "OR"
 0000149E			do_OR:
 0000149E  5B			    POP EBX
 0000149F  59			    pop ecx
 000014A0  0B D9		    or ebx, ecx
 000014A2  53			    push ebx
				    NEXTC
 000014A3  8B 07	     1	   MOV EAX, [EDI]
 000014A5  83 C7 04	     1	   ADD EDI, 4
 000014A8  FF E0	     1	   JMP EAX 
				 ;
 000014AA			_XOR:     ; ( n1 n2 -- n3 )  ;    perform bitwise XOR of n1,n2, return result n3    ; VERIFIED
 000014AA  00001492 R		DD _OR
 000014AE  000014B7 R		DD do_XOR
 000014B2  00 03 58 4F 52	DB 0, 3, "XOR"
 000014B7			do_XOR:
 000014B7  5B			    POP EBX
 000014B8  59			    pop ecx
 000014B9  33 D9		    xor ebx, ecx
 000014BB  53			    push ebx
				    NEXTC
 000014BC  8B 07	     1	   MOV EAX, [EDI]
 000014BE  83 C7 04	     1	   ADD EDI, 4
 000014C1  FF E0	     1	   JMP EAX 
				 ;
 000014C3			_INVERT:  ; ( n1 -- n2 )     ;    perform a bitwise -1 XOR on n1, return result n2    ; VERIFIED
 000014C3  000014AA R		DD _XOR
 000014C7  000014D3 R		DD do_INVERT
 000014CB  00 06 49 4E 56	DB 0, 6, "INVERT"
	   45 52 54
 000014D3			do_INVERT:
 000014D3  5B			    POP EBX
 000014D4  F7 D3		    not ebx
 000014D6  53			    push ebx
				    NEXTC
 000014D7  8B 07	     1	   MOV EAX, [EDI]
 000014D9  83 C7 04	     1	   ADD EDI, 4
 000014DC  FF E0	     1	   JMP EAX 
				 ;
 000014DE			_LSHIFT:  ; ( u1 n -- u2 )  ;    shift u1 left by n bits ; (multiply)    ; VERIFIED
 000014DE  000014C3 R		DD _INVERT
 000014E2  000014EE R		DD do_LSHIFT
 000014E6  00 06 4C 53 48	DB 0, 6, "LSHIFT"
	   49 46 54
 000014EE			do_LSHIFT:
 000014EE  5B			    POP EBX
 000014EF  8B CB		    mov ecx, ebx
 000014F1  5B			    pop ebx
 000014F2  D3 E3		    shl ebx, cl
 000014F4  53			    push ebx
				    NEXTC
 000014F5  8B 07	     1	   MOV EAX, [EDI]
 000014F7  83 C7 04	     1	   ADD EDI, 4
 000014FA  FF E0	     1	   JMP EAX 
				 ;
 000014FC			_RSHIFT:  ; ( u1 n -- u2 )  ;    shift u1 right by n bits ; (divide)    ; VERIFIED
 000014FC  000014DE R		DD _LSHIFT
 00001500  0000150C R		DD do_RSHIFT
 00001504  00 06 52 53 48	DB 0, 6, "RSHIFT"
	   49 46 54
 0000150C			do_RSHIFT:
 0000150C  5B			    POP EBX
 0000150D  8B CB		    mov ecx, ebx
 0000150F  5B			    pop ebx
 00001510  D3 EB		    shr ebx, cl
 00001512  53			    push ebx
				    NEXTC
 00001513  8B 07	     1	   MOV EAX, [EDI]
 00001515  83 C7 04	     1	   ADD EDI, 4
 00001518  FF E0	     1	   JMP EAX 
				 ;
 0000151A			_INCR:  ; ( addr -- )  ;    increment the contents of addr 
 0000151A  000014FC R		DD _RSHIFT
 0000151E  00001528 R		DD do_INCR
 00001522  00 04 49 4E 43	DB 0, 4, "INCR"
	   52
 00001528			do_INCR:
 00001528  5B			    POP EBX
 00001529  83 03 01		    add dword ptr 0 [ebx],  1
				    NEXTC
 0000152C  8B 07	     1	   MOV EAX, [EDI]
 0000152E  83 C7 04	     1	   ADD EDI, 4
 00001531  FF E0	     1	   JMP EAX 
				 ;
 00001533			_DECR:  ; ( addr -- )  ;    decrement the contents of addr 
 00001533  0000151A R		DD _INCR
 00001537  00001541 R		DD do_DECR
 0000153B  00 04 44 45 43	DB 0, 4, "DECR"
	   52
 00001541			do_DECR:
 00001541  5B			    POP EBX
 00001542  83 2B 01		    sub dword ptr 0 [ebx],  1
				    NEXTC
 00001545  8B 07	     1	   MOV EAX, [EDI]
 00001547  83 C7 04	     1	   ADD EDI, 4
 0000154A  FF E0	     1	   JMP EAX 
				 ;
 0000154C			CINCR:  ; ( addr -- )  ;    increment the BYTE contents of addr
 0000154C  00001533 R		DD _DECR
 00001550  0000155B R		DD do_CINCR
 00001554  00 05 43 49 4E	DB 0, 5, "CINCR"
	   43 52
 0000155B			do_CINCR:
 0000155B  5B			    POP EBX
 0000155C  8B 03		    mov eax, [ebx]
 0000155E  83 C0 01		    add eax,  1
 00001561  89 03		    mov [ebx], eax
				    NEXTC
 00001563  8B 07	     1	   MOV EAX, [EDI]
 00001565  83 C7 04	     1	   ADD EDI, 4
 00001568  FF E0	     1	   JMP EAX 
				 ;
 0000156A			CDECR:  ; ( addr -- )  ;    decrement the BYTE contents of addr
 0000156A  0000154C R		DD CINCR
 0000156E  00001579 R		DD do_CDECR
 00001572  00 05 43 44 45	DB 0, 5, "CDECR"
	   43 52
 00001579			do_CDECR:
 00001579  5B			    POP EBX
 0000157A  8B 03		    mov eax, [ebx]
 0000157C  83 E8 01		    sub eax,  1
 0000157F  89 03		    mov [ebx], eax
				    NEXTC
 00001581  8B 07	     1	   MOV EAX, [EDI]
 00001583  83 C7 04	     1	   ADD EDI, 4
 00001586  FF E0	     1	   JMP EAX 
				 ;
 00001588			_ON:      ; ( addr -- )  ;    set the contents of addr to ON ; (-1)
 00001588  0000156A R		DD CDECR
 0000158C  00001594 R		DD do_ON
 00001590  00 02 4F 4E		DB 0, 2, "ON"
 00001594			do_ON:
 00001594  5B			    POP EBX
 00001595  C7 03 FFFFFFFF	    mov dword ptr 0 [ebx], -1
				    NEXTC
 0000159B  8B 07	     1	   MOV EAX, [EDI]
 0000159D  83 C7 04	     1	   ADD EDI, 4
 000015A0  FF E0	     1	   JMP EAX 
				 ;
 000015A2			_OFF:     ; ( addr -- )  ;    set the contents of addr of OFF ; (0)
 000015A2  00001588 R		DD _ON
 000015A6  000015AF R		DD do_OFF
 000015AA  00 03 4F 46 46	DB 0, 3, "OFF"
 000015AF			do_OFF:
 000015AF  5B			    POP EBX
 000015B0  C7 03 00000000	    mov dword ptr 0 [ebx],  0
				    NEXTC
 000015B6  8B 07	     1	   MOV EAX, [EDI]
 000015B8  83 C7 04	     1	   ADD EDI, 4
 000015BB  FF E0	     1	   JMP EAX 
				;
				;    -------------------- Other Operators ------------------------------------
				;
 000015BD			_DOCOLN:
 000015BD  000015A2 R		DD _OFF
 000015C1  000015CB R		DD do_COLN
 000015C5  00 04 43 4F 4C	DB 0, 4, 'COLN'
	   4E
 000015CB			do_COLN:
 000015CB  8B 1D 000009A0 R	    MOV EBX, NFA
 000015D1  8B C1		    MOV EAX, ECX
 000015D3  03 C3		    ADD EAX, EBX
 000015D5  83 C0 01		    ADD EAX, 1
 000015D8  50			    push EAX
 000015D9  EB 0F		    JMP do_DOCOL
				;
 000015DB			DOCOL:   ; ( ADDR -- )        runtime for colon definitions
 000015DB  000015BD R		DD _DOCOLN
 000015DF  000015EA R		DD do_DOCOL
 000015E3  00 05 44 4F 43	DB 0, 5, "DOCOL"
	   4F 4C
 000015EA			do_DOCOL:  
 000015EA  58			    POP EAX
 000015EB  83 ED 04		    SUB EBP, 4
 000015EE  89 7D 00		    MOV [EBP], EDI
 000015F1  8B F8		    mov edi, eax
 000015F3  8B 07		    mov eax, [edi]
 000015F5  83 C7 04		    add edi, 4
 000015F8  FF E0		    JMP EAX 
				;
 000015FA			DODOES:  ;( -- a1 )   ;  runtime for DOES>
 000015FA  000015DB R		DD DOCOL 
 000015FE  0000160A R		DD do_DODOES
 00001602  00 06 44 4F 44	DB 0, 6, "DODOES"
	   4F 45 53
 0000160A			do_DODOES: 
 0000160A  89 75 FC		    mov     [ebp-4], esi   ;  rpush esi
 0000160D  8B F1		    mov     esi, ecx        ;  new esi
 0000160F  8D 58 04		    lea     ebx, 4 [eax]
 00001612  8B 46 FC		    mov     eax, [esi-4]
 00001615  83 ED 04		    sub     ebp,  4
 00001618  FF E0		    JMP EAX
				;
 0000161A			DOVAR:   ;( -- a1 )   ;  runtime for CREATE and VARIABLE   VERIFIED 231201
 0000161A  000015FA R		DD DODOES  
 0000161E  00001629 R		DD do_DOVAR
 00001622  00 05 44 4F 56	DB 0, 5, "DOVAR"
	   41 52
 00001629			do_DOVAR: 
 00001629  A1 000009A0 R	    MOV EAX, NFA
 0000162E  03 C1		    ADD EAX, ECX
 00001630  40			    INC EAX
 00001631  50			    PUSH EAX
				    NEXTC
 00001632  8B 07	     1	   MOV EAX, [EDI]
 00001634  83 C7 04	     1	   ADD EDI, 4
 00001637  FF E0	     1	   JMP EAX 
				; 
 00001639			DOUSER:  ;( -- a1 )   ;  runtime for USER variables
 00001639  0000161A R		DD DOVAR  
 0000163D  00001649 R		DD do_DOUSER
 00001641  00 06 44 4F 55	DB 0, 6, "DOUSER"
	   53 45 52
 00001649			do_DOUSER: 
 00001649  8B 58 04		    mov     ebx, 4 [eax] ;  get offset
 0000164C  03 DA		    add     ebx, edx     ;  add absolute user base
 0000164E  53			    PUSH EBX
				    NEXTC
 0000164F  8B 07	     1	   MOV EAX, [EDI]
 00001651  83 C7 04	     1	   ADD EDI, 4
 00001654  FF E0	     1	   JMP EAX 
				; 
 00001656			DOCON:   ;( -- n1 )   ;  runtime for constants   VERIFIED 231201
 00001656  00001639 R		DD DOUSER  
 0000165A  00001665 R		DD do_DOCON
 0000165E  00 05 44 4F 43	DB 0, 5, "DOCON"
	   4F 4E
 00001665			do_DOCON: 
 00001665  8B 1D 000009A0 R	    MOV EBX, NFA
 0000166B  8B C1		    MOV EAX, ECX
 0000166D  03 C3		    ADD EAX, EBX
 0000166F  40			    INC EAX
 00001670  FF 30		    PUSH [EAX]
				    NEXTC
 00001672  8B 07	     1	   MOV EAX, [EDI]
 00001674  83 C7 04	     1	   ADD EDI, 4
 00001677  FF E0	     1	   JMP EAX 
				; 
 00001679			DODEFER:  ;( -- )     ;  runtime for DEFER
 00001679  00001656 R		DD DOCON 
 0000167D  0000168A R		DD do_DODEFER
 00001681  00 07 44 4F 44	DB 0, 7, "DODEFER"
	   45 46 45 52
 0000168A			do_DODEFER: 
 0000168A  8B 40 04		    mov     eax, 4 [eax]
 0000168D  FF E0		    JMP EAX

 0000168F			DOVALUE:  ;( -- n1 )  ;  runtime for VALUE fetch    VERIFIED 231201
 0000168F  00001679 R		DD DODEFER  
 00001693  000016A0 R		DD do_DOVALUE
 00001697  00 07 44 4F 56	DB 0, 7, "DOVALUE"
	   41 4C 55 45
 000016A0			do_DOVALUE: 
 000016A0  B8 00000000		    MOV EAX, 0
 000016A5  8B 1D 000009A0 R	    MOV EBX, NFA
 000016AB  8A 03		    MOV AL, BYTE PTR [EBX]
 000016AD  03 C3		    ADD EAX, EBX
 000016AF  40			    INC EAX          
 000016B0  FF 30		    PUSH [EAX]
				    NEXTC
 000016B2  8B 07	     1	   MOV EAX, [EDI]
 000016B4  83 C7 04	     1	   ADD EDI, 4
 000016B7  FF E0	     1	   JMP EAX 
				 ; 
 000016B9			DOVALUESTORE:  ;( n1 -- )   ;  runtime for VALUE store    VERIFIED 231201
 000016B9  0000168F R		DD DOVALUE
 000016BD  000016CB R		DD do_VALUESTORE
 000016C1  00 08 44 4F 56	DB 0, 8, "DOVALUE!"
	   41 4C 55 45 21
 000016CB			do_VALUESTORE: 
 000016CB  58			    POP EAX         ; DISCARD CFA POPINTER
 000016CC  B8 00000000		    MOV EAX, 0
 000016D1  8B 1D 000009A0 R	    MOV EBX, NFA
 000016D7  8A 03		    MOV AL, BYTE PTR [EBX]
 000016D9  03 C3		    ADD EAX, EBX
 000016DB  40			    inc eax         ; ADD EAX, 9
 000016DC  5B			    POP EBX         ; RETRIEVE VALUE N1
 000016DD  89 18		    mov [eax], ebx  ; SAVE VALUE
				    NEXTC
 000016DF  8B 07	     1	   MOV EAX, [EDI]
 000016E1  83 C7 04	     1	   ADD EDI, 4
 000016E4  FF E0	     1	   JMP EAX 
				 ; 
 000016E6			DOVALPLUSTORE:  ;( n1 -- )   ;  runtime for VALUE increment   VERIFIED 231201
 000016E6  000016B9 R		DD DOVALUESTORE  
 000016EA  000016F9 R		DD do_VALPLUSTORE
 000016EE  00 09 44 4F 56	DB 0, 9, "DOVALUE+!"
	   41 4C 55 45 2B
	   21
 000016F9			do_VALPLUSTORE: 
 000016F9  58			    POP EAX         ; DISCARD CFA POPINTER
 000016FA  B8 00000000		    MOV EAX, 0
 000016FF  8B 1D 000009A0 R	    MOV EBX, NFA
 00001705  8A 03		    MOV AL, BYTE PTR [EBX]
 00001707  03 C3		    ADD EAX, EBX
 00001709  40			    inc eax         ;ADD EAX, 9
 0000170A  5B			    POP EBX         ; RETRIEVE VALUE N1
 0000170B  01 18		    add     [eax], ebx
				    NEXTC
 0000170D  8B 07	     1	   MOV EAX, [EDI]
 0000170F  83 C7 04	     1	   ADD EDI, 4
 00001712  FF E0	     1	   JMP EAX 
				 ; 
 00001714			DO2VALUE:  ;( d1 -- )   ;  runtime for 2VALUE fetch
 00001714  000016B9 R		DD DOVALUESTORE 
 00001718  00001726 R		DD do_DO2VALUE
 0000171C  00 08 44 4F 32	DB 0, 8, "DO2VALUE"
	   56 41 4C 55 45
 00001726			do_DO2VALUE: 
 00001726  5B			    POP EBX 
 00001727  53			    push    ebx
 00001728  8B 48 04		    mov     ecx, 4 [eax]
 0000172B  FF 71 04		    push    4 [ecx]
 0000172E  8B 19		    mov     ebx, 0 [ecx]
				    NEXTC
 00001730  8B 07	     1	   MOV EAX, [EDI]
 00001732  83 C7 04	     1	   ADD EDI, 4
 00001735  FF E0	     1	   JMP EAX 
				 ; 
 00001737			DOOFF:      ;( n -- )    ;  run-time for OFFSET and FIELD+
 00001737  00001714 R		DD DO2VALUE  
 0000173B  00001746 R		DD do_DOOFF
 0000173F  00 05 44 4F 4F	DB 0, 5, "DOOFF"
	   46 46
 00001746			do_DOOFF: 
 00001746  5B			    POP EBX 
 00001747  03 58 04		    add ebx, 4 [eax]
				    NEXTC
 0000174A  8B 07	     1	   MOV EAX, [EDI]
 0000174C  83 C7 04	     1	   ADD EDI, 4
 0000174F  FF E0	     1	   JMP EAX 
				 ; 
 00001751			SOURCE_:        ; ( -- addr len )     (SOURCE)                 2@ ;
 00001751  00001737 R		DD DOOFF
 00001755  00001761 R		DD do_SOURCE_
 00001759  00 06 53 4F 55	DB 0, 6, 'SOURCE'
	   52 43 45
 00001761			do_SOURCE_:
 00001761  8B 1D 00000938 R	    mov ebx, _SOURCE     ; -----------------Needs work 
 00001767  FF 33		    push [ebx]
 00001769  83 C3 04		    add ebx, 4
 0000176C  FF 33		    push [ebx]
				    NEXTC
 0000176E  8B 07	     1	   MOV EAX, [EDI]
 00001770  83 C7 04	     1	   ADD EDI, 4
 00001773  FF E0	     1	   JMP EAX 
				;
 00001775			_HEADER_:   ;( addr len -- )   standard voc header word
 00001775  00001751 R		DD SOURCE_
 00001779  00001787 R		DD do__HEADER_
 0000177D  00 08 28 48 45	DB 0, 8, '(HEADER)'
	   41 44 45 52 29
 00001787			do__HEADER_:
 00001787  8B 0D 00000958 R	   mov     ecx, CURRENT       ; get current vocab
				;  mov     eax, VHEAD VOC#0 - [ecx] ; fetch header word to execute
 0000178D  FF E0		   JMP     eax
				;
				;   -------------------- Block Memory Operators -------------------------------
				;
 0000178F			 _CMOVE:          ; (  from to count -- )     move "count" bytes from address "from" to   ; VERIFIED
 0000178F  00001775 R		 DD _HEADER_      ;  address "to" - start with the first byte of "from"
 00001793  0000179E R		 DD do_CMOVE
 00001797  00 05 43 4D 4F	 DB 0, 5, 'CMOVE'
	   56 45
 0000179E			 do_CMOVE:
 0000179E  89 3D 00000928 R	                MOV     _EDI , EDI
 000017A4  5B			                POP     EBX
 000017A5  8B CB		                mov     ecx, ebx
 000017A7  8B C6		                mov     eax, esi
 000017A9  5F			                pop     edi
 000017AA  5E			                pop     esi
 000017AB  F3/ A4		                rep     movsb
 000017AD  8B F0		                mov     esi, eax
				;               xor     edi, edi
 000017AF  8B 3D 00000928 R	                MOV     EDI, _EDI
				                NEXTC
 000017B5  8B 07	     1	   MOV EAX, [EDI]
 000017B7  83 C7 04	     1	   ADD EDI, 4
 000017BA  FF E0	     1	   JMP EAX 
				;
 000017BC			_FILL:      ;   ( addr len char -- )  fill addr with char for len bytes  
 000017BC  0000178F R		DD  _CMOVE
 000017C0  000017CA R		DD do_FILL
 000017C4  00 04 46 49 4C	DB 0, 4, 'FILL'
	   4C
 000017CA			do_FILL:
 000017CA  5B			                POP     EBX             ;  CHAR
 000017CB  B7 20		                mov     bh, 32          ;  bh & bl = char = 32
 000017CD  C1 E3 10		                shl     ebx,  16
 000017D0  8B C3		                mov     eax, ebx
 000017D2  C1 E8 10		                shr     eax,  16
 000017D5  0B C3		                or      eax, ebx
 000017D7  8B DF		FILLJ:          mov     ebx, edi        ;  ebx = base POINTER
 000017D9  59			                pop     ecx             ;  ecx = len
 000017DA  5F			                pop     edi             ;  edi = addr
 000017DB  51			                push    ecx             ;  optimize
 000017DC  C1 E9 02		                shr     ecx,  2
 000017DF  F3/ AB		                rep     stosD
 000017E1  59			                pop     ecx
 000017E2  83 E1 03		                and     ecx,  3
 000017E5  F3/ AA		                rep     stosB
 000017E7  8B FB		                mov     edi, ebx        ;  restore
				                NEXTC                   ;  FILL
 000017E9  8B 07	     1	   MOV EAX, [EDI]
 000017EB  83 C7 04	     1	   ADD EDI, 4
 000017EE  FF E0	     1	   JMP EAX 
				;
 000017F0			_ERASE:     ;( addr u -- )  ; VERIFIED
				;  *G If u is greater than zero, clear all bits in each of u consecutive address
				;  ** units of memory beginning at addr .
 000017F0  000017BC R		DD _FILL
 000017F4  000017FF R		DD do_ERASE
 000017F8  00 05 45 52 41	DB 0, 5, 'ERASE'
	   53 45
 000017FF			do_ERASE:
 000017FF  33 C0		                xor     eax, eax
 00001801  EB D4		                jmp     FILLJ
				;
 00001803			BLANK:     ;( c-addr u -- )           ANSI         String
				;  *G If u is greater than zero, store the character value for space in u consecutive
				;  ** character positions beginning at c-addr.
 00001803  000017F0 R		DD _ERASE
 00001807  00001812 R		DD do_BLANK
 0000180B  00 05 42 4C 41	DB 0, 5, 'BLANK'
	   4E 4B
 00001812			do_BLANK:
 00001812  B8 20202020		                mov     eax, 20202020h ;  all blanks
 00001817  EB BE		                jmp     FILLJ
				;
				; -------------------- Parse Input Stream --------------------
				;
 00001819			TOBODY:       ;( cfa -- pfa ) \ convert code field address to parameter field address
 00001819  00001803 R		DD BLANK
 0000181D  00001828 R		DD do_TOBODY
 00001821  00 05 3E 42 4F	DB 0, 5, ">BODY"
	   44 59
 00001828			do_TOBODY:
 00001828  5B			    POP EBX
 00001829  83 C3 04		    add ebx,  4
 0000182C  53			    PUSH EBX
				    NEXTC
 0000182D  8B 07	     1	   MOV EAX, [EDI]
 0000182F  83 C7 04	     1	   ADD EDI, 4
 00001832  FF E0	     1	   JMP EAX 
				 ;
 00001834			BODYOFF:      ;( pfa -- cfa ) \ convert parameter field address to code field address
 00001834  00001819 R		DD TOBODY
 00001838  00001843 R		DD do_BODYOFF
 0000183C  00 05 42 4F 44	DB 0, 5, "BODY>"
	   59 3E
 00001843			do_BODYOFF:
 00001843  5B			    POP EBX
 00001844  83 EB 04		    sub ebx,  4
 00001847  53			    PUSH EBX
				    NEXTC
 00001848  8B 07	     1	   MOV EAX, [EDI]
 0000184A  83 C7 04	     1	   ADD EDI, 4
 0000184D  FF E0	     1	   JMP EAX 
				;
 0000184F			_WORD:       ; ( SADDR char -- Caddr ) CADDR = COUNTED STRING       ; VERIFIED
 0000184F  00001834 R		DD BODYOFF
 00001853  0000185D R		DD do_WORD
 00001857  00 04 57 4F 52	DB 0, 4, "WORD"
	   44
 0000185D			do_WORD: ; ( SADDR BL -- SADDR, LEN )
				; parse the input stream for a string delimited by char. Skip all leading char. Give a
				; counted string (the string is ended with a blank, not included in count).
				; If char is a blank treat all control characters as delimiter.
				; Use only inside colon definition.
 0000185D  5B			    POP     EBX ; delimiter CHAR
 0000185E  83 3D 000009C4 R	    CMP     S_LEN, 1
	   01
 00001865  7F 07		    JG      @@W1
				    NEXTC
 00001867  8B 07	     1	   MOV EAX, [EDI]
 00001869  83 C7 04	     1	   ADD EDI, 4
 0000186C  FF E0	     1	   JMP EAX 
 0000186E			@@W1:
 0000186E  58			    POP     EAX ; ADDRESS OF STRING
 0000186F  57			    PUSH    EDI
 00001870  56			    push    esi     	
 00001871  8B F8		    MOV     EDI, EAX            ; edi = input pointer
 00001873  B8 00000000		    MOV     EAX, 0
 00001878  B0 20		    mov     al, 32              ; al = delimiter = SPACE 
 0000187A  03 3D 00000930 R	    add     edi, _IN    		; add _IN
 00001880  8B 0D 000009C4 R	    mov     ecx, S_LEN          ; ecx = input length
 00001886  2B 0D 00000930 R	    sub     ecx, _IN    		; subtract _IN
 0000188C  77 0E		    ja      short @@9A
 0000188E  33 C9		    xor     ecx, ecx   			; at end of input
 00001890  C7 05 00000930 R	    MOV     _IN, 0
	   00000000
 0000189A  EB 68		    jmp     @@8A
 0000189C			@@9A:
 0000189C  3C 20		    cmp     al,  32
 0000189E  75 2D		    jne     short @@5A
				                                ; Delimiter is a blank, treat all chars <= 32 as the delimiter
 000018A0			@@1B:
 000018A0  38 07		    cmp     [edi], al           ; leading delimiter?
 000018A2  77 10		    ja      short @@2B
 000018A4  83 C7 01		    ADD     EDI, 1
 000018A7  EB F7		    JMP     @@1B
 000018A9  83 E9 01		    sub     ecx,  1
 000018AC  75 F2		    jnz     short @@1B
 000018AE  8B F7		    mov     esi, edi    		; esi = start of word
 000018B0  8B CF		    mov     ecx, edi    		; ecx = end of word
 000018B2  EB 34		    jmp     short @@7A
 000018B4			@@2B:
 000018B4  8B F7		    mov     esi, edi    		; esi = start of word
 000018B6			@@3B:
 000018B6  38 07		    cmp     [edi], al     		; end of word?
 000018B8  76 0C		    jbe     short @@4B
 000018BA  83 C7 01		    add     edi,  1
 000018BD  83 E9 01		    sub     ecx,  1
 000018C0  75 F4		    jnz     short @@3B
 000018C2  8B CF		    mov     ecx, edi    		; ecx = end of word
 000018C4  EB 22		    jmp     short @@7A
 000018C6			@@4B:
 000018C6  8B CF		    mov     ecx, edi    		; ecx = end of word DELIMITER FOUND
 000018C8  83 C7 01		    add     edi,  1  			; skip over ending delimiter
 000018CB  EB 1B		    jmp     short @@7A
										        ; delimiter is not a blank
 000018CD			@@5A:
 000018CD  F3/ AE		    repz    scasb
 000018CF  75 06		    jne     short @@6A
 000018D1  8B F7		    mov     esi, edi    		; end of input
 000018D3  8B CF		    mov     ecx, edi
 000018D5  EB 11		    jmp     short @@7A
 000018D7			@@6A:
 000018D7  83 EF 01		    sub     edi,  1    			; backup
 000018DA  83 C1 01		    add     ecx,  1
 000018DD  8B F7		    mov     esi, edi    		; esi = start of word
 000018DF  F2/ AE		    repnz   scasb
 000018E1  8B CF		    mov     ecx, edi    		; ecx = end of word
 000018E3  75 03		    jne     short @@7A
 000018E5  83 E9 01		    sub     ecx,  1   	 		; account for ending delimiter
				                                ; Update _IN pointer and get word length
 000018E8			@@7A:
 000018E8  2B 3D 000009B8 R	    sub     edi, S_ADR              ; offset from start
 000018EE  89 3D 00000930 R	    mov     _IN , edi   		    ; update _IN
 000018F4  2B CE		    sub     ecx, esi    		    ; length of word
 000018F6  3B 0D 00000994 R	    cmp     ecx,  MAXCOUNTED        ; max at MAXCOUNTED
 000018FC  76 06		    jbe     short @@8A
 000018FE  8B 0D 00000994 R	    mov     ecx,  MAXCOUNTED        ; clip to MAXCOUNTED
										            ; Move string to pocket
 00001904			@@8A:
 00001904  8B 3D 000009AC R	    mov     edi, POCKET         ; edi = pocket
 0000190A  57			    PUSH    EDI
 0000190B  88 0F		    mov     [edi], cl           ; store count byte
 0000190D  83 C7 01		    add     edi,  1
 00001910  F3/ A4		    rep     movsb       	    ; move rest of word
 00001912  B8 00000020		    mov     eax,  32
 00001917  AA			    stosb               	    ; append a BLANK to pocket
 00001918  58			    POP     EAX
 00001919  5E			    pop     esi
 0000191A  5F			    POP     EDI
 0000191B  40			    INC     EAX
 0000191C  50			    PUSH    EAX
				    NEXTC                       ; END OF WORD: 
 0000191D  8B 07	     1	   MOV EAX, [EDI]
 0000191F  83 C7 04	     1	   ADD EDI, 4
 00001922  FF E0	     1	   JMP EAX 
				;
 00001924			PARSENAME:  ; ( "<spaces>name" -- c-addr u ) ; parse the input stream
 00001924  0000184F R		DD _WORD
 00001928  00001937 R		DD do_PARSENAME
 0000192C  00 09 50 41 52	DB 0, 9, "PARSENAME"
	   53 45 4E 41 4D
	   45
 00001937			do_PARSENAME:
 00001937  5B			    POP EBX
				    ; for a string delimited by spaces. Skip all leading spaces.
				    ; Give the string as address and count.
 00001938  53			    push    ebx
 00001939  A1 000009B8 R	    mov     eax, S_ADR           ; edi = input pointer
 0000193E  03 05 00000930 R	    add     eax, _IN   		     ; add _IN
 00001944  50			    push    eax         		 ; address of output eax = input char
 00001945  8B 0D 000009C4 R	    mov     ecx, S_LEN           ; ecx = input length
 0000194B  2B 0D 00000930 R	    sub     ecx, _IN    		 ; subtract _IN
 00001951  77 04		    ja      short @@1C
 00001953  33 C9		    xor     ecx, ecx   			 ; at end of input
 00001955  EB 43		    jmp     short @@8C

 00001957			@@1C:
 00001957  50			    push    eax
 00001958  8B 00		    mov     eax, [eax]
 0000195A  83 F8 20		    cmp     eax,  32        ; leading delimiter?
 0000195D  58			    pop     eax
 0000195E  77 0E		    ja      @@2C
 00001960  83 C0 01		    add     eax,  1    		; go to next character
 00001963  83 E9 01		    sub     ecx,  1
 00001966  75 EF		    jnz     @@1C

 00001968  8B D8		    mov     ebx, eax    	; ebx = start of word
 0000196A  8B CB		    mov     ecx, ebx   		; ecx = end of word
 0000196C  EB 1C		    jmp     short @@7C

 0000196E			@@2C:
 0000196E  8B D8		    mov     ebx, eax    	; ebx = start of word
 00001970			@@3C:
 00001970  50			    push    eax
 00001971  8B 00		    mov     eax, [eax]
 00001973  83 F8 20		    cmp     eax,  32        ; end of word?
 00001976  58			    pop     eax
 00001977  76 0C		    jbe     @@4C
 00001979  83 C0 01		    add     eax,  1
 0000197C  83 E9 01		    sub     ecx,  1
 0000197F  75 EF		    jnz     short @@3C
 00001981  8B C8		    mov     ecx, eax        ; ecx = end of word
 00001983  EB 05		    jmp     short @@7C

 00001985			@@4C:
 00001985  8B C8		    mov     ecx, eax    	; ecx = end of word
 00001987  83 C0 01		    add     eax,  1    		; skip over ending delimiter
				            ; update _IN pointer and get word length
 0000198A			@@7C:
 0000198A  2B 05 000009B8 R	    sub     eax, S_ADR       ; offset from start
 00001990  A3 00000930 R	    mov     _IN , eax  		 ; update _IN
 00001995  2B CB		    sub     ecx, ebx    	 ; length of word
 00001997  89 1C 24		    mov     0 [esp], ebx     ; save on stack
 0000199A			@@8C:
 0000199A  8B D9		    mov     ebx, ecx    	 ; and length
				    NEXTC
 0000199C  8B 07	     1	   MOV EAX, [EDI]
 0000199E  83 C7 04	     1	   ADD EDI, 4
 000019A1  FF E0	     1	   JMP EAX 
				;
 000019A3			PARSEINIT:          ; ( BUFFLEN -- )
 000019A3  00001924 R		DD PARSENAME
 000019A7  000019B6 R		DD do_PARSEINIT
 000019AB  00 09 50 41 52	DB 0, 9, 'PARSEINIT'
	   53 45 49 4E 49
	   54
 000019B6			do_PARSEINIT:
 000019B6  8F 05 000009C8 R	POP S1_LEN
 000019BC  C7 05 00000934 R	MOV _1IN, 0
	   00000000
				NEXTC
 000019C6  8B 07	     1	   MOV EAX, [EDI]
 000019C8  83 C7 04	     1	   ADD EDI, 4
 000019CB  FF E0	     1	   JMP EAX 
				;
 000019CD			PARSE:      ; ( BUFFERRADDR, char "ccc<char>" -- c-addr u ) ; parse the input stream
 000019CD  000019A3 R		DD PARSEINIT
 000019D1  000019DC R		DD do_PARSE
 000019D5  00 05 50 41 52	DB 0, 5, "PARSE"
	   53 45
 000019DC			do_PARSE:
 000019DC  5B			    POP EBX                         ; CHARACTER TO SEARCH FOR
 000019DD  8F 05 000009BC R	    POP S1_ADR                      ; BUFFER TO SEARCH
 000019E3  A1 000009BC R	    mov     eax, S1_ADR             ; S_ADR = input pointer
 000019E8  03 05 00000934 R	    add     eax, _1IN    			; add _IN
 000019EE  50			    push    eax         			; address of INput
 000019EF  B2 20		    mov     dl, 32      			; char to scan for eax = input char
 000019F1  8B 0D 000009C8 R	    mov     ecx, S1_LEN             ; ecx = input length
 000019F7  2B 0D 00000934 R	    sub     ecx, _1IN    			; subtract _IN
 000019FD  77 04		    ja      short @@1D
 000019FF  33 C9		    xor     ecx, ecx                ; at end of input
 00001A01  EB 28		    jmp     short @@8D

 00001A03			@@1D:
 00001A03  8B D8		    mov     ebx, eax    			; ebx = start of word
 00001A05			@@3D:
 00001A05  38 10		    cmp     [eax], dl        		; end of word?
 00001A07  74 0C		    je      short @@4D
 00001A09  83 C0 01		    add     eax,  1
 00001A0C  83 E9 01		    sub     ecx,  1
 00001A0F  75 F4		    jnz     short @@3D
 00001A11  8B C8		    mov     ecx, eax    			; ecx = end of word
 00001A13  EB 05		    jmp     short @@7D

 00001A15			@@4D:
 00001A15  8B C8		    mov     ecx, eax    			; ecx = end of word
 00001A17  83 C0 01		    add     eax,  1    			    ; skip over ending delimiter
				                                    ; update _IN pointer and get word length
 00001A1A			@@7D:
 00001A1A  2B 05 000009BC R	    sub     eax, S1_ADR              ; offset from start
 00001A20  A3 00000934 R	    mov     _1IN , eax   			; update _IN
 00001A25  2B CB		    sub     ecx, ebx    			; length of word
 00001A27  89 5C 24 04		    mov     4 [esp], ebx            ; save on stack
 00001A2B			@@8D:
 00001A2B  8B D9		    mov     ebx, ecx    			; and length
 00001A2D  53			    PUSH EBX
				    NEXTC                           ; END OF PARSE
 00001A2E  8B 07	     1	   MOV EAX, [EDI]
 00001A30  83 C7 04	     1	   ADD EDI, 4
 00001A33  FF E0	     1	   JMP EAX 
				 ;
 00001A35			 PARSESTR:  ; ( Addr Len -- Addr Len)       VERIFIED 231205
 00001A35  000019CD R		DD PARSE
 00001A39  00001A48 R		DD do_PARSESTR
 00001A3D  00 09 50 41 52	DB 0, 9, "PARSE-STR"
	   53 45 2D 53 54
	   52
 00001A48			do_PARSESTR:
 00001A48  5B			POP EBX             ;   EBX register = LENGTH OF STRING
 00001A49  58			POP EAX             ;   Load String Address
 00001A4A  52			PUSH EDX            ;   Save register set
 00001A4B  50			PUSH EAX            ;   Save String address
 00001A4C  03 C3		ADD EAX , EBX       ;   Add length to addr to find End of string
 00001A4E  8B D0		MOV EDX , EAX       ;   Save End of string
 00001A50  58			POP EAX             ;   restore string addr
 00001A51  B9 00000000		MOV ECX,  0000      ;   Load Counter
 00001A56			@@1E:
 00001A56  50			push eax
 00001A57  8B 00		mov eax, [eax]
 00001A59  83 F8 20		CMP eax,  32        ;   advance over leading spaces
 00001A5C  58			pop eax
 00001A5D  75 07		JNE SHORT @@2E
 00001A5F  40			INC EAX
 00001A60  3B C2		CMP EAX, EDX
 00001A62  74 13		JE SHORT @@3E       ;   end of string encountered
 00001A64  EB F0		JMP SHORT @@1E
 00001A66			@@2E:
 00001A66  50			PUSH EAX            ;   save starting address
 00001A67			@@4E:
 00001A67  41			INC ECX
 00001A68  50			push eax
 00001A69  8A 00		mov AL, BYTE PTR [eax]
 00001A6B  3C 20		CMP AL,  32        ;   locate a space
 00001A6D  58			pop eax
 00001A6E  74 07		JE SHORT @@3E       ; trailing space found
 00001A70  3B C2		CMP EAX, EDX
 00001A72  74 03		JE SHORT @@3E       ;   past end of string
 00001A74  40			INC EAX
 00001A75  EB F0		JMP SHORT @@4E
 00001A77			@@3E:
 00001A77  49			DEC ECX
 00001A78  8B D9		MOV EBX, ECX        ;   move counter to ebx
 00001A7A  58			POP EAX
 00001A7B  5A			POP EDX
 00001A7C  50			PUSH EAX
 00001A7D  53			push ebx
				NEXTC               ; END OF PARSESTR
 00001A7E  8B 07	     1	   MOV EAX, [EDI]
 00001A80  83 C7 04	     1	   ADD EDI, 4
 00001A83  FF E0	     1	   JMP EAX 
				;
 00001A85			_NOOP:      ; VERIFIED
 00001A85  00001A35 R		DD PARSESTR
 00001A89  00001A93 R		DD do_NOOP
 00001A8D  00 04 4E 4F 4F	DB 0, 4, 'NOOP'
	   50
 00001A93			do_NOOP:
				NEXTC
 00001A93  8B 07	     1	   MOV EAX, [EDI]
 00001A95  83 C7 04	     1	   ADD EDI, 4
 00001A98  FF E0	     1	   JMP EAX 
				;
 00001A9A			_HERE:      ; VERIFIED
 00001A9A  00001A85 R		DD _NOOP
 00001A9E  00001AA8 R		DD do_HERE
 00001AA2  00 04 48 45 52	DB 0, 4, 'HERE'
	   45
 00001AA8			do_HERE:
 00001AA8  8B 1D 00000968 R	mov ebx, [DPR]
 00001AAE  53			push ebx
				NEXTC
 00001AAF  8B 07	     1	   MOV EAX, [EDI]
 00001AB1  83 C7 04	     1	   ADD EDI, 4
 00001AB4  FF E0	     1	   JMP EAX 
				;
 00001AB6			_UPPERCASE: ; ( SADDR LEN -- SADDR)     ; VERIFIED
 00001AB6  00001A9A R		DD _HERE
 00001ABA  00001AC9 R		DD do_UPPERCASE
 00001ABE  00 09 55 50 50	DB 0, 9, 'UPPERCASE'
	   45 52 43 41 53
	   45
 00001AC9			do_UPPERCASE:
 00001AC9  59			POP ECX  ; STRING LENGTH
 00001ACA  8B 1C 24		MOV  EBX ,[ESP]
 00001ACD  81 E1 000000FF	AND ECX, 0FFH
 00001AD3  B8 00000000		MOV EAX, 0
 00001AD8  89 1D 000009E8 R	MOV TV$, EBX 
 00001ADE  FF 35 000009E8 R	push TV$
 00001AE4  E8 00000000 E	call szUpper
				NEXTC       ; UPPERCASE
 00001AE9  8B 07	     1	   MOV EAX, [EDI]
 00001AEB  83 C7 04	     1	   ADD EDI, 4
 00001AEE  FF E0	     1	   JMP EAX 
				;
 00001AF0			_LOWERCASE: ; ( SADDR LEN -- SADDR)     ; VERIFIED
 00001AF0  00001AB6 R		DD _UPPERCASE
 00001AF4  00001B03 R		DD do_LOWERCASE
 00001AF8  00 09 4C 4F 57	DB 0, 9, 'LOWERCASE'
	   45 52 43 41 53
	   45
 00001B03			do_LOWERCASE:
 00001B03  59			POP ECX  ; STRING LENGTH
 00001B04  8B 1C 24		MOV  EBX ,[ESP]
 00001B07  81 E1 000000FF	AND ECX, 0FFH
 00001B0D  B8 00000000		MOV EAX, 0
 00001B12  89 1D 000009E8 R	MOV TV$, EBX 
 00001B18  FF 35 000009E8 R	push TV$
 00001B1E  E8 00000000 E	call szLower
				NEXTC       ; LOWERCASE
 00001B23  8B 07	     1	   MOV EAX, [EDI]
 00001B25  83 C7 04	     1	   ADD EDI, 4
 00001B28  FF E0	     1	   JMP EAX 
				;
 00001B2A			FIND: ; ( SADDR LEN -- cfa   ) Search dictionary for a word         VERIFIED
 00001B2A  00001AF0 R		DD _LOWERCASE
 00001B2E  00001B38 R		DD do_FIND
 00001B32  00 04 46 49 4E	DB 0, 4, 'FIND'
	   44
 00001B38			do_FIND:
 00001B38  C7 05 0000096C R	MOV FCOUNTER, 0
	   00000000
 00001B42  C7 05 0000094C R	MOV CFA, 0
	   00000000
 00001B4C  C7 05 00000984 R	MOV LFA, 0
	   00000000
 00001B56  C7 05 000009A0 R	MOV NFA, 0
	   00000000
 00001B60  C7 05 00000970 R	MOV FFLAG, 0
	   00000000
 00001B6A  B8 00000000		MOV EAX, 0
 00001B6F  59			POP ECX     ; LENGTH
 00001B70  66| 83 E1 0F		AND CX, 0FH
 00001B74  66| 83 F9 00		CMP CX, 0
 00001B78  7F 18		JG @@01
 00001B7A  C7 05 00000970 R	MOV FFLAG, 0
	   00000000
 00001B84  58			POP EAX     ; REMOVE ADDRESS FROM STACK
 00001B85  FF 35 0000094C R	PUSH CFA    
				NEXTC       ; ABORT
 00001B8B  8B 07	     1	   MOV EAX, [EDI]
 00001B8D  83 C7 04	     1	   ADD EDI, 4
 00001B90  FF E0	     1	   JMP EAX 
 00001B92			@@01:
 00001B92  58			POP EAX     ; POCKET ADDRESS
 00001B93  57			PUSH EDI    ; INTERPRETER POINTER
 00001B94  FF 35 00000980 R	PUSH [LATEST] 
 00001B9A			@@6F:
 00001B9A  FF 05 0000096C R	INC FCOUNTER
 00001BA0  5B			POP EBX
 00001BA1  3A 4B 09		CMP CL,  [EBX+9]
 00001BA4  75 46		JNZ @@1F
				; WORD LENGHTS ARE EQUAL CMP WORDS
 00001BA6  89 1D 00000984 R	MOV LFA, EBX
 00001BAC  53			PUSH EBX
 00001BAD  83 C3 09		ADD EBX, 9
 00001BB0  89 1D 000009A0 R	MOV NFA, EBX    
 00001BB6  5B			POP EBX
 00001BB7  53			PUSH EBX
 00001BB8  8A 0D 00000878 R	MOV CL, [POC]
 00001BBE  66| 83 E1 0F		AND CX, 0FH
 00001BC2  83 C3 04		ADD EBX, 4
 00001BC5  FF 33		PUSH [EBX]
 00001BC7  8F 05 0000094C R	POP CFA
 00001BCD  83 C3 06		ADD EBX, 6
 00001BD0  8B F0		MOV ESI, EAX
 00001BD2  8B FB		MOV EDI, EBX
 00001BD4  F3/ A6		REPE CMPSB
 00001BD6  5B			POP EBX
 00001BD7  8A 0D 00000878 R	MOV CL, [POC]
 00001BDD  75 0D		JNZ @@1F 
 00001BDF  5F			POP EDI
 00001BE0  C7 05 00000970 R	MOV FFLAG, -1
	   FFFFFFFF
 00001BEA  EB 42		JMP @@5F
 00001BEC			@@1F:
 00001BEC  8B 1B		MOV EBX, [EBX] ; LINK ADDRESS
 00001BEE  53			PUSH EBX
 00001BEF  FF 33		PUSH [EBX] ; LINK ADDRESS
 00001BF1  5B			POP EBX 
 00001BF2  83 FB 00		CMP EBX, 0
 00001BF5  74 19		JZ @@6F1
 00001BF7  8B 1C 24		MOV EBX, [ESP] ; RECOVER ADDRESS
 00001BFA  C7 05 000009A0 R	MOV NFA, 0
	   00000000
 00001C04  C7 05 00000984 R	MOV LFA, 0
	   00000000
 00001C0E  EB 8A		JMP @@6F
 00001C10			@@6F1:
 00001C10  59			POP ECX
 00001C11  5F			POP EDI
 00001C12  FF 35 000009AC R	PUSH POCKET
 00001C18  8F 05 0000094C R	POP CFA
 00001C1E  FF 05 0000094C R	INC CFA
 00001C24  C7 05 00000970 R	MOV FFLAG, 0
	   00000000
 00001C2E			@@5F:
 00001C2E  FF 35 0000094C R	PUSH CFA
				NEXTC ; FIND: LEAVING CFA
 00001C34  8B 07	     1	   MOV EAX, [EDI]
 00001C36  83 C7 04	     1	   ADD EDI, 4
 00001C39  FF E0	     1	   JMP EAX 
				;
 00001C3B			GTNUMBER:    ;( ud addr len -- ud addr len )    VERIFIED 231211
 00001C3B  00001AF0 R		DD _LOWERCASE
 00001C3F  00001C4D R		DD do_GTNUMBER
 00001C43  00 08 47 54 4E	DB 0, 8, 'GTNUMBER'
	   55 4D 42 45 52
 00001C4D			do_GTNUMBER:
 00001C4D  5B			                POP     EBX
 00001C4E  85 DB		                test    ebx, ebx                ; check if anything to convert
 00001C50  74 55		                je      short @@4H              ; zero, so skip
 00001C52  89 7D FC		                mov     [ebp-4], edi
 00001C55  89 55 F8		                mov     [ebp-8], edx            ; save UP
 00001C58  8B 34 24		                mov     esi, [esp]              ; esi = address
 00001C5B  8B 3D 00000944 R	                mov     edi, BASE               ; get the number base
 00001C61  0F B6 06		@@1H:           movzx   eax, byte ptr [esi]     ; get next digit
 00001C64  3C 30		                cmp     al,  '0'
 00001C66  72 36		                jb      short @@3H              ; if below '0' branch to done
 00001C68  3C 39		                cmp     al,  '9'
 00001C6A  76 08		                jbe     short @@2H              ; go convert it
 00001C6C  24 DF		                and     al,  0DFH               ; convert to uppercase
 00001C6E  3C 41		                cmp     al,  'A'                ; if below 'A'
 00001C70  72 2C		                jb      short @@3H              ; then branch to done
 00001C72  2C 07		                sub     al,  7
 00001C74  2C 30		@@2H:           sub     al,  '0'
 00001C76  3B C7		                cmp     eax, edi
 00001C78  73 24		                jae     short @@3H              ; out of base range
 00001C7A  87 44 24 04		                xchg    eax, 4 [esp]            ; high word * base
 00001C7E  F7 E7		                mul     edi
 00001C80  87 44 24 08		                xchg    eax, 8 [esp]            ; low word * base
 00001C84  F7 E7		                mul     edi
 00001C86  03 44 24 04		                add     eax, 4 [esp]            ; add
 00001C8A  13 54 24 08		                adc     edx, 8 [esp]
 00001C8E  89 44 24 08		                mov     8 [esp], eax            ; store result
 00001C92  89 54 24 04		                mov     4 [esp], edx
 00001C96  83 C6 01		                add     esi,  1
 00001C99  83 EB 01		                sub     ebx,  1
 00001C9C  75 C3		                jnz     short @@1H
 00001C9E  89 34 24		@@3H:           mov     [esp], esi              ; address of unconvertable digit
 00001CA1  8B 7D FC		                mov     edi, [ebp-4]
 00001CA4  8B 55 F8		                mov     edx, [ebp-8]            ; save UP
 00001CA7			@@4H:            
				NEXTC
 00001CA7  8B 07	     1	   MOV EAX, [EDI]
 00001CA9  83 C7 04	     1	   ADD EDI, 4
 00001CAC  FF E0	     1	   JMP EAX 
				;
 00001CAE			NUMINIT:      ; ( -- )                  initialise number values
 00001CAE  00001C3B R		DD GTNUMBER
 00001CB2  00001CBF R		DD do_NUMINIT
 00001CB6  00 07 4E 55 4D	DB 0, 7, 'NUMINIT'
	   49 4E 49 54
 00001CBF			do_NUMINIT:
 00001CBF  C7 05 00000960 R	MOV DOUBLEQ, -1                ; false to double?
	   FFFFFFFF
 00001CC9  C7 05 00000964 R	MOV DPLOCATION, -1             ; -1 to dp-location
	   FFFFFFFF
 00001CD3  C7 05 000009EC R	MOV VENUMQ, 0                  ; false to -ve-num?
	   00000000
				NEXTC
 00001CDD  8B 07	     1	   MOV EAX, [EDI]
 00001CDF  83 C7 04	     1	   ADD EDI, 4
 00001CE2  FF E0	     1	   JMP EAX 
				;
 00001CE4			NEWNUMB: ; ( ADDR F -- N F )  ONLY WORKS FOR DECIMAL INTEGERS (+/-)       ; VERIFIED 231219
 00001CE4  00001CAE R		DD NUMINIT
 00001CE8  00001CF5 R		DD do_NEWNUMB
 00001CEC  00 07 4E 45 57	DB 0, 7,'NEWNUMB'
	   4E 55 4D 42
 00001CF5			do_NEWNUMB:
 00001CF5  5B			POP EBX
 00001CF6  83 FB 00		CMP EBX, 0
 00001CF9  75 0F		JNE @NEWNUMB
 00001CFB  E8 00000000 E	call atol   ; CONVERT ASCII STRING TO NUMBER (EAX)
 00001D00  50			PUSH EAX
 00001D01  6A FF		PUSH -1
				NEXTC
 00001D03  8B 07	     1	   MOV EAX, [EDI]
 00001D05  83 C7 04	     1	   ADD EDI, 4
 00001D08  FF E0	     1	   JMP EAX 
 00001D0A			@NEWNUMB:
 00001D0A  6A F3		PUSH -13    ; UNDEFINED
 00001D0C  6A 00		PUSH 0
				NEXTC
 00001D0E  8B 07	     1	   MOV EAX, [EDI]
 00001D10  83 C7 04	     1	   ADD EDI, 4
 00001D13  FF E0	     1	   JMP EAX 
				;
 00001D15			NEWHEADER:   ; ( ADDR LEN  -  )
 00001D15  00001CE4 R		DD NEWNUMB
 00001D19  00001D28 R		DD do_NEWHEADER
 00001D1D  00 07 4E 45 57	DB 0, 7, 'NEWHEADER'
	   48 45 41 44 45
	   52
 00001D28			do_NEWHEADER:
 00001D28  59			POP ECX     ; LENGTH
 00001D29  5B			POP EBX     ; ADDR TIB
 00001D2A  57			PUSH EDI
 00001D2B  51			PUSH ECX
 00001D2C  81 E1 000000FF	AND ECX, 00FFH
 00001D32  41			INC ECX
 00001D33  8B 15 00000980 R	MOV EDX, LATEST     ; PREVIOUS LFA
 00001D39  A1 00000968 R	MOV EAX, DPR
 00001D3E  A3 00000984 R	MOV LFA, EAX        ; SAVE LFA
 00001D43  89 10		MOV [EAX],  EDX     ; LOAD LFA
 00001D45  A3 00000980 R	MOV LATEST, EAX     ; UPDATE LATEST WITH NEW LFA
 00001D4A  83 C0 08		ADD EAX, 8          ; BFA
 00001D4D  C6 00 00		MOV BYTE PTR [EAX], 0
 00001D50  40			INC EAX             ; MOVE TO NFA
 00001D51  A3 000009A0 R	MOV NFA, EAX        ; SAVE NFA 
 00001D56  8B F8		MOV EDI, EAX
 00001D58  83 EB 01		SUB EBX, 1
 00001D5B  8B F3		MOV ESI, EBX
 00001D5D  F3/ A4		REP MOVSB           ; LOAD NFA WITH LENGTH BYTE AND STRING
 00001D5F  A1 00000968 R	MOV EAX, DPR          
 00001D64  59			POP ECX
 00001D65  41			INC ECX
 00001D66  83 C1 09		ADD ECX, 9         
 00001D69  03 C1		ADD EAX, ECX        ; CFA
 00001D6B  A3 0000094C R	MOV CFA, EAX
 00001D70  A1 00000984 R	MOV EAX, LFA
 00001D75  83 C0 04		ADD EAX, 4
 00001D78  FF 35 0000094C R	PUSH CFA
 00001D7E  8F 00		POP [EAX]           ; SAVE CFA
 00001D80  FF 35 0000094C R	PUSH CFA
 00001D86  58			POP EAX
 00001D87  50			PUSH EAX
 00001D88  8F 05 00000968 R	POP DPR
 00001D8E  5F			POP EDI
				NEXTC       ; EXIT NEWHEADER
 00001D8F  8B 07	     1	   MOV EAX, [EDI]
 00001D91  83 C7 04	     1	   ADD EDI, 4
 00001D94  FF E0	     1	   JMP EAX 
				;
 00001D96			KBREAD:   ; READ INPUT FROM KEYBOARD        ; VERIFIED
 00001D96  00001D15 R		DD NEWHEADER
 00001D9A  00001DA6 R		DD do_KBREAD
 00001D9E  00 06 4B 42 52	DB 0, 6, 'KBREAD'
	   45 41 44
 00001DA6			do_KBREAD:
 00001DA6  8D 05 00000C25 R	lea eax, MsgQ
 00001DAC  50			push eax
 00001DAD  E8 00000000 E	call StdOut
 00001DB2  6A 01		push LENGTHOF TIB
 00001DB4  8D 05 00001CA3 R	lea eax, TIB
 00001DBA  50			push eax
 00001DBB  E8 00000000 E	call StdIn
 00001DC0  8D 1D 00001CA3 R	LEA EBX, TIB    ; ADD A SPACE TO END OF INPUT LINE
 00001DC6  03 D8		ADD EBX, EAX
 00001DC8  6A 20		PUSH 20H
 00001DCA  8F 03		POP [EBX]
 00001DCC  83 C0 01		ADD EAX, 1
 00001DCF  A3 000009C4 R	MOV S_LEN, EAX
 00001DD4  50			PUSH EAX
				NEXTC
 00001DD5  8B 07	     1	   MOV EAX, [EDI]
 00001DD7  83 C7 04	     1	   ADD EDI, 4
 00001DDA  FF E0	     1	   JMP EAX 
				;
 00001DDC			CLS: ; CLEAR SCREEN     ; VERIFIED
 00001DDC  00001D96 R		DD KBREAD
 00001DE0  00001DE9 R		DD do_CLS
 00001DE4  00 03 43 4C 53	DB 0, 3, 'CLS'
 00001DE9			do_CLS:
				    invoke ClearScreen
 00001DE9  E8 00000000 E   *	    call   ClearScreen
				NEXTC
 00001DEE  8B 07	     1	   MOV EAX, [EDI]
 00001DF0  83 C7 04	     1	   ADD EDI, 4
 00001DF3  FF E0	     1	   JMP EAX 
				;
 00001DF5			CR: ; EMIT CRLF ; VERIFIED
 00001DF5  00001DDC R		DD CLS
 00001DF9  00001E01 R		DD do_CR
 00001DFD  00 02 43 52		DB 0, 2, 'CR'
 00001E01			do_CR:
 00001E01  8D 05 00000C3F R	lea eax, crlf$
 00001E07  50			push eax
 00001E08  E8 00000000 E	call StdOut
				NEXTC
 00001E0D  8B 07	     1	   MOV EAX, [EDI]
 00001E0F  83 C7 04	     1	   ADD EDI, 4
 00001E12  FF E0	     1	   JMP EAX 
				;
 00001E14			DABS:           ; ( d1 -- d2 )    \ return the absolute value of d1 as d2
 00001E14  00001DF5 R		DD CR
 00001E18  00001E22 R		DD do_DABS
 00001E1C  00 04 44 41 42	DB 0, 4, 'DABS'
	   53
 00001E22			do_DABS:
 00001E22  5B			POP     EBX
 00001E23  85 DB		test    ebx, ebx
 00001E25  79 09		jns     short @@1K
 00001E27  58			pop     eax
 00001E28  F7 DB		neg     ebx
 00001E2A  F7 D8		neg     eax
 00001E2C  83 DB 00		sbb     ebx, 0
 00001E2F  50			push    eax
 00001E30			@@1K:   NEXTC
 00001E30  8B 07	     1	   MOV EAX, [EDI]
 00001E32  83 C7 04	     1	   ADD EDI, 4
 00001E35  FF E0	     1	   JMP EAX 
				;
 00001E37			HOLD:       ; ( char -- ) \ insert char in number output picture - see <#
 00001E37  00001E14 R		DD DABS
 00001E3B  00001E45 R		DD do_HOLD
 00001E3F  00 04 48 4F 4C	DB 0, 4, 'HOLD'
	   44
 00001E45			do_HOLD:
 00001E45  8B 42 04		mov     eax, 4 [EDX]   ; UP EQU EDX  ( [EDX] + 4 )  CELLS = + 4  MOV EAX, [EDX] + 4
 00001E48  83 E8 01		sub     eax, 1
 00001E4B  C6 00 20		mov     BYTE PTR [eax], 32
 00001E4E  89 42 04		mov     4 [EDX], eax   ; DUP USER HLD CELL+ ( numeric output pointer )
 00001E51  5B			pop     ebx
 00001E52  53			PUSH    EBX
				NEXTC
 00001E53  8B 07	     1	   MOV EAX, [EDI]
 00001E55  83 C7 04	     1	   ADD EDI, 4
 00001E58  FF E0	     1	   JMP EAX 
				;
 00001E5A			SPACES: ; ( N -- )
 00001E5A  00001E37 R		DD HOLD
 00001E5E  00001E6A R		DD do_SPACES
 00001E62  00 06 53 50 41	DB 0, 6, 'SPACES'
	   43 45 53
 00001E6A			do_SPACES:
 00001E6A  59			POP ECX ; NUMBER OF SPACES
 00001E6B			@@1L:
 00001E6B  8D 05 00000C46 R	 lea eax, SPACE$
 00001E71  E8 00000000 E	 call StdOut
 00001E76  FE CB		 DEC BL
 00001E78  80 FB 00		 CMP BL, 0
 00001E7B  75 EE		 JNZ @@1L
				 NEXTC
 00001E7D  8B 07	     1	   MOV EAX, [EDI]
 00001E7F  83 C7 04	     1	   ADD EDI, 4
 00001E82  FF E0	     1	   JMP EAX 
				;
 00001E84			POUND:              ; CODE #  ( d1 -- d2 ) \ convert a digit in pictured number output - see <#
 00001E84  00001E5A R		DD SPACES
 00001E88  00001E8F R		DD do_POUND
 00001E8C  00 01 23		DB 0, 1, '#'
 00001E8F			do_POUND:
 00001E8F  5B			POP EBX
 00001E90  8B C3		MOV EAX, EBX
 00001E92  8B 0D 00000944 R	MOV ECX, BASE
 00001E98  F6 F1		DIV CL
 00001E9A  80 FC 09		cmp AH,  9
 00001E9D  76 03		jbe short @@1M
 00001E9F  80 C4 07		add AH,  7
 00001EA2			@@1M:           
 00001EA2  80 C4 30		add AH,  48           ; '0' 48D, 30H
 00001EA5  50			PUSH EAX
 00001EA6  A1 00000978 R	MOV EAX, HLD
 00001EAB  83 E8 01		SUB EAX, 1
 00001EAE  A3 00000978 R	MOV HLD, EAX
 00001EB3  5A			POP EDX
 00001EB4  88 30		MOV BYTE PTR [EAX], DH
 00001EB6  B6 00		MOV DH, 0
 00001EB8  52			PUSH EDX
				NEXTC
 00001EB9  8B 07	     1	   MOV EAX, [EDI]
 00001EBB  83 C7 04	     1	   ADD EDI, 4
 00001EBE  FF E0	     1	   JMP EAX 
				;
 00001EC0			itohex:                  ; (PAD N -- PAD)       VERIFIED 231206
 00001EC0  00001E84 R		DD POUND
 00001EC4  00001ECF R		DD do_I2HEX
 00001EC8  00 05 49 32 48	DB 0, 5, 'I2HEX'
	   45 58
 00001ECF			do_I2HEX:
 00001ECF  57			    push   edi           ; save a call-preserved register for scratch space
 00001ED0  8B 7C 24 08		    mov    edi, [esp+8]  ; out pointer

 00001ED4  8B 44 24 04		    mov    eax, [esp+4]  ; number

 00001ED8  B9 00000008		    mov    ecx, 8        ; 8 hex digits, fixed width zero-padded
 00001EDD			@@loopA:
 00001EDD  C1 C0 04		    rol    eax, 4        ; rotate the high 4 bits to the bottom
 00001EE0  8B D0		    mov    edx, eax
 00001EE2  83 E2 0F		    and    edx, 0fH      ; and isolate 4-bit integer in EDX
 00001EE5  80 FA 00		    CMP    DL, 0
 00001EE8  75 0A		    JNZ    @@loopB
 00001EEA  49			    DEC    ECX           ; SKIP LEADING 0'S
 00001EEB  C6 07 20		    MOV    BYTE PTR [EDI], 32
 00001EEE  47			    INC    EDI
 00001EEF  EB EC		    JMP    @@loopA
 00001EF1			@@loop:                  ; do {
 00001EF1  C1 C0 04		    rol    eax, 4        ; rotate the high 4 bits to the bottom
 00001EF4			@@loopB:
 00001EF4  8B D0		    mov    edx, eax
 00001EF6  83 E2 0F		    and    edx, 0fH      ; and isolate 4-bit integer in EDX

 00001EF9  8A 92 00000C48 R	    MOV    DL, byte PTR [HEX_TABLE + edx]
				    ; movzx  edx, DL     
 00001EFF  88 17		    mov    [edi], DL     ; copy a character from the lookup table
 00001F01  47			    inc    edi           ; loop forward in the output buffer

 00001F02  49			    dec    ecx
 00001F03  75 EC		    jnz    @@loop        ; }while(--ecx)
 00001F05  C6 07 48		    MOV    BYTE PTR [EDI], 72
 00001F08  5F			    pop    edi
 00001F09  58			    POP    EAX
				    NEXTC
 00001F0A  8B 07	     1	   MOV EAX, [EDI]
 00001F0C  83 C7 04	     1	   ADD EDI, 4
 00001F0F  FF E0	     1	   JMP EAX 
				;
 00001F11			__UNTIL:     ;    ( f1 -- )       \ "runtime" if f1=FALSE branch to after BEGIN
 00001F11  00001EC0 R		DD itohex
 00001F15  00001F21 R		DD do__UNTIL
 00001F19  00 06 5F 55 4E	DB 0, 6, '_UNTIL'
	   54 49 4C
 00001F21			do__UNTIL:
 00001F21  85 DB		test    ebx, ebx
 00001F23  5B			pop     ebx
 00001F24  74 0B		je      short @@11A
 00001F26  8B 77 04		mov     eSI, 4 [edi]
 00001F29  83 C7 08		add     edi, 8
 00001F2C  FF 36		PUSH    [ESI]
 00001F2E  5E			POP     ESI
 00001F2F  FF E6		jmp     ESI
 00001F31			@@11A:            
 00001F31  8B 3F		   mov edi, [edi]
 00001F33  FF 37		   PUSH [EDI]
 00001F35  5E			   POP ESI
 00001F36  83 EE 04		   SUB ESI, 4
				   ;mov eax, -4 [edi]
 00001F39  FF 36		   PUSH [ESI]
 00001F3B  5E			   POP ESI
 00001F3C  FF E6		   jmp ESI
				;
 00001F3E			_IF@:        ; INTERACTIVE IF - THEN PAIR    ; VERIFIED
 00001F3E  00001F11 R		DD __UNTIL
 00001F42  00001F4C R		DD do_IF@
 00001F46  00 03 5B 49 46	DB 0, 3, '[IF]'
	   5D
 00001F4C			do_IF@:
 00001F4C  5B			POP EBX
 00001F4D  83 FB 00		CMP EBX,0
 00001F50  74 07		JZ @IF
				NEXTC       ; CONTINUE PROCESS NEXT WORDS
 00001F52  8B 07	     1	   MOV EAX, [EDI]
 00001F54  83 C7 04	     1	   ADD EDI, 4
 00001F57  FF E0	     1	   JMP EAX 
 00001F59			@IF:        ; SKIP WORDS TILL do_THEN@ FOUND
 00001F59  81 3F 00001F88 R	cmp [edi], do_ELSE@
 00001F5F  74 0D		JZ @IF1a
 00001F61  81 3F 00001FAC R	CMP [EDI], do_THEN@
 00001F67  74 08		JZ @IF1
 00001F69  83 C7 04		ADD EDI, 4
 00001F6C  EB EB		JMP @IF
 00001F6E			@IF1a:
 00001F6E  83 C7 04		ADD EDI, 4
 00001F71			@IF1:
				; CONTINUE PROCESSING WORDS
				NEXTC
 00001F71  8B 07	     1	   MOV EAX, [EDI]
 00001F73  83 C7 04	     1	   ADD EDI, 4
 00001F76  FF E0	     1	   JMP EAX 
				;
 00001F78			_ELSE@:      ; INTERACTIVE
 00001F78  00001F3E R		DD _IF@
 00001F7C  00001F88 R		DD do_ELSE@
 00001F80  00 05 5B 45 4C	DB 0, 5, '[ELSE]'
	   53 45 5D
 00001F88			do_ELSE@:
 00001F88  81 3F 00001FAC R	CMP [EDI], do_THEN@
 00001F8E  74 05		JZ else1
 00001F90  83 C7 04		ADD EDI, 4
 00001F93  EB F3		JMP do_ELSE@
 00001F95			else1:
				NEXTC
 00001F95  8B 07	     1	   MOV EAX, [EDI]
 00001F97  83 C7 04	     1	   ADD EDI, 4
 00001F9A  FF E0	     1	   JMP EAX 
				;
 00001F9C			_THEN@:      ; INTERACTIVE  ; VERIFIED
 00001F9C  00001F78 R		DD _ELSE@
 00001FA0  00001FAC R		DD do_THEN@
 00001FA4  00 05 5B 54 48	DB 0, 5, '[THEN]'
	   45 4E 5D
 00001FAC			do_THEN@:
				; NOOP
				NEXTC
 00001FAC  8B 07	     1	   MOV EAX, [EDI]
 00001FAE  83 C7 04	     1	   ADD EDI, 4
 00001FB1  FF E0	     1	   JMP EAX 
				;
 00001FB3			HASHV:     ; ( a1 n1 #threads -- n2 )        verified 231210
 00001FB3  00001F9C R		DD _THEN@
 00001FB7  00001FC2 R		DD do_HASHV
 00001FBB  00 05 48 41 53	DB 0, 5, 'HASHV'
	   48 56
 00001FC2			do_HASHV:
 00001FC2  5B			 POP     EBX
 00001FC3  58			 pop     eax                     ; pop count into EAX
 00001FC4  89 55 FC		 mov     [EBP-4], edx            ; save UP
 00001FC7  89 5D F8		 mov     [EBP-8], ebx            ; save # of threads
 00001FCA  5B			 pop     ebx                     ; get string address into EBX
 00001FCB  8B C8		 mov     ecx, eax                ; copy count into ECX
 00001FCD  03 D9		 add     ebx, ecx
 00001FCF  F7 D9		 neg     ecx
 00001FD1			@@1HV:
 00001FD1  C1 C0 07		 rol     eax,  7                 ; rotate result some
 00001FD4  32 04 19		 xor     al, [ebx] [ecx]
 00001FD7  83 C1 01		 add     ecx,  1
 00001FDA  7C F5		 jl      @@1HV                   ; +ve, keep going
 00001FDC  33 D2		 xor     edx, edx                ; clear high part of dividend
 00001FDE  F7 75 F8		 div     DWORD PTR [EBP-8]       ; perform modulus by #threads
 00001FE1  8B DA		 mov     ebx, edx                ; move result into EBX
 00001FE3  8B 55 FC		 mov     edx, [EBP-4]            ; restore UP
 00001FE6  8D 1C 9D		 lea     ebx, [ebx*4]            ; multiply by cell size
	   00000000
 00001FED  53			 push    ebx
				 NEXTC
 00001FEE  8B 07	     1	   MOV EAX, [EDI]
 00001FF0  83 C7 04	     1	   ADD EDI, 4
 00001FF3  FF E0	     1	   JMP EAX 
				;
 00001FF5			EXECUTE:   ;( cfa -- )  execute a Forth word, given its cfa  ; VERIFIED 231229
 00001FF5  00001FB3 R		DD HASHV
 00001FF9  00002006 R		DD do_EXECUTE
 00001FFD  00 07 45 58 45	DB 0, 7, 'EXECUTE'
	   43 55 54 45
 00002006			do_EXECUTE:
 00002006  58			   POP EAX
 00002007  FF E0		   jmp eax
;
 00002009			_EMSG:                  ; VERIFIED 231219
 00002009  00001FF5 R		DD EXECUTE
 0000200D  00002018 R		DD do_EMSG
 00002011  00 05 45 4D 53	DB 0, 5, 'EMSG?'
	   47 3F
 00002018			do_EMSG:
 00002018  8B 04 24		MOV EAX, [ESP]
 0000201B  83 F8 FF		CMP EAX, -1
 0000201E  74 2D		JE @EMSG
 00002020  58			POP EAX
 00002021  8D 05 00000B10 R	lea eax, Msg10
 00002027  50			push eax
 00002028  E8 00000000 E	call StdOut
 0000202D  8D 05 00000878 R	lea eax, POC
 00002033  83 C0 01		add eax, 1
 00002036  50			push eax
 00002037  E8 00000000 E	call StdOut
 0000203C  8D 05 00000B22 R	lea eax, Msg11
 00002042  50			push eax
 00002043  E8 00000000 E	call StdOut
 00002048  BF 00000718 R	MOV EDI, _ABORT@ + 4 
 0000204D			@EMSG:
 0000204D  58			POP EAX
				NEXTC
 0000204E  8B 07	     1	   MOV EAX, [EDI]
 00002050  83 C7 04	     1	   ADD EDI, 4
 00002053  FF E0	     1	   JMP EAX 
				;

 00002055			_PDOTP:                        ; ( -- addr len )                
 00002055  00002009 R		DD _EMSG
 00002059  00002063 R		DD do_PDOTP
 0000205D  00 04 28 2E 22	DB 0, 4, '(.")'
	   29
 00002063			do_PDOTP:
 00002063  8D 0F		lea     ecx, [edi]             ; start of string
 00002065  0F B6 1F		movzx   ebx, byte ptr [edi]    ; length of string in TOS
 00002068  51			push    ecx                    ; save addr of string
 00002069  8D 74 0B 04		lea     esi, 4 [ecx] [ebx]     ; optimised next, account for len & null at end
 0000206D  83 E6 FC		and     esi, -4                ; align
 00002070  8D 05 0000220F R	LEA EAX, do_TYPE               ; mov     eax, # ' TYPE          \ next word
 00002076  FF E0		JMP     EAX                    ; go do it
				;
 00002078			_SP:                            ; ( -- ADDR N)  EG S" TEXT TO HANDLE"         VERIFIED
 00002078  00002055 R		DD _PDOTP
 0000207C  00002084 R		DD do_SP
 00002080  00 02 53 22		DB 0, 2, 'S"'
 00002084			do_SP:
 00002084  8D 05 00001CA3 R	LEA EAX, TIB                    ; SAVE THE ADDRESS OF TIB FOR WORD
 0000208A  50			PUSH EAX
 0000208B  6A 22		PUSH 34                         ; PUSH ASCII "
 0000208D  68 00002097 R	PUSH $ + 10
 00002092  E9 FFFFF553		JMP do_DOCOL
 00002097  0000185D R		DD do_WORD                      ; PARSE INPUT STRING TIB " WORD
 0000209B  000013AB R		DD do_COUNT                     ; GET LENGTH
 0000209F  000008A9 R		DD do_PUSH1, do_IN, do_FETCH    ; 1 _IN @ + _IN !     INCREMENT THE _IN OFFSET
	   0000025F R
	   00000922 R
 000020AB  00000A79 R		DD do_PLUS, do_IN, do_STORE
	   0000025F R
	   00000938 R
 000020B7  00001DB0 R		DD SCRATCH, do_DUP, do_LIT, 80, do_ERASE
	   00000C37 R
	   00000C07 R
	   00000050
	   000017FF R
 000020CB  00000C50 R		DD do_SWAP                      ; MOVE THE DATA IN THE TIB TO THE DATA AREA
 000020CF  00000F9A R		DD do_2DUP, do_2TOR, do_CMOVE, do_2RFROM
	   00000F3D R
	   0000179E R
	   00000F5F R
 000020DF  00000132 R		DD do_STATE, do_FETCH
	   00000922 R
 000020E7  00001F4C R		DD do_IF@ 
 000020EB  00001AA8 R		DD do_HERE, do_OVER, do_CCOMMA, do_OVER, do_ALLOT, do_1PLUS, do_SWAP, do_CMOVE
	   00000C6F R
	   00002830 R
	   00000C6F R
	   0000311A R
	   00000B44 R
	   00000C50 R
	   0000179E R
 0000210B  000008D6 R		DD do_PUSH0, do_CCOMMA, do_ALIGN
	   00002830 R
	   0000261B R
 00002117  00001FAC R		DD do_THEN@
 0000211B  00000862 R		DD do_SEMI
				;
 0000211F			_Endless:    ; ENDLESS LOOP      VERIFIED
 0000211F  00002078 R		DD _SP
 00002123  00002130 R		DD do_Endless
 00002127  00 07 45 4E 44	DB 0, 7, 'ENDLESS'
	   4C 45 53 53
 00002130			do_Endless:
 00002130  EB FE		JMP do_Endless
				;
 00002132			_QMISSING: ; ( f --  )
 00002132  0000211F R		DD _Endless 
 00002136  00002144 R		DD do_?MISSING
 0000213A  00 08 3F 4D 49	DB 0, 8, '?MISSING'
	   53 53 49 4E 47
 00002144			do_?MISSING:
				; POP EAX
				NEXTC
 00002144  8B 07	     1	   MOV EAX, [EDI]
 00002146  83 C7 04	     1	   ADD EDI, 4
 00002149  FF E0	     1	   JMP EAX 
				;
 0000214B			_BYE:       ; VERIFIED
 0000214B  00002132 R		DD _QMISSING
 0000214F  00002158 R		DD BYE
 00002153  00 03 42 59 45	DB 0, 3, 'BYE'
 00002158			BYE:
 00002158  C7 05 00000948 R	MOV BYEFLAG, 0H 
	   00000000
				NEXTC
 00002162  8B 07	     1	   MOV EAX, [EDI]
 00002164  83 C7 04	     1	   ADD EDI, 4
 00002167  FF E0	     1	   JMP EAX 
				;
 00002169			_QBYE:      ; VERIFIED
 00002169  0000214B R		DD _BYE
 0000216D  00002177 R		DD QBYE
 00002171  00 04 3F 42 59	DB 0, 4, '?BYE'
	   45
 00002177			QBYE:
 00002177  FF 35 00000948 R	PUSH BYEFLAG 
				NEXTC
 0000217D  8B 07	     1	   MOV EAX, [EDI]
 0000217F  83 C7 04	     1	   ADD EDI, 4
 00002182  FF E0	     1	   JMP EAX 
				;
 00002184			_QUIT:      ; VERIFIED
 00002184  00002169 R		DD _QBYE 
 00002188  00002192 R		DD QUIT
 0000218C  00 04 51 55 49	DB 0, 4, 'QUIT'
	   54
 00002192			QUIT:
 00002192  8D 05 00000AD7 R	lea eax, Msg6
 00002198  50			push eax
 00002199  E8 00000000 E	call StdOut
 0000219E  E9 0000011E		JMP do_QSTACK
				NEXTC
 000021A3  8B 07	     1	   MOV EAX, [EDI]
 000021A5  83 C7 04	     1	   ADD EDI, 4
 000021A8  FF E0	     1	   JMP EAX 
				;
				; invoke atodw, ADDR MyDecimalString                ; CONVERT ASCII STRING TO NUMBER (EAX)
				; invoke ustr2dw, ustr2dw proc pszString:DWORD      ; Convert string to unsigned DWORD (EAX)
				;
 000021AA			_dwtoa:  ; ( N, ADDR -- )  CONVERT DWORD NUMBER TO ASCII STRING     VERIFIED
 000021AA  00002184 R		DD _QUIT
 000021AE  000021B9 R		DD do_dwtoa
 000021B2  00 05 44 57 54	DB 0, 5, 'DWTOA'
	   4F 41
 000021B9			do_dwtoa:
 000021B9  E8 00000000 E	call dwtoa
				NEXTC
 000021BE  8B 07	     1	   MOV EAX, [EDI]
 000021C0  83 C7 04	     1	   ADD EDI, 4
 000021C3  FF E0	     1	   JMP EAX 
				; 
 000021C5			_udw2str:  ; ( N, ADDR -- )   Convert unsigned DWORD to string
 000021C5  000021AA R		DD _dwtoa
 000021C9  000021D6 R		DD do_udw2str
 000021CD  00 07 55 44 57	DB 0, 7, 'UDW2STR'
	   32 53 54 52
 000021D6			do_udw2str:
 000021D6  E8 00000000 E	call udw2str
				NEXTC
 000021DB  8B 07	     1	   MOV EAX, [EDI]
 000021DD  83 C7 04	     1	   ADD EDI, 4
 000021E0  FF E0	     1	   JMP EAX 
				;
 000021E2			_stdout: ; ( ADDR LEN -- )  NOTE: SAME AS 'TYPE'    VERIFIED
 000021E2  000021C5 R		DD _udw2str
 000021E6  000021F2 R		DD do_STDOUT
 000021EA  00 06 53 54 44	DB 0, 6, 'STDOUT'
	   4F 55 54
 000021F2			do_STDOUT: 
 000021F2  83 C4 04		ADD ESP, 4      ; IGNORE LENGTH 
 000021F5  E8 00000000 E	call StdOut
				NEXTC
 000021FA  8B 07	     1	   MOV EAX, [EDI]
 000021FC  83 C7 04	     1	   ADD EDI, 4
 000021FF  FF E0	     1	   JMP EAX 
				;
 00002201			_TYPE: ; ( ADDR LEN -- )        VERIFIED
 00002201  000021E2 R		DD _stdout
 00002205  0000220F R		DD do_TYPE
 00002209  00 04 54 59 50	DB 0, 4, 'TYPE'
	   45
 0000220F			do_TYPE:
 0000220F  59			POP ECX         ; GET LENGTH BYTE
 00002210  8B 04 24		MOV EAX, [ESP]  ; COPY TOP OF STACK TO EAX
 00002213  03 C1		ADD EAX, ECX
 00002215  C6 00 00		MOV BYTE PTR [EAX], 0   ; MUST HAVE A 0H AT END OF OUTPUT
 00002218  E8 00000000 E	call StdOut
				NEXTC
 0000221D  8B 07	     1	   MOV EAX, [EDI]
 0000221F  83 C7 04	     1	   ADD EDI, 4
 00002222  FF E0	     1	   JMP EAX 
				;
 00002224			_ms:            ; ( -- N ) GET SYSTEM TIME IN MILLISECONDS  VERIFIED
 00002224  00002201 R		DD _TYPE
 00002228  00002231 R		DD do_MS
 0000222C  00 03 4D 53 40	DB 0, 3, 'MS@'
 00002231			do_MS:
 00002231  8D 1D 00000918 R	LEA EBX, _SYSTIME
 00002237  53			push EBX
 00002238  E8 00000000 E	CALL GetLocalTime
 0000223D  8D 1D 00000918 R	LEA EBX, _SYSTIME
 00002243  B9 0000003C		MOV ECX, 60
 00002248  83 C3 08		ADD EBX, 8
 0000224B  B8 00000000		MOV EAX, 0
 00002250  66| 03 03		ADD AX, WORD PTR [EBX]  ; LOAD HOURS
 00002253  83 C3 02		ADD EBX, 2
 00002256  F7 E1		MUL ECX         ; CONVERT HOURS TO MINUTES
 00002258  66| 03 03		ADD AX, WORD PTR [EBX]  ; LOAD MINUTES
 0000225B  83 C3 02		ADD EBX, 2
 0000225E  F7 E1		MUL ECX         ; CONVERT MINUTES TO SECONDS
 00002260  66| 03 03		ADD AX, WORD PTR [EBX]  ; LOAD SECONDS
 00002263  83 C3 02		ADD EBX, 2
 00002266  B9 000003E8		MOV ECX, 1000
 0000226B  F7 E1		MUL ECX         ; CONVERT SECONDS TO MILLISECONDS
 0000226D  66| 03 03		ADD AX, WORD PTR [EBX]  ; LOAD MILLISCONDS
 00002270  50			PUSH EAX
				NEXTC
 00002271  8B 07	     1	   MOV EAX, [EDI]
 00002273  83 C7 04	     1	   ADD EDI, 4
 00002276  FF E0	     1	   JMP EAX 
				;
 00002278			_WDCOUNT:       ;  COUNT THE WORDS IN THE DICTIONARY       VERIFIED
 00002278  00002224 R		DD _ms
 0000227C  00002289 R		DD do_WDCOUNT
 00002280  00 07 57 44 43	DB 0, 7, 'WDCOUNT'
	   4F 55 4E 54
 00002289			do_WDCOUNT:
 00002289  60			PUSHAD
 0000228A  8B 1D 00000980 R	MOV EBX, LATEST
 00002290  B9 00000000		MOV ECX, 0
 00002295			@WDC1:
 00002295  41			INC ECX
 00002296  FF 33		PUSH [EBX]
 00002298  8B 04 24		MOV EAX, [ESP]
 0000229B  83 F8 00		CMP EAX, 0
 0000229E  5B			POP EBX
 0000229F  74 02		JZ @WDC2
 000022A1  EB F2		JMP @WDC1
 000022A3			@WDC2:
 000022A3  89 0D 0000095C R	MOV DCW, ECX
 000022A9  61			POPAD
				NEXTC
 000022AA  8B 07	     1	   MOV EAX, [EDI]
 000022AC  83 C7 04	     1	   ADD EDI, 4
 000022AF  FF E0	     1	   JMP EAX 
				;
 000022B1			_QSTACK:                ; QUERY STACK STATUS   VERIFIED 231201
 000022B1  00002278 R		DD _WDCOUNT
 000022B5  000022C1 R		DD do_QSTACK
 000022B9  00 06 3F 53 54	DB 0, 6, '?STACK'
	   41 43 4B
 000022C1			do_QSTACK:
 000022C1  3B 25 000009D0 R	CMP ESP, S0
 000022C7  7F 19		JG @QS1
 000022C9  3B 25 000005D1 R	CMP ESP, S0-1023
 000022CF  7C 22		JL @QS2
 000022D1  C7 05 000009D4 R	MOV STACKERROR, 0           ; INBOUNDS
	   00000000
				NEXTC
 000022DB  8B 07	     1	   MOV EAX, [EDI]
 000022DD  83 C7 04	     1	   ADD EDI, 4
 000022E0  FF E0	     1	   JMP EAX 
 000022E2			@QS1:
 000022E2  C7 05 000009D4 R	MOV STACKERROR, -4         ; stack underflow
	   FFFFFFFC
				NEXTC
 000022EC  8B 07	     1	   MOV EAX, [EDI]
 000022EE  83 C7 04	     1	   ADD EDI, 4
 000022F1  FF E0	     1	   JMP EAX 
 000022F3			@QS2:
 000022F3  C7 05 000009D4 R	MOV STACKERROR, -3         ; stack overflow
	   FFFFFFFD
				NEXTC
 000022FD  8B 07	     1	   MOV EAX, [EDI]
 000022FF  83 C7 04	     1	   ADD EDI, 4
 00002302  FF E0	     1	   JMP EAX 
				;
 00002304			_GCFA:  ; ( -- CFA)  PUT THE CFA ON THE STACK OF THE NEXT EXECUTABLE WORD    VERIFIED 231201
 00002304  000022B1 R		DD _QSTACK
 00002308  00002312 R		DD do_GCFA
 0000230C  00 04 54 49 43	DB 0, 4, 'TICK'
	   4B
 00002312			do_GCFA:
 00002312  8B 07		MOV EAX, [EDI]
 00002314  50			PUSH EAX
 00002315  83 C7 04		ADD EDI, 4
				NEXTC
 00002318  8B 07	     1	   MOV EAX, [EDI]
 0000231A  83 C7 04	     1	   ADD EDI, 4
 0000231D  FF E0	     1	   JMP EAX 
				;
 0000231F			 _BTOH:   ; ( BYTE - 'XX')       VERIFIED 231207
 0000231F  00002304 R		 DD _GCFA
 00002323  0000232D R		 DD do_BTOH
 00002327  00 04 42 54 4F	 DB 0, 4, 'BTOH'
	   48
 0000232D			 do_BTOH:
 0000232D  58			 POP EAX            ;   BYTE TO CONVERT IN AX
 0000232E  57			 PUSH EDI
 0000232F  8D 3D 00001B96 R	 LEA EDI, PAD
 00002335  BA 00000000		 MOV EDX, 0
 0000233A  89 17		 MOV [EDI], EDX
 0000233C  B9 00000002		 MOV ECX, 2
 00002341  C1 C0 18		 ROL EAX, 24
 00002344			@@loopB2H:
 00002344  C1 C0 04		 rol    Eax, 4        ; rotate the high 4 bits to the bottom
 00002347  8B D0		 mov    edx, eax
 00002349  83 E2 0F		 and    edx, 0fH      ; and isolate 4-bit integer in EDX
 0000234C  8A 92 00000C48 R	 MOV    DL, byte PTR [HEX_TABLE + edx]
 00002352  88 17		 mov    [edi], DL     ; copy a character from the lookup table
 00002354  47			 inc    edi           ; loop forward in the output buffer
 00002355  49			 dec    ecx
 00002356  75 EC		 jnz    @@loopB2H        ; }while(--ecx)
 00002358  5F			 POP EDI
				 NEXTC
 00002359  8B 07	     1	   MOV EAX, [EDI]
 0000235B  83 C7 04	     1	   ADD EDI, 4
 0000235E  FF E0	     1	   JMP EAX 
				;
 00002360			_BEXT:      ; ( N, -- C,C,C,C)  EXTRACT INDIVIDUAL BYTES FROM WORD  VERIFIED 231207
 00002360  0000231F R		 DD _BTOH
 00002364  0000236E R		 DD do_BEXT
 00002368  00 04 42 45 58	 DB 0, 4, 'BEXT'
	   54
 0000236E			 do_BEXT:
 0000236E  58			 POP EAX
 0000236F  8B D8		 MOV EBX, EAX
 00002371  25 FF000000		 AND EAX, 0FF000000H
 00002376  C1 C8 18		 ROR EAX, 24
 00002379  50			 PUSH EAX
 0000237A  8B C3		 MOV EAX, EBX
 0000237C  25 00FF0000		 AND EAX, 000FF0000H
 00002381  C1 C8 10		 ROR EAX, 16
 00002384  50			 PUSH EAX
 00002385  8B C3		 MOV EAX, EBX
 00002387  25 0000FF00		 AND EAX, 00000FF00H
 0000238C  C1 C8 08		 ROR EAX, 8
 0000238F  50			 PUSH EAX
 00002390  8B C3		 MOV EAX, EBX
 00002392  25 000000FF		 AND EAX, 0000000FFH
 00002397  50			 PUSH EAX
				 NEXTC
 00002398  8B 07	     1	   MOV EAX, [EDI]
 0000239A  83 C7 04	     1	   ADD EDI, 4
 0000239D  FF E0	     1	   JMP EAX 
				;
 0000239F			_CMAX:      ; ( C -- C ) CHECK IF C < 32 IF TRUE RETURN 46 '.'  VERIFIED 231208 
 0000239F  00002360 R		DD _BEXT
 000023A3  000023AD R		DD do_CMAX
 000023A7  00 04 43 4D 41	DB 0, 4, 'CMAX'
	   58
 000023AD			do_CMAX:
 000023AD  8B 04 24		MOV EAX, [ESP]
 000023B0  B9 0000001F		MOV ECX, 31
 000023B5  2B C1		SUB EAX, ECX
 000023B7  7F 08		JG CMAX0
 000023B9  B8 0000002E		MOV EAX, 46
 000023BE  89 04 24		MOV [ESP], EAX
 000023C1			CMAX0:
				NEXTC
 000023C1  8B 07	     1	   MOV EAX, [EDI]
 000023C3  83 C7 04	     1	   ADD EDI, 4
 000023C6  FF E0	     1	   JMP EAX 
				;
				;   --------------------------- File Control Words -------------------------------------
				; R/O = 80000000H   W/O = 40000000H  R/W = C0000000H (-40000000H)
				;     -2147483648         1073741824     -1073741824
				;
 000023C8			_FILEOPEN:         ; (ADDR, LEN, MODE -- IOR, F )        VERIFIED 231214
 000023C8  0000239F R		DD _CMAX
 000023CC  000023DB R		DD do_FILEOPEN
 000023D0  00 09 4F 50 45	DB 0, 9, 'OPEN-FILE'
	   4E 2D 46 49 4C
	   45
 000023DB			do_FILEOPEN:
 000023DB  58			POP EAX ; MODE
 000023DC  5B			POP EBX ; LENGTH - NOT USED
 000023DD  8F 05 00000978 R	POP HLD ; ADDR
 000023E3  6A 00		PUSH 0                  ;  
 000023E5  68 80000000		PUSH 80000000H          ;  128 = NORMAL
 000023EA  6A 03		PUSH 3                  ;  DISPOSITION 3 = OPEN ONLY IF EXIST
 000023EC  6A 00		PUSH 0                  ;
 000023EE  6A 03		PUSH 3                  ;  SHARE MODES 1 READ 2 WRITE 3 BOTH
 000023F0  50			PUSH EAX                ;  WRITE ONLY MODE R/O, W/O, R/W 
 000023F1  FF 35 00000978 R	PUSH HLD                ;
 000023F7  E8 00000000 E	call CreateFileA 
 000023FC  50			PUSH EAX
				invoke GetLastError
 000023FD  E8 00000000 E   *	    call   GetLastError
 00002402  50			push eax
				NEXTC
 00002403  8B 07	     1	   MOV EAX, [EDI]
 00002405  83 C7 04	     1	   ADD EDI, 4
 00002408  FF E0	     1	   JMP EAX 
				;
 0000240A			_FILECLOSE:         ; ( HDL -- FLG )        VERIFIED 231212
 0000240A  000023C8 R		DD _FILEOPEN
 0000240E  0000241E R		DD do_FILECLOSE
 00002412  00 0A 43 4C 4F	DB 0, 10, 'CLOSE-FILE'
	   53 45 2D 46 49
	   4C 45
 0000241E			do_FILECLOSE:
 0000241E  E8 00000000 E	CALL CloseHandle
				; PUSH EAX
				invoke GetLastError
 00002423  E8 00000000 E   *	    call   GetLastError
 00002428  50			push eax
				NEXTC
 00002429  8B 07	     1	   MOV EAX, [EDI]
 0000242B  83 C7 04	     1	   ADD EDI, 4
 0000242E  FF E0	     1	   JMP EAX 
				;
 00002430			_FILECREATE:          ; (ADDR     - HLD FLG)    VERIFIED 231212
 00002430  0000240A R		DD _FILECLOSE
 00002434  00002445 R		DD do_FILECREATE
 00002438  00 0B 43 52 45	DB 0, 11, 'CREATE-FILE'
	   41 54 45 2D 46
	   49 4C 45
 00002445			do_FILECREATE:       
 00002445  8F 05 00000978 R	POP HLD
 0000244B  6A 00		PUSH 0                  ;  
 0000244D  68 80000000		PUSH 80000000H          ;  128 = NORMAL
 00002452  6A 02		PUSH 2                  ;
 00002454  6A 00		PUSH 0                  ;
 00002456  6A 03		PUSH 3                  ;  SHARE MODES 1 READ 2 WRITE 3 BOTH
 00002458  68 40000000		PUSH 40000000H          ;  WRITE ONLY MODE 
 0000245D  FF 35 00000978 R	PUSH HLD                ;
				; HLD - FILENAME PTR, ACCESS, SHARE, NULL, 2 - CREATE, 128 - NORMAL, HANDLE
 00002463  E8 00000000 E	call CreateFileA 
 00002468  50			PUSH EAX
 00002469  E8 00000000 E	CALL GetLastError
 0000246E  50			push eax
				NEXTC
 0000246F  8B 07	     1	   MOV EAX, [EDI]
 00002471  83 C7 04	     1	   ADD EDI, 4
 00002474  FF E0	     1	   JMP EAX 
				;
 00002476			_GetFileSize:   ; ( FileID -- UD F )        VERIFIED 231213
 00002476  00002430 R		DD _FILECREATE
 0000247A  00002489 R		DD do_GFS
 0000247E  00 09 46 49 4C	DB 0, 9, 'FILE-SIZE'
	   45 2D 53 49 5A
	   45
 00002489			do_GFS:
 00002489  8D 05 000009DC R	LEA EAX, TV1
 0000248F  5B			POP EBX
 00002490  50			PUSH EAX
 00002491  53			PUSH EBX
 00002492  E8 00000000 E	CALL GetFileSize
 00002497  50			PUSH EAX
				NEXTC
 00002498  8B 07	     1	   MOV EAX, [EDI]
 0000249A  83 C7 04	     1	   ADD EDI, 4
 0000249D  FF E0	     1	   JMP EAX 
				;
 0000249F			_FPARMSRW:  ;    ( addr len fileid -- 0 0 ptr len addr fileid ) VERIFIED 231214
				;                 parms for read/write
 0000249F  00002476 R		DD _GetFileSize
 000024A3  000024B1 R		DD do_FPARMSRW
 000024A7  00 09 46 50 41	DB 0, 9, 'FPARMSRW'
	   52 4D 53 52 57
 000024B1			do_FPARMSRW:
 000024B1  5E			   POP     ESI                     ; RETURN VALUE
 000024B2  5B			   POP     EBX                     ; HANDLE
 000024B3  58			   POP EAX                         ; LENGTH
 000024B4  59			   POP ECX                         ; ADDR
 000024B5  6A 00		   PUSH 0
 000024B7  54			   PUSH ESP
 000024B8  50			   PUSH EAX
 000024B9  51			   PUSH ECX
 000024BA  53			   PUSH    EBX
 000024BB  56			   PUSH    ESI
 000024BC  C3			   RET ; NEXTC
				;
 000024BD			_READFILE:          ; (  BUFFER, #BYTES, HNDL  -- BREAD, ior )  ior = 0 = success     VERIFIED 231214
 000024BD  0000249F R		DD _FPARMSRW
 000024C1  000024D0 R		DD do_READFILE
 000024C5  00 09 52 45 41	DB 0, 9, 'READ-FILE'
	   44 2D 46 49 4C
	   45
 000024D0			do_READFILE:
 000024D0  E8 FFFFFFDC		CALL do_FPARMSRW
 000024D5  E8 00000000 E	CALL ReadFile
 000024DA  8B 44 24 FC		MOV EAX, [ESP-4]
 000024DE  50			PUSH EAX
 000024DF  E8 00000000 E	CALL GetLastError
 000024E4  50			PUSH EAX
				NEXTC
 000024E5  8B 07	     1	   MOV EAX, [EDI]
 000024E7  83 C7 04	     1	   ADD EDI, 4
 000024EA  FF E0	     1	   JMP EAX 
				;
 000024EC			_WRITEFILE:          ; (  BUFFER, #BYTER, HNDL  -- len ior )  ior = 0 = success
 000024EC  000024BD R		DD _READFILE
 000024F0  00002500 R		DD do_WRITEFILE
 000024F4  00 0A 57 52 49	DB 0, 10, 'WRITE-FILE'
	   54 45 2D 46 49
	   4C 45
 00002500			do_WRITEFILE:
 00002500  E8 FFFFFFAC		CALL do_FPARMSRW
 00002505  E8 00000000 E	CALL WriteFile
 0000250A  E8 00000000 E	CALL GetLastError
 0000250F  50			PUSH EAX
				NEXTC
 00002510  8B 07	     1	   MOV EAX, [EDI]
 00002512  83 C7 04	     1	   ADD EDI, 4
 00002515  FF E0	     1	   JMP EAX 
				;
 00002517			_fileposition:             ; ( fileid -- len-ud ior ) 0 0 rot FILE_CURRENT SETFP  VERIFIED 231216
 00002517  000024EC R		DD _WRITEFILE              ; RETURN FILE POSITION
 0000251B  0000252E R		DD do_FILEPOSITION
 0000251F  00 0D 46 49 4C	DB 0, 13, 'FILE-POSITION'
	   45 2D 50 4F 53
	   49 54 49 4F 4E
 0000252E			do_FILEPOSITION:
 0000252E  58			POP EAX     ; FILE ID
 0000252F  6A 01		PUSH 1      ; START POINT
 00002531  6A 00		PUSH 0      ; NULL
 00002533  6A 00		PUSH 0      ; # BYTES TO MOVE
 00002535  50			PUSH EAX
 00002536  E8 00000000 E	Call SetFilePointer  
 0000253B  50			PUSH EAX
 0000253C  E8 00000000 E	CALL GetLastError 
 00002541  50			PUSH EAX
				NEXTC
 00002542  8B 07	     1	   MOV EAX, [EDI]
 00002544  83 C7 04	     1	   ADD EDI, 4
 00002547  FF E0	     1	   JMP EAX 
				;
 00002549			_repositionfile:            ; ( len-ud fileid -- ior ) ; ior - 0 = success  FILE_BEGIN SetFP nip nip 
 00002549  00002517 R		DD _fileposition            ; VERIFIED 231216
 0000254D  00002562 R		DD do_REPOSITIONFILE
 00002551  00 0F 52 45 50	DB 0, 15, 'REPOSITION-FILE'
	   4F 53 49 54 49
	   4F 4E 2D 46 49
	   4C 45
 00002562			do_REPOSITIONFILE:
 00002562  58			POP EAX     ; FILE ID
 00002563  5B			POP EBX     ; # BYTES TO MOVE
 00002564  6A 00		PUSH 0      ; START POINT
 00002566  6A 00		PUSH 0      ; NULL
 00002568  53			PUSH EBX     
 00002569  50			PUSH EAX
 0000256A  E8 00000000 E	Call SetFilePointer  
 0000256F  50			PUSH EAX
 00002570  E8 00000000 E	CALL GetLastError 
 00002575  50			PUSH EAX
				NEXTC
 00002576  8B 07	     1	   MOV EAX, [EDI]
 00002578  83 C7 04	     1	   ADD EDI, 4
 0000257B  FF E0	     1	   JMP EAX 
				;
				;  -------------------- Memory Management functions -------------------------- 
				;
 0000257D			_MALLOC:
 0000257D  00002549 R		DD _repositionfile
 00002581  0000258D R		DD do_MALLOC
 00002585  00 06 4D 41 4C	DB 0, 6, 'MALLOC'
	   4C 4F 43
 0000258D			do_MALLOC:

				NEXTC
 0000258D  8B 07	     1	   MOV EAX, [EDI]
 0000258F  83 C7 04	     1	   ADD EDI, 4
 00002592  FF E0	     1	   JMP EAX 
				;
 00002594			_ALLOCATE:  ; ( N -- ADDR FL )      ; VERIFIED
 00002594  0000257D R		DD _MALLOC
 00002598  000025A6 R		DD do_ALLOCATE
 0000259C  00 08 41 4C 4C	DB 0, 8, 'ALLOCATE'
	   4F 43 41 54 45
 000025A6			do_ALLOCATE:
 000025A6  6A 00		push 0
 000025A8  E8 00000000 E	call GlobalAlloc           ; GMEM_MOVEABLE=0 or GMEM_ZEROINIT=2
 000025AD  A3 0000092C R	mov _hMemory,eax
				.if eax!=0
 000025B2  0B C0	   *	    or	eax, eax
 000025B4  74 1E	   *	    je     @C0001
 000025B6  FF 35 0000092C R	push _hMemory
 000025BC  E8 00000000 E	call GlobalLock
 000025C1  A3 000009A8 R	mov pMem,eax
 000025C6  FF 35 000009A8 R	PUSH pMem
 000025CC  E8 00000000 E	CALL GetLastError
 000025D1  50			PUSH EAX
				.else
 000025D2  EB 0E	   *	    jmp    @C0003
 000025D4		   *@C0001:
 000025D4  8D 05 00000B94 R	lea eax, Msg18
 000025DA  50			push eax
 000025DB  E8 00000000 E	call StdOut
 000025E0  6A 00		PUSH 0
				.endif
 000025E2		   *@C0003:
				NEXTC
 000025E2  8B 07	     1	   MOV EAX, [EDI]
 000025E4  83 C7 04	     1	   ADD EDI, 4
 000025E7  FF E0	     1	   JMP EAX 
				;
 000025E9			_free:          ; ( pMem -- ) release global memory allocated  VERIFIED 231201
 000025E9  00002594 R		DD _ALLOCATE 
 000025ED  000025F7 R		DD do_FREE
 000025F1  00 04 46 52 45	DB 0, 4, 'FREE'
	   45
 000025F7			do_FREE:
 000025F7  8B 04 24		mov eax, [esp]
 000025FA  50			push eax
 000025FB  E8 00000000 E	call GlobalUnlock
 00002600  E8 00000000 E	call GlobalFree
				NEXTC
 00002605  8B 07	     1	   MOV EAX, [EDI]
 00002607  83 C7 04	     1	   ADD EDI, 4
 0000260A  FF E0	     1	   JMP EAX 
				;
 0000260C			_ALIGN:   ; ( ADDR -  ADDR)     VERIFIED 231222
 0000260C  000025E9 R		DD _free
 00002610  0000261B R		DD do_ALIGN
 00002614  00 05 41 4C 49	DB 0, 5, 'ALIGN'
	   47 4E
 0000261B			do_ALIGN:
 0000261B  58			POP EAX
 0000261C  83 C0 03		ADD EAX, 3
 0000261F  83 E0 FC		AND EAX, -4
 00002622  50			PUSH EAX
				NEXTC
 00002623  8B 07	     1	   MOV EAX, [EDI]
 00002625  83 C7 04	     1	   ADD EDI, 4
 00002628  FF E0	     1	   JMP EAX 
				;
				;   -------------------- End of CODE Definitions ---------------------------
 0000262A			EOCD:
				;   -------------------- Begining of Colon Definitions ---------------------
				;
 0000262A			_DECIMAL: ; 10 BASE !       VERIFIED
 0000262A  0000260C R		DD _ALIGN
 0000262E  0000263B R		DD do_DECIMAL
 00002632  00 07 44 45 43	DB 0, 7, 'DECIMAL'
	   49 4D 41 4C
 0000263B			do_DECIMAL:
 0000263B  68 00002645 R	PUSH $ + 10
 00002640  E9 FFFFEFA5		JMP do_DOCOL 
 00002645  00000C07 R		DD do_LIT, 10, do_BASE, do_STORE, do_SEMI
	   0000000A
	   0000014E R
	   00000938 R
	   00000862 R
				;
 00002659			HEX:   ;    16 BASE !       VERIFIED
 00002659  0000262A R		DD _DECIMAL
 0000265D  00002666 R		DD do_HEX
 00002661  00 03 48 45 58	DB 0, 3, 'HEX'
 00002666			do_HEX:
 00002666  68 00002670 R	PUSH $ + 10
 0000266B  E9 FFFFEF7A		JMP do_DOCOL 
 00002670  00000C07 R		DD do_LIT, 16, do_BASE, do_STORE, do_SEMI
	   00000010
	   0000014E R
	   00000938 R
	   00000862 R
				;
 00002684			_BINARY:     ;    2 BASE !       VERIFIED
 00002684  00002659 R		DD HEX
 00002688  00002694 R		DD do_BINARY
 0000268C  00 06 42 49 4E	DB 0, 6, 'BINARY'
	   41 52 59
 00002694			do_BINARY:
 00002694  68 0000269E R	PUSH $ + 10
 00002699  E9 FFFFEF4C		JMP do_DOCOL 
 0000269E  00000C07 R		DD do_LIT, 2, do_BASE, do_STORE, do_SEMI
	   00000002
	   0000014E R
	   00000938 R
	   00000862 R
				;
 000026B2			_OCTAL: ;    8 BASE !       VERIFIED
 000026B2  00002684 R		DD _BINARY
 000026B6  000026C1 R		DD do_OCTAL
 000026BA  00 05 4F 43 54	DB 0, 5, 'OCTAL'
	   41 4C
 000026C1			do_OCTAL:
 000026C1  68 000026CB R	PUSH $ + 10
 000026C6  E9 FFFFEF1F		JMP do_DOCOL 
 000026CB  00000C07 R		DD do_LIT, 8, do_BASE, do_STORE, do_SEMI
	   00000008
	   0000014E R
	   00000938 R
	   00000862 R
				;
 000026DF			_HEADER:        ; VERIFIED 231223
 000026DF  000026B2 R		DD _OCTAL
 000026E3  000026EF R		DD do_HEADER
 000026E7  00 06 48 45 41	DB 0, 6, 'HEADER'
	   44 45 52
 000026EF			do_HEADER:
 000026EF  68 000026F9 R	PUSH $ + 10
 000026F4  E9 FFFFEEF1		JMP do_DOCOL 
 000026F9  00000132 R		DD do_STATE, do_FETCH, do_IF@, do_S_ADR, do_FETCH, do_ELSE@, TIB, do_THEN@
	   00000922 R
	   00001F4C R
	   000004A4 R
	   00000922 R
	   00001F88 R
	   00001CA3 R
	   00001FAC R
 00002719  00000C07 R		DD do_LIT, 32, do_WORD, do_COUNT 
	   00000020
	   0000185D R
	   000013AB R
 00002729  00000F9A R		DD do_2DUP, do_UPPERCASE, do_DROP
	   00001AC9 R
	   00000C22 R
 00002735  00001D28 R		DD do_NEWHEADER;  _HEADER_  ; Same as (HEADER)
 00002739  00000862 R		DD do_SEMI
				;
 0000273D			_PRINT: ; ( n -- )   display as signed single       VERIFIED
 0000273D  000026DF R		DD _HEADER
 00002741  00002748 R		DD do_PRINT
 00002745  00 01 2E		DB 0, 1, '.'
 00002748			do_PRINT:
 00002748  68 00002752 R	PUSH $ + 10
 0000274D  E9 FFFFEE98		JMP do_DOCOL 
 00002752  00001B96 R		DD PAD, do_SWAP, do_dwtoa             ; CONVERT n TO ASCII
	   00000C50 R
	   000021B9 R
 0000275E  00001B96 R		DD PAD, do_PUSH0, do_STDOUT  ; DISPLAY DATA
	   000008D6 R
	   000021F2 R
 0000276A  00000862 R		DD do_SEMI
				;
 0000276E			_EMIT: ; ( CHAR -- ) Display one character      VERIFIED
 0000276E  0000273D R		dd _PRINT
 00002772  0000277C R		DD do_EMIT
 00002776  00 04 45 4D 49	DB 0, 4, 'EMIT'
	   54
 0000277C			do_EMIT:
 0000277C  58			POP EAX
 0000277D  A2 00001B96 R	MOV BYTE PTR PAD, BYTE PTR AL
 00002782  C6 05 00001B97 R	MOV BYTE PTR PAD+1, 0
	   00
 00002789  8D 05 00001B96 R	LEA EAX, PAD
 0000278F  50			PUSH EAX
 00002790  6A 01		PUSH 1
 00002792  68 0000279C R	push $ + 10
 00002797  E9 FFFFEE4E		JMP do_DOCOL
 0000279C  0000220F R		DD do_TYPE  
 000027A0  00000862 R		DD do_SEMI
				;
 000027A4			_qmark:                  ;  ( addr -- ) \ display single stored at address
 000027A4  0000276E R		DD _EMIT
 000027A8  000027AF R		DD do_QMARK
 000027AC  00 01 3F		DB 0, 1, '?'
 000027AF			do_QMARK:  ;  @ . ;
 000027AF  68 000027B9 R	PUSH $ + 10
 000027B4  E9 FFFFEE31		JMP do_DOCOL
 000027B9  00000922 R		DD do_FETCH, do_PRINT
	   00002748 R
 000027C1  00000862 R		DD do_SEMI
				;
 000027C5			_COMMA: ; , ( n -- )  ( compile cell at HERE, increment DP)
 000027C5  000027A4 R		DD _qmark
 000027C9  000027D0 R		DD do_COMMA
 000027CD  00 01 2C		DB 0, 1, ','
 000027D0			do_COMMA:  ; HERE ! CELL DP +!  ;
 000027D0  68 000027DA R	PUSH $ + 10
 000027D5  E9 FFFFEE10		JMP do_DOCOL
 000027DA  00001AA8 R		DD do_HERE, do_STORE, do_CELL, do_DPR, do_PLUSSTORE 
	   00000938 R
	   00000D5C R
	   000001BE R
	   0000094F R
 000027EE  00000862 R		DD do_SEMI
				;
 000027F2			_WCOMMA: ; : W, ( n -- )  ( compile word at HERE, increment DP)
 000027F2  000027C5 R		DD _COMMA
 000027F6  000027FE R		DD do_WCOMMA
 000027FA  00 02 57 2C		DB 0, 2, 'W,'
 000027FE			do_WCOMMA:
 000027FE  68 00002808 R	PUSH $ + 10
 00002803  E9 FFFFEDE2		JMP do_DOCOL
 00002808  00001AA8 R		DD do_HERE  ; HERE W! 2 DP +!  ;
 0000280C  000009F5 R		DD do_WSTORE, do_LIT, 2, do_DPR, do_PLUSSTORE
	   00000C07 R
	   00000002
	   000001BE R
	   0000094F R
 00002820  00000862 R		DD do_SEMI
				;
 00002824			_CCOMMA:     ; C,  ( n -- )  ( compile byte at HERE, increment DP)
 00002824  000027F2 R		DD _WCOMMA
 00002828  00002830 R		DD do_CCOMMA
 0000282C  00 02 43 2C		DB 0, 2, 'C,'
 00002830			do_CCOMMA:
 00002830  68 0000283A R	PUSH $ + 10
 00002835  E9 FFFFEDB0		JMP do_DOCOL                
 0000283A  00001AA8 R		DD do_HERE  ; HERE C! DP INCR ;
 0000283E  00000995 R		DD do_CSTORE, do_DPR, do_INCR
	   000001BE R
	   00001528 R
 0000284A  00000862 R		DD do_SEMI
				;
 0000284E			_CREATE:        ; ( "<spaces>name" -- )    Create a definition for name.   VERIFIED 231201
 0000284E  00002824 R		DD _CCOMMA
 00002852  0000285E R		DD do_CREATE
 00002856  00 06 43 52 45	DB 0, 6, 'CREATE'
	   41 54 45
 0000285E			do_CREATE:
 0000285E  68 00002868 R	PUSH $ + 10
 00002863  E9 FFFFED82		JMP do_DOCOL 
 00002868  000026EF R		DD do_HEADER       ;HEADER DOVAR COMPILE, ;
 0000286C  000028DF R		DD do_VARHEAD      ;DD do_DOVAR do_COMPILECOMMA
 00002870  000008D6 R		DD do_PUSH0, do_COMMA
	   000027D0 R
 00002878  00000862 R		DD do_SEMI
				;
 0000287C			_CONHEAD:       ; COMPLETE HEADER FOR CONSTANT  VERIFIED 231201
 0000287C  0000284E R		DD _CREATE
 00002880  0000288D R		DD do_CONHEAD
 00002884  00 07 43 4F 4E	DB 0, 7, 'CONHEAD' 
	   48 45 41 44
 0000288D			do_CONHEAD:
 0000288D  A1 000009A0 R	MOV EAX, NFA
 00002892  83 E8 05		SUB EAX, 5 
 00002895  C7 00 00001665 R	MOV [EAX], do_DOCON
				NEXTC
 0000289B  8B 07	     1	   MOV EAX, [EDI]
 0000289D  83 C7 04	     1	   ADD EDI, 4
 000028A0  FF E0	     1	   JMP EAX 
				;
 000028A2			_CONSTANT:  ; ( n "name" -- )    create a constant (unchangeable) value    ; VERIFIED 231223
 000028A2  0000287C R		DD _CONHEAD
 000028A6  000028B4 R		DD do_CONSTANT
 000028AA  01 08 43 4F 4E	DB 1, 8, 'CONSTANT'
	   53 54 41 4E 54
 000028B4			do_CONSTANT: 
 000028B4  68 000028BE R	PUSH $ + 10
 000028B9  E9 FFFFED2C		JMP do_DOCOL
 000028BE  000026EF R		DD do_HEADER      ; HEADER DOCON COMPILE, , ;
 000028C2  0000288D R		DD do_CONHEAD     ; LEAVE ADDRESS OF DOCON
 000028C6  000027D0 R		DD do_COMMA       ; LEAVE VALUE
 000028CA  00000862 R		DD do_SEMI
				;
 000028CE			_VARHEAD:       ; COMPLETE HEADER FOR VARIABLE  VERIFIED 231201
 000028CE  000028A2 R		DD _CONSTANT
 000028D2  000028DF R		DD do_VARHEAD
 000028D6  00 07 56 41 52	DB 0, 7, 'VARHEAD' 
	   48 45 41 44
 000028DF			do_VARHEAD:
 000028DF  A1 000009A0 R	MOV EAX, NFA
 000028E4  83 E8 05		SUB EAX, 5
 000028E7  C7 00 00001629 R	MOV [EAX], do_DOVAR
				NEXTC
 000028ED  8B 07	     1	   MOV EAX, [EDI]
 000028EF  83 C7 04	     1	   ADD EDI, 4
 000028F2  FF E0	     1	   JMP EAX 
				;
 000028F4			_VARIABLE:      ; ( "name" -- )      create a variable (changeable) value     VERIFIED 231223
 000028F4  000028CE R		DD _VARHEAD
 000028F8  00002906 R		DD do_VARIABLE
 000028FC  01 08 56 41 52	DB 1, 8, 'VARIABLE'
	   49 41 42 4C 45
 00002906			do_VARIABLE:
 00002906  68 00002910 R	PUSH $ + 10
 0000290B  E9 FFFFECDA		JMP do_DOCOL
 00002910  0000285E R		DD do_CREATE    ; CREATE 0 , ;
 00002914  000008D6 R		DD do_PUSH0
 00002918  000027D0 R		DD do_COMMA
 0000291C  00000862 R		DD do_SEMI
				;
 00002920			_VALUE:         ; ( n "name" -- )  \ create a self fetching changeable value  VERIFIED 231223
 00002920  000028F4 R		DD _VARIABLE
 00002924			VALUE:
 00002924  0000292F R		DD do_VALUE
 00002928  01 05 56 41 4C	DB 1, 5, 'VALUE'
	   55 45
 0000292F			do_VALUE:
 0000292F  68 00002939 R	PUSH $ + 10
 00002934  E9 FFFFECB1		JMP do_DOCOL
 00002939  00000132 R		DD do_STATE, do_FETCH
	   00000922 R
 00002941  00001F4C R		DD do_IF@, do_S_ADR, do_FETCH                                         ; DETERMINS WHERE IPUT IF FROM
	   000004A4 R
	   00000922 R
 0000294D  00001F88 R		DD do_ELSE@, TIB
	   00001CA3 R
 00002955  00001FAC R		DD do_THEN@
 00002959  00000C07 R		DD do_LIT, 32, do_WORD, do_COUNT
	   00000020
	   0000185D R
	   000013AB R
 00002969  00000F9A R		DD do_2DUP, do_UPPERCASE, do_DROP
	   00001AC9 R
	   00000C22 R
 00002975  00001D28 R		DD do_NEWHEADER                                                       ; 'n TO value-name' will change a value
 00002979  00002312 R		DD do_GCFA, do_DOVALUE, do_NFA, do_LIT, 5, do_MINUS,  do_STORE        ; DOVALUE COMPILE
	   000016A0 R
	   00000211 R
	   00000C07 R
	   00000005
	   00000A90 R
	   00000938 R
 00002995  000027D0 R		DD do_COMMA                                                           ; ( n )     ,  Parameter field
 00002999  00000862 R		DD do_SEMI
				;
 0000299D			_LITERAL:       ;( n -- )
 0000299D  00002920 R		DD _VALUE       ; COMPILE LIT , ; IMMEDIATE 
 000029A1			LITERAL:
 000029A1  000029AE R		DD do_LITERAL
 000029A5  01 07 4C 49 54	DB 1, 7, 'LITERAL'
	   45 52 41 4C
 000029AE			do_LITERAL:
 000029AE  68 000029B8 R	PUSH $ + 10
 000029B3  E9 FFFFEC32		JMP do_DOCOL
 000029B8  0000090B R		DD do_COMPILE
 000029BC  00000C07 R		DD do_LIT
 000029C0  000027D0 R		DD do_COMMA
 000029C4  00000862 R		DD do_SEMI
				;
 000029C8			_CHAR:  ; ( "c" -- char )
				 ;   parse char from input stream and put its ascii code on stack.
				 ;   If <c> is longer than a char, takes its first char.
				 ;   If parse area is empty return 0.
				 ;   BL WORD COUNT 0<> SWAP C@ AND ;
 000029C8  0000299D R		DD _LITERAL
 000029CC  000029D6 R		DD do_CHAR
 000029D0  00 04 43 48 41	DB 0, 4, 'CHAR'
	   52
 000029D6			do_CHAR:
 000029D6  68 000029E0 R	PUSH $ + 10
 000029DB  E9 FFFFEC0A		JMP do_DOCOL
 000029E0  00001CA3 R		DD TIB, do_LIT, 32, do_WORD, do_COUNT
	   00000C07 R
	   00000020
	   0000185D R
	   000013AB R
 000029F4  00000FEA R		DD do_0NE   ; 0 <>
 000029F8  00000C50 R		DD do_SWAP, do_CFETCH, do_AND
	   0000097D R
	   00001486 R
 00002A04  00000862 R		DD do_SEMI
				;
 00002A08			PCHARP:
 00002A08  000029C8 R		DD _CHAR
 00002A0C  00002A18 R		DD do_PCHARP
 00002A10  01 06 5B 43 48	DB 1, 6, '[CHAR]'
	   41 52 5D
 00002A18			do_PCHARP:
 00002A18  68 00002A22 R	PUSH $ + 10
 00002A1D  E9 FFFFEBC8		JMP do_DOCOL
 00002A22  000029D6 R		DD do_CHAR
 00002A26  000029AE R		DD do_LITERAL
 00002A2A  00000862 R		DD do_SEMI
				;
 00002A2E			NUMBERQ:        ; ( addr len -- d1 f1 ) 
 00002A2E  00002A08 R		DD PCHARP
 00002A32  00002A3F R		DD do_NUMBER?
 00002A36  00 07 4E 55 4D	DB 0, 7, 'NUMBER?'
	   42 45 52 3F
 00002A3F			do_NUMBER?:
 00002A3F  68 00002A49 R	PUSH $ + 10
 00002A44  E9 FFFFEBA1		JMP do_DOCOL
 00002A49  000036A4 R		DD do_PNUMBERP
 00002A4D  00000862 R		DD do_SEMI
				;
 00002A51			_NUMBER:     ; ( str -- d ) COUNT (NUMBER?) ?MISSING   
 00002A51  00002A2E R		DD NUMBERQ
 00002A55			NUMBER:
 00002A55  00002A61 R		DD do_NUMBER
 00002A59  00 06 4E 55 4D	DB 0, 6, 'NUMBER'
	   42 45 52
 00002A61			do_NUMBER:
 00002A61  68 00002A6B R	PUSH $ + 10
 00002A66  E9 FFFFEB7F		JMP do_DOCOL
 00002A6B  000013AB R		DD do_COUNT, do_NUMBER?, do_?MISSING
	   00002A3F R
	   00002144 R
 00002A77  00000862 R		DD do_SEMI
				;        
				;   -------------------- NUMBER DEFINITIONS ---------------------------
				;
 00002A7B			POUNDS:         ;( d1 -- d2 ) \ consume last digits in a pictured number output - see <#
 00002A7B  00002A51 R		DD _NUMBER      ; BEGIN  #  2DUP OR 0= UNTIL ;
 00002A7F  00002A87 R		DD do_POUNDS
 00002A83  00 02 23 53		DB 0, 2, '#S'
 00002A87			do_POUNDS:
 00002A87  68 00002A91 R	PUSH $ + 10
 00002A8C  E9 FFFFEB59		JMP do_DOCOL
 00002A91  00002D5E R		DD do_BEGIN@
 00002A95  00001E8F R		DD do_POUND
 00002A99  00000F9A R		DD do_2DUP
 00002A9D  0000149E R		DD do_OR
 00002AA1  0000101E R		DD do_0GT       ; do_EQU0
 00002AA5  00002D85 R		DD do_UNTIL@
 00002AA9  00000862 R		DD do_SEMI
				;
 00002AAD			_PDDOTP:            ; (D.) ( d -- addr len )   convert as signed double to ascii string
 00002AAD  00002A7B R		DD POUNDS
 00002AB1  00002ABB R		DD do_PDDOTP
 00002AB5  00 04 28 44 2E	DB 0, 4, '(D.)'
	   29
 00002ABB			do_PDDOTP:          ; TUCK DABS  <# #S ROT SIGN #> ;
 00002ABB  68 00002AC5 R	PUSH $ + 10
 00002AC0  E9 FFFFEB25		JMP do_DOCOL
 00002AC5  00000D09 R		DD do_TUCK
 00002AC9  00001E22 R		DD do_DABS
 00002ACD  00002B82 R		DD do_RPOUND
 00002AD1  00002A87 R		DD do_POUNDS
				;DD do_ROT
				;DD do_SIGN
 00002AD5  00002BB4 R		DD do_LPOUND
 00002AD9  00000862 R		DD do_SEMI
				;
 00002ADD			_DDOT:              ;( d -- )   display as signed double
 00002ADD  00002AAD R		DD _PDDOTP          ; (D.) TYPE SPACE ;
 00002AE1  00002AE9 R		DD do_DDOT
 00002AE5  00 02 44 2E		DB 0, 2, 'D.'
 00002AE9			do_DDOT:
 00002AE9  68 00002AF3 R	PUSH $ + 10
 00002AEE  E9 FFFFEAF7		JMP do_DOCOL
 00002AF3  00002ABB R		DD do_PDDOTP        ; (D.)
 00002AF7  0000220F R		DD do_TYPE
 00002AFB  00000C07 R		DD do_LIT, 32
	   00000020
 00002B03  0000277C R		DD do_EMIT
 00002B07  00000862 R		DD do_SEMI
				;
 00002B0B			DDOTR:  ; ( d w -- ) \ display as signed double right justified in w wide field
 00002B0B  00002ADD R		DD _DDOT
 00002B0F  00002B18 R		DD do_DDOTR
 00002B13  00 03 44 2E 52	DB 0, 3, 'D.R'
 00002B18			do_DDOTR:           ; >R (D.) R> OVER - SPACES TYPE ;
 00002B18  68 00002B22 R	PUSH $ + 10
 00002B1D  E9 FFFFEAC8		JMP do_DOCOL
 00002B22  00000EB8 R		DD do_TOR
 00002B26  00002AE9 R		DD do_DDOT
 00002B2A  00000ED2 R		DD do_FROMR
 00002B2E  00000C6F R		DD do_OVER
 00002B32  00000A90 R		DD do_MINUS
 00002B36  00001E6A R		DD do_SPACES
 00002B3A  0000220F R		DD do_TYPE
 00002B3E  00000862 R		DD do_SEMI
				;
 00002B42			SIGN:                  ; ( f1 -- ) \ insert a sign in pictured number output - see <#
 00002B42  00002B0B R		DD DDOTR               ; 0< IF  [CHAR] - HOLD  THEN ;
 00002B46  00002B50 R		DD do_SIGN
 00002B4A  00 04 53 49 47	DB 0, 4, 'SIGN'
	   4E
 00002B50			do_SIGN:
 00002B50  68 00002B5A R	PUSH $ + 10
 00002B55  E9 FFFFEA90		JMP do_DOCOL
 00002B5A  00001006 R		DD do_0LT
 00002B5E  00002C1F R		DD do_IF
 00002B62  00002A18 R		DD do_PCHARP            ; [CHAR]
 00002B66  0000002D		DD 45                   ; '-' CHAR
 00002B6A  00001E45 R		DD do_HOLD
 00002B6E  00002C5F R		DD do_THEN
 00002B72  00000862 R		DD do_SEMI
				;
 00002B76			RPOUND:             ; <# ( ud -- ) \ begin a pictured number output. Full example :
 00002B76  00002B42 R		DD SIGN             ; : test dup 0< if negate -1 else 0 then >r
 00002B7A  00002B82 R		DD do_RPOUND        ; s>d <# [char] $ hold # # [char] . hold # # # [char] , hold #S r> sign #>
 00002B7E  00 02 3C 23		DB 0, 2, '<#'          ; cr type ;
 00002B82			do_RPOUND:          ; PAD HLD ! ;
 00002B82  68 00002B8C R	PUSH $ + 10
 00002B87  E9 FFFFEA5E		JMP do_DOCOL
 00002B8C  00001B96 R		DD PAD
 00002B90  00000C07 R		DD do_LIT, 12
	   0000000C
 00002B98  00000A79 R		DD do_PLUS
 00002B9C  00000115 R		DD do_HLD, do_STORE
	   00000938 R
 00002BA4  00000862 R		DD do_SEMI
				;
 00002BA8			LPOUND:              ; #> ( d1 -- addr len ) \ ends a pictured number output - see <#
 00002BA8  00002B76 R		DD RPOUND            ;2DROP  HLD @ PAD OVER - ;
 00002BAC  00002BB4 R		DD do_LPOUND
 00002BB0  00 02 23 3E		DB 0, 2, '#>'
 00002BB4			do_LPOUND:
 00002BB4  68 00002BBE R	PUSH $ + 10
 00002BB9  E9 FFFFEA2C		JMP do_DOCOL
 00002BBE  00000FB9 R		DD do_2DROP
 00002BC2  00000115 R		DD do_HLD,  do_DUP, do_FETCH
	   00000C37 R
	   00000922 R
 00002BCE  00001B96 R		DD PAD  ;do_OVER
				;DD do_SWAP, 
 00002BD2  00000A90 R		DD do_MINUS    ; NO NEED TO CALC LENGTH
 00002BD6  00000862 R		DD do_SEMI
				;
 00002BDA			_IMMEDIATE:              ; ( -- )  VERIFIED 231227
 00002BDA  00002BA8 R		DD LPOUND                ; \ mark the last header created as an immediate word
 00002BDE			IMMEDIATE:
 00002BDE  00002BED R		DD do_IMMEDIATE          ; LAST @ N>BFA BFA_IMMEDIATE ( TOGGLE ) over c@ or swap c! ;
 00002BE2  00 09 49 4D 4D	DB 0, 9, 'IMMEDIATE'
	   45 44 49 41 54
	   45
 00002BED			do_IMMEDIATE:
 00002BED  68 00002BF7 R	PUSH $ + 10
 00002BF2  E9 FFFFE9F3		JMP do_DOCOL
 00002BF7  000038F1 R		DD LASTNFA, do_1MINUS, do_DUP, do_PUSH1, do_SWAP, do_CSTORE
	   00000B5C R
	   00000C37 R
	   000008A9 R
	   00000C50 R
	   00000995 R
 00002C0F  00000862 R		DD do_SEMI
				;
 00002C13			_IF:
 00002C13  00002BDA R		DD _IMMEDIATE
 00002C17  00002C1F R		DD do_IF
 00002C1B  00 02 49 46		DB 0, 2, 'IF'
 00002C1F			do_IF:
 00002C1F  68 00002C29 R	PUSH $ + 10
 00002C24  E9 FFFFE9C1		JMP do_DOCOL
 00002C29  00002BED R		DD do_IMMEDIATE
 00002C2D  00000862 R		DD do_SEMI
				;
 00002C31			_ELSE:
 00002C31  00002C13 R		DD _IF
 00002C35  00002C3F R		DD do_ELSE
 00002C39  00 04 45 4C 53	DB 0, 4, 'ELSE'
	   45
 00002C3F			do_ELSE:
 00002C3F  68 00002C49 R	PUSH $ + 10
 00002C44  E9 FFFFE9A1		JMP do_DOCOL
 00002C49  00002BED R		DD do_IMMEDIATE
 00002C4D  00000862 R		DD do_SEMI
				;
 00002C51			_THEN:
 00002C51  00002C31 R		DD _ELSE
 00002C55  00002C5F R		DD do_THEN
 00002C59  00 04 54 48 45	DB 0, 4, 'THEN'
	   4E
 00002C5F			do_THEN:
 00002C5F  68 00002C69 R	PUSH $ + 10
 00002C64  E9 FFFFE981		JMP do_DOCOL
 00002C69  00002BED R		DD do_IMMEDIATE
 00002C6D  00000862 R		DD do_SEMI
				;
 00002C71			_NIF:
 00002C71  00002C51 R		DD _THEN
 00002C75  00002C7E R		DD do_NIF
 00002C79  00 02 2D 49 46	DB 0, 2, '-IF'
 00002C7E			do_NIF:
 00002C7E  68 00002C88 R	PUSH $ + 10
 00002C83  E9 FFFFE962		JMP do_DOCOL

 00002C88  00000862 R		DD do_SEMI
				;
 00002C8C			_LMARK:         ; <MARK ( -- addr )   HERE ;
 00002C8C  00002C71 R		DD _NIF
 00002C90  00002C9B R		DD do_LMARK
 00002C94  00 05 3C 4D 41	DB 0, 5, '<MARK'
	   52 4B
 00002C9B			do_LMARK:
 00002C9B  68 00002CA5 R	PUSH $ + 10
 00002CA0  E9 FFFFE945		JMP do_DOCOL
 00002CA5  00001AA8 R		DD do_HERE
 00002CA9  00000862 R		DD do_SEMI
				;
 00002CAD			_QCOMP:         ; ?COMP  STATE @ 0=  THROW_COMPONLY   ?THROW  ;
 00002CAD  00002C8C R		DD _LMARK       ; CHECK FOR COMPILATION STATE THROW ERROR IF NOT
 00002CB1  00002CBC R		DD do_?COMP
 00002CB5  00 05 3F 43 4F	DB 0, 5, '?COMP'
	   4D 50
 00002CBC			do_?COMP:
 00002CBC  68 00002CC6 R	PUSH $ + 10
 00002CC1  E9 FFFFE924		JMP do_DOCOL
 00002CC6  00000132 R		DD do_STATE, do_FETCH, do_EQU0
	   00000922 R
	   00000FCF R
 00002CD2  00000862 R		DD do_SEMI
				;
 00002CD6			QPAIRS:                ; ?PAIRS        ( n1 n2 -- )  XOR THROW_MISMATCH ?THROW ; \ Sometimes used in applications.
 00002CD6  00002CAD R		DD _QCOMP
 00002CDA  00002CE6 R		DD do_?PAIRS
 00002CDE  00 06 3F 50 41	DB 0, 6, '?PAIRS'
	   49 52 53
 00002CE6			do_?PAIRS:
 00002CE6  68 00002CF0 R	PUSH $ + 10
 00002CEB  E9 FFFFE8FA		JMP do_DOCOL
 00002CF0  000014B7 R		DD do_XOR
 00002CF4  00000862 R		DD do_SEMI
				;
 00002CF8			_BEGIN:            ; BEGIN  ?COMP  COMPILE _BEGIN <MARK CELL+ 1 ; IMMEDIATE
 00002CF8  00002CD6 R		DD QPAIRS
 00002CFC  00002D07 R		DD do_BEGIN
 00002D00  01 05 42 45 47	DB 1, 5, 'BEGIN'
	   49 4E
 00002D07			do_BEGIN:
 00002D07  68 00002D11 R	PUSH $ + 10
 00002D0C  E9 FFFFE8D9		JMP do_DOCOL
 00002D11  00002CBC R		DD do_?COMP
 00002D15  0000090B R		DD do_COMPILE
 00002D19  00002C9B R		DD do_LMARK
 00002D1D  000008A9 R		DD do_PUSH1
 00002D21  00000DCF R		DD do_CELLPLUS
 00002D25  00000862 R		DD do_SEMI
				;
 00002D29			LRESOLVE:       ; : <RESOLVE      ( addr -- )   , ;
 00002D29  00002CF8 R		DD _BEGIN
 00002D2D  00002D3B R		DD do_LRESOLVE
 00002D31  00 08 3C 52 45	DB 0, 8, '<RESOLVE'
	   53 4F 4C 56 45
 00002D3B			do_LRESOLVE:
 00002D3B  68 00002D45 R	PUSH $ + 10
 00002D40  E9 FFFFE8A5		JMP do_DOCOL
 00002D45  000027D0 R		DD do_COMMA
 00002D49  00000862 R		DD do_SEMI
				;
 00002D4D			_BEGIN@:                    ; NOW USING THE CONTROL STACK  (CSP)
 00002D4D  00002D29 R		DD LRESOLVE                 ; verified working from interpreter 240101
 00002D51  00002D5E R		DD do_BEGIN@
 00002D55  00 06 5B 42 45	DB 0, 6, '[BEGIN]'
	   47 49 4E 5D
 00002D5E			do_BEGIN@:
 00002D5E  A1 00000954 R	MOV EAX, CSP
 00002D63  83 E8 04		SUB EAX, 4
 00002D66  89 38		MOV [EAX], EDI
 00002D68  A3 00000954 R	MOV CSP, EAX
				NEXTC
 00002D6D  8B 07	     1	   MOV EAX, [EDI]
 00002D6F  83 C7 04	     1	   ADD EDI, 4
 00002D72  FF E0	     1	   JMP EAX 
				;
 00002D74			_UNTIL@:                    ; verified working from interpreter 240101
 00002D74  00002D4D R		DD _BEGIN@
 00002D78  00002D85 R		DD do_UNTIL@
 00002D7C  00 06 5B 55 4E	DB 0, 6, '[UNTIL]'
	   54 49 4C 5D
 00002D85			do_UNTIL@:
 00002D85  58			POP EAX
 00002D86  83 F8 00		CMP EAX, 0
 00002D89  74 0E		JE @BU
 00002D8B  A1 00000954 R	MOV EAX, CSP
 00002D90  8B 38		MOV EDI, [EAX]
				NEXTC
 00002D92  8B 07	     1	   MOV EAX, [EDI]
 00002D94  83 C7 04	     1	   ADD EDI, 4
 00002D97  FF E0	     1	   JMP EAX 
 00002D99			@BU:
 00002D99  A1 00000954 R	MOV EAX, CSP
 00002D9E  83 C0 04		ADD EAX, 4      ; BEGIN-UNTIL IS NOW COMPLETED DROP ADDRESS
 00002DA1  A3 00000954 R	MOV CSP, EAX
				NEXTC
 00002DA6  8B 07	     1	   MOV EAX, [EDI]
 00002DA8  83 C7 04	     1	   ADD EDI, 4
 00002DAB  FF E0	     1	   JMP EAX 
				;
 00002DAD			_UNTIL:         ; UNTIL ( F1 -- ) ?COMP  1 ?PAIRS  COMPILE _UNTIL  <RESOLVE ; IMMEDIATE
 00002DAD  00002D74 R		DD _UNTIL@ 
 00002DB1  00002DBC R		DD do_UNTIL
 00002DB5  00 05 55 4E 54	DB 0, 5, 'UNTIL'
	   49 4C
 00002DBC			do_UNTIL:
 00002DBC  68 00002DC6 R	PUSH $ + 10
 00002DC1  E9 FFFFE824		JMP do_DOCOL
 00002DC6  00002CBC R		DD do_?COMP
 00002DCA  000008A9 R		DD do_PUSH1
 00002DCE  00002CE6 R		DD do_?PAIRS
 00002DD2  0000090B R		DD do_COMPILE
 00002DD6  00001F21 R		DD do__UNTIL
 00002DDA  00002D3B R		DD do_LRESOLVE
 00002DDE  00000862 R		DD do_SEMI
				;
 00002DE2			_dotR:               ;( n w -- ) \ display as signed single right justified in w wide field
 00002DE2  00002D74 R		DD _UNTIL@                   
 00002DE6  00002DEE R		DD do_dotR
 00002DEA  00 02 2E 52		DB 0, 2, '.R'
 00002DEE			do_dotR:
 00002DEE  68 00002DF8 R	PUSH $ + 10
 00002DF3  E9 FFFFE7F2		JMP do_DOCOL
 00002DF8  00000EB8 R		DD do_TOR, do_StoD, do_FROMR, do_DDOTR                      ; >R  S>D  R>  D.R
	   00000D40 R
	   00000ED2 R
	   00002B18 R
 00002E08  00000862 R		DD do_SEMI
				;
 00002E0C			_dotS: ;     ( -- ) \ display current data stack contents  VERIFIED 231211
 00002E0C  00002DE2 R		DD _dotR
 00002E10  00002E18 R		DD do_dotS
 00002E14  00 02 2E 53		DB 0, 2, '.S'
 00002E18			do_dotS:
 00002E18  68 00002E22 R	PUSH $ + 10
 00002E1D  E9 FFFFE7C8		JMP do_DOCOL
 00002E22  00001B96 R		DD PAD, do_LIT, 80, do_ERASE
	   00000C07 R
	   00000050
	   000017FF R
 00002E32  000022C1 R		DD do_QSTACK 
 00002E36  00000E41 R		DD do_DEPTH, do_SMAX, do_FETCH, do_MIN, do_SERROR, do_FETCH, do_EQU0
	   00000298 R
	   00000922 R
	   00001164 R
	   00000406 R
	   00000922 R
	   00000FCF R
 00002E52  00001F4C R		DD do_IF@  ;  STACKERROR = 0
 00002E56  00000C37 R		DD do_DUP  ;  MIN = 0 
 00002E5A  00001F4C R		DD do_IF@
 00002E5E  000002B2 R		DD do_S0, do_FETCH, do_LIT, 4, do_MINUS, do_TV3, do_STORE
	   00000922 R
	   00000C07 R
	   00000004
	   00000A90 R
	   00000303 R
	   00000938 R
 00002E7A  00000C07 R		DD do_LIT, 91, do_EMIT, do_DUP                      ; do_DOTP, "["
	   0000005B
	   0000277C R
	   00000C37 R
 00002E8A  00001B96 R		DD PAD, do_SWAP, do_dwtoa, PAD, do_PUSH0      ; invoke dwtoa, dwValue:DWORD, lpBuffer:DWORD 
	   00000C50 R
	   000021B9 R
	   00001B96 R
	   000008D6 R
 00002E9E  000021F2 R		DD do_STDOUT                                        ; DISPLAY ASCII TEXT IN PAD
 00002EA2  00000C07 R		DD do_LIT, 93, do_EMIT, do_LIT, 32, do_EMIT        ; do_DOTP, "]"
	   0000005D
	   0000277C R
	   00000C07 R
	   00000020
	   0000277C R
 00002EBA  00002D5E R		DD do_BEGIN@, do_TV3, do_FETCH, do_FETCH            ; BEGIN TV3 @ @
	   00000303 R
	   00000922 R
	   00000922 R
 00002ECA  00001B96 R		DD PAD, do_SWAP, do_dwtoa, PAD, do_PUSH0      ; invoke dwtoa, dwValue:DWORD, lpBuffer:DWORD 
	   00000C50 R
	   000021B9 R
	   00001B96 R
	   000008D6 R
 00002EDE  000021F2 R		DD do_STDOUT ; , PAD, do_LIT, 16, do_ERASE       ; CLEAR PAD
 00002EE2  00000C07 R		DD do_LIT, 4, do_TV3, do_MINUSSTORE                 ; SDTOUT 4 TV3 -!   
	   00000004
	   00000303 R
	   00000966 R
				;DD do_BASE, do_FETCH, do_LIT, 16, do_EQU           ; BASE @ 16 =
				;DD do_IF@
				;DD do_SPACE, do_EMIT, do_LIT, 'h', do_EMIT
				;DD do_THEN@
 00002EF2  00000C07 R		DD do_LIT, 32, do_EMIT
	   00000020
	   0000277C R
 00002EFE  00000B5C R		DD do_1MINUS, do_DUP, do_0NE
	   00000C37 R
	   00000FEA R
 00002F0A  00002D85 R		DD do_UNTIL@
 00002F0E  00000B44 R		DD do_1PLUS
 00002F12  00001FAC R		DD do_THEN@
 00002F16  00001FAC R		DD do_THEN@
 00002F1A  00000FCF R		DD do_EQU0
 00002F1E  00001F4C R		DD do_IF@
 00002F22  00000C07 R		DD do_LIT, Mempty, do_PUSH0, do_STDOUT, do_RS      ; DISPLAY 'EMPTY' MESSAGE RESET STACK
	   00000C37 R
	   000008D6 R
	   000021F2 R
	   000008BE R
 00002F36  00001FAC R		DD do_THEN@ 
 00002F3A  00000406 R		DD do_SERROR, do_FETCH, do_PUSH0, do_NEQ           ; STACKERROR <> 0
	   00000922 R
	   000008D6 R
	   00001058 R
 00002F4A  00001F4C R		DD do_IF@
 00002F4E  00000C07 R		DD do_LIT, Msg22, do_PUSH0, do_STDOUT, do_RS       ; DISPLAY 'STACKERROR' MESSAGE
	   00000BF8 R
	   000008D6 R
	   000021F2 R
	   000008BE R
 00002F62  00001FAC R		DD do_THEN@
 00002F66  00000862 R		DD do_SEMI
				;
 00002F6A			_ACCEPT:
 00002F6A  00002E0C R		DD _dotS
 00002F6E			ACCEPT:
 00002F6E  00002F7A R		DD do_ACCEPT
 00002F72  00 06 41 43 43	DB 0, 6, 'ACCEPT'
	   45 50 54
 00002F7A			do_ACCEPT: ; ( -- NBREAD)
 00002F7A  68 00002F84 R	PUSH $ + 10
 00002F7F  E9 FFFFE666		JMP do_DOCOL
 00002F84  00001CA3 R		DD TIB, do_ZCOUNT, do_ERASE 
	   0000140B R
	   000017FF R
 00002F90  00001DA6 R		DD do_KBREAD ; ( -- n ) EAX = NBREAD n
 00002F94  00001CA3 R		DD TIB, do_SWAP, do_UPPERCASE
	   00000C50 R
	   00001AC9 R
 00002FA0  00000862 R		DD do_SEMI
				;
 00002FA4			_FORGET:
 00002FA4  00002F6A R		DD _ACCEPT
 00002FA8			FORGET:
 00002FA8  00002FB4 R		DD do_FORGET
 00002FAC  00 06 46 4F 52	DB 0, 6, 'FORGET'
	   47 45 54
 00002FB4			do_FORGET:
 00002FB4  68 00002FBE R	PUSH $ + 10
 00002FB9  E9 FFFFE62C		JMP do_DOCOL
 00002FBE  00001CA3 R		DD TIB, do_LIT, 32, do_WORD, do_COUNT, do_FIND ; LOCATE LFA OF WORD TO REMOVE
	   00000C07 R
	   00000020
	   0000185D R
	   000013AB R
	   00001B38 R
 00002FD6  000001F6 R		DD do_LFA, do_FETCH, do_DUP, do_DUP, do_FETCH, do_LATEST, do_STORE, do_DUP
	   00000922 R
	   00000C37 R
	   00000C37 R
	   00000922 R
	   00000570 R
	   00000938 R
	   00000C37 R
 00002FF6  000001BE R		DD do_DPR, do_FETCH, do_SWAP, do_MINUS, do_SWAP, do_DPR, do_STORE
	   00000922 R
	   00000C50 R
	   00000A90 R
	   00000C50 R
	   000001BE R
	   00000938 R
 00003012  000008D6 R		DD do_PUSH0, do_FILL, do_DROP            ; ERASE SPACE FROM LFA TO END OF DICT (DPR)
	   000017CA R
	   00000C22 R
 0000301E  00000862 R		DD do_SEMI
				;
 00003022			_DOTP:                      ; VERIFIED 231227
 00003022  00002FA4 R		DD _FORGET
 00003026  0000302E R		DD do_DOTP
 0000302A  01 02 2E 22		DB 1, 2, '."'
 0000302E			do_DOTP:        ; HERE [CHAR] " PARSE ", 0 C, ALIGN COUNT
 0000302E  8D 05 00001CA3 R	LEA EAX, TIB    ; SAVE THE ADDRESS OF TIB FOR WORD
 00003034  50			PUSH EAX
 00003035  6A 22		PUSH 34         ; PUSH ASCII "
 00003037  68 00003041 R	PUSH $ + 10
 0000303C  E9 FFFFE5A9		JMP do_DOCOL
 00003041  0000185D R		DD do_WORD      ; PARSE INPUT STRING TIB " WORD
 00003045  000013AB R		DD do_COUNT     ; GET LENGTH
 00003049  00001B96 R		DD PAD, do_SWAP   ; MOVE THE DATA IN THE TIB TO THE DATA AREA
	   00000C50 R
 00003051  00000F9A R		DD do_2DUP, do_2TOR, do_CMOVE, do_2RFROM
	   00000F3D R
	   0000179E R
	   00000F5F R
 00003061  0000220F R		DD do_TYPE
 00003065  000008A9 R		DD do_PUSH1, do_IN, do_FETCH  ; 1 _IN @ + _IN !     INCREMENT THE _IN OFFSET
	   0000025F R
	   00000922 R
 00003071  00000A79 R		DD do_PLUS, do_IN, do_STORE
	   0000025F R
	   00000938 R
 0000307D  00001B96 R		DD PAD, do_ZCOUNT, do_ERASE
	   0000140B R
	   000017FF R
 00003089  00000862 R		DD do_SEMI
				;
 0000308D			_PAUSE:         ; ( N -- ) PAUSE FOR N MILLISECONDS          VERIFIED
 0000308D  00003022 R		DD _DOTP
 00003091  0000309C R		DD do_PAUSE
 00003095  00 05 50 41 55	DB 0, 5, 'PAUSE'
	   53 45
 0000309C			do_PAUSE:
 0000309C  68 000030A6 R	PUSH $ + 10
 000030A1  E9 FFFFE544		JMP do_DOCOL
 000030A6  00002231 R		DD do_MS, do_PLUS
	   00000A79 R
 000030AE  00002D5E R		DD do_BEGIN@
 000030B2  00002231 R		DD do_MS, do_OVER, do_GT, do_EQU0
	   00000C6F R
	   0000109B R
	   00000FCF R
 000030C2  00002D85 R		DD do_UNTIL@
 000030C6  00000C22 R		DD do_DROP
 000030CA  00000862 R		DD do_SEMI
				NEXTC
 000030CE  8B 07	     1	   MOV EAX, [EDI]
 000030D0  83 C7 04	     1	   ADD EDI, 4
 000030D3  FF E0	     1	   JMP EAX 
				;
 000030D5			_KEY:       ; ( -- C )  INPUTS A CHARACTER FROM KEYBOARD
 000030D5  0000308D R		DD _PAUSE
 000030D9			KEY:
 000030D9  000030E2 R		DD do_KEY  
 000030DD  00 03 4B 45 59	DB 0, 3, 'KEY'
 000030E2			do_KEY:

				NEXTC
 000030E2  8B 07	     1	   MOV EAX, [EDI]
 000030E4  83 C7 04	     1	   ADD EDI, 4
 000030E7  FF E0	     1	   JMP EAX 
				;
 000030E9			_KEYQ:      ; ( -- N ) CHECK FOR CHARACTER IN BUFFER
 000030E9  000030D5 R		DD _KEY
 000030ED  000030F7 R		DD do_KEYQ
 000030F1  00 04 4B 45 59	DB 0, 4,'KEY?'
	   3F
 000030F7			do_KEYQ:
 000030F7  FF 35 0000097C R	push  KEYIN
 000030FD  6A 00		push 0
 000030FF  E8 00000000 E	call GetNumberOfConsoleInputEvents
				NEXTC
 00003104  8B 07	     1	   MOV EAX, [EDI]
 00003106  83 C7 04	     1	   ADD EDI, 4
 00003109  FF E0	     1	   JMP EAX 
				;
 0000310B			_ALLOT:         ; ( n -- ) \ allocate n bytes at HERE, increment DP         VERIFIED
 0000310B  000030E9 R		DD _KEYQ        ; DUP 1000 + ?MEMCHK DP +! ;
 0000310F			ALLOT:
 0000310F  0000311A R		DD do_ALLOT
 00003113  00 05 41 4C 4C	DB 0, 5, 'ALLOT'
	   4F 54
 0000311A			do_ALLOT:
 0000311A  68 00003124 R	PUSH $ + 10
 0000311F  E9 FFFFE4C6		JMP do_DOCOL
 00003124  00000C37 R		DD do_DUP, do_LIT, 1000, do_PLUS
	   00000C07 R
	   000003E8
	   00000A79 R
 00003134  00000A2A R		DD do_MEMQ, do_LT
	   00001073 R
 0000313C  00001F4C R		DD do_IF@, do_DPR, do_PLUSSTORE, do_PUSH0
	   000001BE R
	   0000094F R
	   000008D6 R
 0000314C  00001FAC R		DD do_THEN@, do_DROP
	   00000C22 R
 00003154  00000862 R		DD do_SEMI
				;
 00003158			_TICK:      ; ( -- ADDR ) RETURNS THE CFA OF THE NEXT INPUT WORD   VERIFIED 231214
 00003158  0000310B R		DD _ALLOT
 0000315C  00003163 R		DD do_TICK
 00003160  00 01 27		DB 0, 1, "'"
 00003163			do_TICK:
 00003163  68 0000316D R	PUSH $ + 10
 00003168  E9 FFFFE47D		JMP do_DOCOL
 0000316D  00001CA3 R		DD TIB, do_LIT, 32, do_WORD, do_COUNT, do_FIND
	   00000C07 R
	   00000020
	   0000185D R
	   000013AB R
	   00001B38 R
 00003185  00000862 R		DD do_SEMI
				;
 00003189			_TO:                        ; VERIFIED 231201
 00003189  00003158 R		DD _TICK 
 0000318D			TO:
 0000318D  00003195 R		DD do_TO
 00003191  00 02 54 4F		DB 0, 2, 'TO'
 00003195			do_TO:
 00003195  68 0000319F R	PUSH $ + 10
 0000319A  E9 FFFFE44B		JMP do_DOCOL
 0000319F  00001CA3 R		DD TIB, do_LIT, 32, do_WORD, do_COUNT, do_FIND
	   00000C07 R
	   00000020
	   0000185D R
	   000013AB R
	   00001B38 R
 000031B7  000016CB R		DD do_VALUESTORE
 000031BB  00000862 R		DD do_SEMI
				;
 000031BF			_PTO:                        ; VERIFIED 231201
 000031BF  00003189 R		DD _TO 
 000031C3  000031CC R		DD do_PTO
 000031C7  00 03 2B 54 4F	DB 0, 3, '+TO'
 000031CC			do_PTO:
 000031CC  68 000031D6 R	PUSH $ + 10
 000031D1  E9 FFFFE414		JMP do_DOCOL
 000031D6  00001CA3 R		DD TIB, do_LIT, 32, do_WORD, do_COUNT, do_FIND
	   00000C07 R
	   00000020
	   0000185D R
	   000013AB R
	   00001B38 R
 000031EE  000016F9 R		DD do_VALPLUSTORE
 000031F2  00000862 R		DD do_SEMI
				;
 000031F6			_ZCOMMAQ:             ; Z,"  ( -<string">- )  \ compile string delimited by " as uncounted
 000031F6  000031BF R		DD _PTO               ;      chars null-terminated chars at here
 000031FA  00003203 R		DD do_ZCOMM           ;      HERE [CHAR] " PARSE Z", 0 C, ALIGN ZCOUNT \N->CRLF
 000031FE  00 03 5A 2C 22	DB 0, 3,'Z,"'
 00003203			do_ZCOMM:
 00003203  68 0000320D R	PUSH $ + 10
 00003208  E9 FFFFE3DD		JMP do_DOCOL
 0000320D  00001CA3 R		DD TIB, do_LIT, 34, do_PARSE, do_2DUP, do_HERE, do_SWAP, do_CMOVE
	   00000C07 R
	   00000022
	   000019DC R
	   00000F9A R
	   00001AA8 R
	   00000C50 R
	   0000179E R
 0000322D  00000CF1 R		DD do_NIP, do_DUP, do_HERE, do_PLUS, do_DPR, do_STORE
	   00000C37 R
	   00001AA8 R
	   00000A79 R
	   000001BE R
	   00000938 R
 00003245  000008D6 R		DD do_PUSH0, do_CCOMMA
	   00002830 R
 0000324D  00000862 R		DD do_SEMI
				;
 00003251			_ANEW:              ; MARKER FOR USE OF FORGET      VERIFIED 231205
 00003251  000031F6 R		DD _ZCOMMAQ
 00003255			ANEW:
 00003255  0000325F R		DD do_ZCOMMAQ
 00003259  00 04 41 4E 45	DB 0, 4, 'ANEW'
	   57
 0000325F			do_ZCOMMAQ:
 0000325F  68 00003269 R	PUSH $ + 10
 00003264  E9 FFFFE381		JMP do_DOCOL
 00003269  00001CA3 R		DD TIB, do_LIT, 32, do_WORD, do_COUNT
	   00000C07 R
	   00000020
	   0000185D R
	   000013AB R
 0000327D  00001D28 R		DD do_NEWHEADER 
 00003281  00002312 R		DD do_GCFA, do_NOOP, do_NFA, do_LIT, 4, do_MINUS,  do_STORE 
	   00001A93 R
	   00000211 R
	   00000C07 R
	   00000004
	   00000A90 R
	   00000938 R
 0000329D  00000862 R		DD do_SEMI
				;
 000032A1			_WORDS:                 ; listing of dictionary words          VERIFIED 231224
 000032A1  00003251 R		DD _ANEW
 000032A5  000015CB R		DD do_COLN              ;   do_WORDS
 000032A9  00 05 57 4F 52	DB 0, 5, 'WORDS'
	   44 53
				; REPLACED WITH do_COLN IN CFA                       ;   do_WORDS: PUSH $ + 10  JMP do_DOCOL
 000032B0  00001B96 R		DD PAD, do_LIT, 160, do_ERASE
	   00000C07 R
	   000000A0
	   000017FF R
 000032C0  00001B96 R		DD PAD, do_HLD, do_STORE, do_PUSH0, do_TV1, do_STORE
	   00000115 R
	   00000938 R
	   000008D6 R
	   000002CD R
	   00000938 R
 000032D8  00000570 R		DD do_LATEST, do_FETCH
	   00000922 R
 000032E0  00002D5E R		DD do_BEGIN@
 000032E4  00000C37 R		DD do_DUP, do_LIT, 9, do_PLUS, do_DUP, do_PUSH1, do_PLUS, do_SWAP, do_CFETCH, do_DUP, do_TOR ; SAVE LENGTH
	   00000C07 R
	   00000009
	   00000A79 R
	   00000C37 R
	   000008A9 R
	   00000A79 R
	   00000C50 R
	   0000097D R
	   00000C37 R
	   00000EB8 R
 00003310  00000115 R		DD do_HLD, do_FETCH, do_SWAP, do_CMOVE, do_FROMR    ; RECOVER LENGTH
	   00000922 R
	   00000C50 R
	   0000179E R
	   00000ED2 R
 00003324  000008A9 R		DD do_PUSH1, do_TV1, do_PLUSSTORE                   ; INCREMENT COUNTER
	   000002CD R
	   0000094F R
 00003330  00000C07 R		DD do_LIT, 16, do_SWAP, do_MINUS, PAD, do_ZCOUNT, do_PLUS, do_SWAP
	   00000010
	   00000C50 R
	   00000A90 R
	   00001B96 R
	   0000140B R
	   00000A79 R
	   00000C50 R
 00003350  00000C07 R		DD do_LIT, 32, do_FILL                              ; ADD SPACES TO END OF THE BUFFER 
	   00000020
	   000017CA R
 0000335C  00000C07 R		DD do_LIT, 12, do_HLD, do_PLUSSTORE
	   0000000C
	   00000115 R
	   0000094F R
 0000336C  000002CD R		DD do_TV1, do_FETCH, do_LIT, 8, do_EQU
	   00000922 R
	   00000C07 R
	   00000008
	   0000103B R
 00003380  00001F4C R		DD do_IF@
 00003384  00001B96 R		DD PAD, do_ZCOUNT, do_TYPE, do_CR, do_LIT, 100, do_PAUSE
	   0000140B R
	   0000220F R
	   00001E01 R
	   00000C07 R
	   00000064
	   0000309C R
 000033A0  000008D6 R		DD do_PUSH0, do_TV1, do_STORE, PAD, do_ZCOUNT, do_LIT, 0, do_FILL
	   000002CD R
	   00000938 R
	   00001B96 R
	   0000140B R
	   00000C07 R
	   00000000
	   000017CA R
 000033C0  00001B96 R		DD PAD, do_HLD, do_STORE
	   00000115 R
	   00000938 R
 000033CC  00001FAC R		DD do_THEN@
 000033D0  00000922 R		DD do_FETCH, do_DUP, do_0NE
	   00000C37 R
	   00000FEA R
 000033DC  00002D85 R		DD do_UNTIL@
 000033E0  000002CD R		DD do_TV1, do_FETCH, do_LIT, 0, do_GT
	   00000922 R
	   00000C07 R
	   00000000
	   0000109B R
 000033F4  00001F4C R		DD do_IF@
 000033F8  00001B96 R		DD PAD, do_ZCOUNT, do_TYPE, do_CR, do_CR
	   0000140B R
	   0000220F R
	   00001E01 R
	   00001E01 R
 0000340C  000008D6 R		DD do_PUSH0, do_TV1, do_STORE, PAD, do_ZCOUNT, do_LIT, 0, do_FILL
	   000002CD R
	   00000938 R
	   00001B96 R
	   0000140B R
	   00000C07 R
	   00000000
	   000017CA R
 0000342C  00001FAC R		DD do_THEN@
 00003430  00000862 R		DD do_SEMI
				;
 00003434			_CTYPE:  ; ( STRING, LEN -- )       VERIFIED 231208
 00003434  000032A1 R		DD _WORDS
 00003438			CTYPE:
 00003438  00003443 R		DD do_CTYPE
 0000343C  00 05 43 54 59	DB 0, 5, 'CTYPE'
	   50 45
 00003443			do_CTYPE:
 00003443  68 0000344D R	PUSH $ + 10
 00003448  E9 FFFFE19D		JMP do_DOCOL
 0000344D  00002D5E R		DD do_BEGIN@
 00003451  00000EB8 R		DD do_TOR
 00003455  00000C37 R		DD do_DUP, do_CFETCH, do_CMAX, do_EMIT
	   0000097D R
	   000023AD R
	   0000277C R
 00003465  00000B44 R		DD do_1PLUS
 00003469  00000ED2 R		DD do_FROMR, do_1MINUS, do_DUP
	   00000B5C R
	   00000C37 R
 00003475  00002D85 R		DD do_UNTIL@, do_2DROP
	   00000FB9 R
 0000347D  00000862 R		DD do_SEMI
				;
 00003481			_DUMP:         ; ( ADDR, N --  )  VERIFIED 231224
 00003481  00003434 R		DD _CTYPE
 00003485  000015CB R		DD do_COLN
 00003489  00 04 44 55 4D	DB 0, 4, 'DUMP'
	   50
 0000348F  00001E01 R		DD do_CR
 00003493			@DLOOP1:
 00003493  000002CD R		DD do_TV1, do_STORE, do_TV2, do_STORE
	   00000938 R
	   000002E8 R
	   00000938 R
 000034A3  00001B96 R		DD PAD, do_HLD, do_STORE
	   00000115 R
	   00000938 R
 000034AF  000002E8 R		DD do_TV2, do_FETCH, do_TV1, do_FETCH, do_PLUS     ; CALC END POINT AND SAVE
	   00000922 R
	   000002CD R
	   00000922 R
	   00000A79 R
 000034C3  00002D5E R		DD do_BEGIN@, do_TOR                               ; BEGIN0
	   00000EB8 R
 000034CB  00000115 R		DD do_HLD, do_FETCH, do_TV2, do_FETCH, do_I2HEX    
	   00000922 R
	   000002E8 R
	   00000922 R
	   00001ECF R
 000034DF  0000140B R		DD do_ZCOUNT, do_TYPE
	   0000220F R
 000034E7  00000444 R		DD do_SEP1, do_ZCOUNT, do_TYPE
	   0000140B R
	   0000220F R
 000034F3  00001B96 R		DD PAD, do_ZCOUNT, do_ERASE
	   0000140B R
	   000017FF R
 000034FF  00000C07 R		DD do_LIT, 4, do_BEGIN@, do_TOR                   ; BEGIN1
	   00000004
	   00002D5E R
	   00000EB8 R
 0000350F  000002E8 R		DD do_TV2, do_FETCH, do_FETCH, do_BEXT
	   00000922 R
	   00000922 R
	   0000236E R
 0000351F  00000C07 R		DD do_LIT, 4, do_BEGIN@, do_TOR                   ; BEGIN2
	   00000004
	   00002D5E R
	   00000EB8 R
 0000352F  0000232D R		DD do_BTOH, PAD, do_ZCOUNT, do_TYPE, do_LIT, 32, do_EMIT
	   00001B96 R
	   0000140B R
	   0000220F R
	   00000C07 R
	   00000020
	   0000277C R
 0000354B  00000ED2 R		DD do_FROMR, do_1MINUS, do_DUP  
	   00000B5C R
	   00000C37 R
 00003557  00002D85 R		DD do_UNTIL@                                        ; UNTIL2
 0000355B  00000C22 R		DD do_DROP 
 0000355F  000002E8 R		DD do_TV2, do_DUP, do_FETCH, do_LIT, 4, do_PLUS, do_SWAP, do_STORE ; TV2 DUP @  4 + SWAP !
	   00000C37 R
	   00000922 R
	   00000C07 R
	   00000004
	   00000A79 R
	   00000C50 R
	   00000938 R
 0000357F  00000ED2 R		DD do_FROMR, do_1MINUS, do_DUP  
	   00000B5C R
	   00000C37 R
 0000358B  00002D85 R		DD do_UNTIL@                                        ; UNTIL1
 0000358F  00000C22 R		DD do_DROP, do_SEP1, do_ZCOUNT, do_TYPE
	   00000444 R
	   0000140B R
	   0000220F R
 0000359F  00000C07 R		DD do_LIT, 125, do_PAUSE
	   0000007D
	   0000309C R
 000035AB  000002E8 R		DD do_TV2, do_FETCH, do_LIT, 16, do_MINUS, do_LIT, 16, do_CTYPE
	   00000922 R
	   00000C07 R
	   00000010
	   00000A90 R
	   00000C07 R
	   00000010
	   00003443 R
 000035CB  00000444 R		DD do_SEP1, do_ZCOUNT, do_TYPE, do_CR
	   0000140B R
	   0000220F R
	   00001E01 R
 000035DB  00000ED2 R		DD do_FROMR, do_DUP, do_TV2, do_FETCH, do_MINUS, do_0GT
	   00000C37 R
	   000002E8 R
	   00000922 R
	   00000A90 R
	   0000101E R
 000035F3  00002D85 R		DD do_UNTIL@                                        ; UNTIL0
 000035F7  00000C22 R		DD do_DROP, do_CR
	   00001E01 R
 000035FF  00000862 R		DD do_SEMI
				;
 00003603			_FILEEXIST:         ; ( ADDR -- F )  0 = FILE EXIST   -1 = FILE NOT FOUND   VERIFIED 231213
 00003603  00003481 R		DD _DUMP
 00003607			FILEEXIST:
 00003607  00003616 R		DD do_FILEQ
 0000360B  00 0A 46 49 4C	DB 0, 10, 'FILEEXIST'
	   45 45 58 49 53
	   54
 00003616			do_FILEQ:
 00003616  68 00003620 R	PUSH $ + 10
 0000361B  E9 FFFFDFCA		JMP do_DOCOL
 00003620  00000C07 R		DD do_LIT, 80000000H, do_FILEOPEN, do_SWAP, do_DUP, do_0GT
	   80000000
	   000023DB R
	   00000C50 R
	   00000C37 R
	   0000101E R
 00003638  00001F4C R		DD do_IF@, do_FILECLOSE, do_DROP, do_ELSE@, do_NIP
	   0000241E R
	   00000C22 R
	   00001F88 R
	   00000CF1 R
 0000364C  00001FAC R		DD do_THEN@
 00003650  00000862 R		DD do_SEMI
				;
 00003654			_COMMENT1:                          ; VERIFIED 122322
 00003654  00003603 R		DD _FILEEXIST
 00003658  000015CB R		DD do_COLN
 0000365C  01 01 5C		DB 1, 1, '\'                        ; IMMEDIATE WORDS
 0000365F  00000C07 R		DD do_LIT, 13, do_PARSE, do_2DROP   ; ASSUMES INPUT BUFFER HAS BEEN PLACED ON STACK             
	   0000000D
	   000019DC R
	   00000FB9 R
 0000366F  00000862 R		DD do_SEMI
				;
 00003673			_COMMENT2:
 00003673  00003654 R		DD _COMMENT1
 00003677  000015CB R		DD do_COLN
 0000367B  01 01 28		DB 1, 1, '('                        ; IMMEDIATE WORDS
 0000367E  00000C07 R		DD do_LIT, 41, do_PARSE, do_2DROP   ; ASSUMES INPUT BUFFER HAS BEEN PLACED ON STACK  
	   00000029
	   000019DC R
	   00000FB9 R
 0000368E  00000862 R		DD do_SEMI
				;
 00003692			PRENUMB:                        ; ( ADDR LEN -- ADDR FLAG )   VERIFIED 231219
 00003692  00003673 R		DD _COMMENT2                    ; CHECKS TO SEE IF HEX CODE 'H' ON END OR 1ST CHAR > 9
 00003696  000036A4 R		DD do_PNUMBERP
 0000369A  00 08 28 4E 55	DB 0, 8, '(NUMBER)'
	   4D 42 45 52 29
 000036A4			do_PNUMBERP:
 000036A4  68 000036AE R	PUSH $ + 10
 000036A9  E9 FFFFDF3C		JMP do_DOCOL
 000036AE  00000C6F R		DD do_OVER, do_SWAP, do_1MINUS, do_PLUS, do_CFETCH, do_LIT, 'H', do_EQU
	   00000C50 R
	   00000B5C R
	   00000A79 R
	   0000097D R
	   00000C07 R
	   00000048
	   0000103B R
 000036CE  00000C50 R		DD do_SWAP, do_DUP, do_CFETCH, do_LIT, '9' , do_GT, do_ROT, do_OR
	   00000C37 R
	   0000097D R
	   00000C07 R
	   00000039
	   0000109B R
	   00000C88 R
	   0000149E R
 000036EE  00001CF5 R		DD do_NEWNUMB
 000036F2  00000862 R		DD do_SEMI
				;
 000036F6			_INTERPRET:                 ; VERIFIED 231221
 000036F6  00003692 R		DD PRENUMB
 000036FA			INTERPRET:
 000036FA  00003709 R		DD do_INTERPRET
 000036FE  00 09 49 4E 54	DB 0, 9, 'INTERPRET'
	   45 52 50 52 45
	   54
 00003709			do_INTERPRET:
 00003709  68 00003713 R	PUSH $ + 10
 0000370E  E9 FFFFDED7		JMP do_DOCOL
 00003713  000001DB R		DD do_FFLAG, do_FETCH                              ; FLAG = TRUE <>0 THEN EXECUTE
	   00000922 R
 0000371B  00001F4C R		DD do_IF@, do_EXECUTE     
	   00002006 R
 00003723  00001F88 R		DD do_ELSE@, NUMBER, do_EMSG, do_THEN@          ; ? NUMBER AVAILABLE ON STACK    
	   00002A55 R
	   00002018 R
	   00001FAC R
 00003733  00000862 R		DD do_SEMI
				;
 00003737			_BPA:    ; (  --  )
 00003737  000036F6 R		DD _INTERPRET
 0000373B			TOBPA:
 0000373B  000015CB R		DD do_COLN
 0000373F  00 04 3E 42 50	DB 0, 4, '>BPA'
	   41
				;PUSH $ + 10
				;JMP do_DOCOL
 00003745  00000211 R		DD do_NFA, do_FETCH, do_LIT, 2, do_MINUS, do_CFETCH
	   00000922 R
	   00000C07 R
	   00000002
	   00000A90 R
	   0000097D R
 0000375D  00001F4C R		DD do_IF@, do_EXECUTE, do_ELSE, do_COMMA, do_THEN@
	   00002006 R
	   00002C3F R
	   000027D0 R
	   00001FAC R
 00003771  00000862 R		DD do_SEMI
				;
 00003775			NUMBER@:   ;
 00003775  00003737 R		DD _BPA
 00003779			TONUMBER: 
 00003779  00003786 R		DD do_NUMBER@
 0000377D  00 07 3E 4E 55	DB 0, 7, '>NUMBER'
	   4D 42 45 52
 00003786			do_NUMBER@:
 00003786  68 00003790 R	PUSH $ + 10
 0000378B  E9 FFFFDE5A		JMP do_DOCOL
 00003790  00002A55 R		DD NUMBER, do_IF@, do_COMMA, do_THEN
	   00001F4C R
	   000027D0 R
	   00002C5F R
 000037A0  00000862 R		DD do_SEMI
				;
 000037A4			_LOAD:      ; ( ADDR LEN -- )  COMPILE FROM A FILE   WORK IN PROGRESS --  
 000037A4  00003775 R		DD NUMBER@
 000037A8  000015CB R		DD do_COLN
 000037AC  00 04 4C 4F 41	DB 0, 4, 'LOAD'
	   44
 000037B2			do_LOAD:
 000037B2  0000027C R		DD do_S_LEN, do_STORE, do_PUSH0, do_IN, do_STORE
	   00000938 R
	   000008D6 R
	   0000025F R
	   00000938 R
 000037C6  000004A4 R		DD do_S_ADR, do_STORE, do_STATE, do_ON, do_COMPF, do_ON
	   00000938 R
	   00000132 R
	   00001594 R
	   00000515 R
	   00001594 R
 000037DE  00002D5E R		DD do_BEGIN@
 000037E2  000004A4 R		DD do_S_ADR, do_FETCH, do_LIT, 32, do_WORD
	   00000922 R
	   00000C07 R
	   00000020
	   0000185D R
 000037F6  000013AB R		DD do_COUNT, do_2DUP, do_UPPERCASE, do_OVER, do_TYPE, do_CR, do_FIND        
	   00000F9A R
	   00001AC9 R
	   00000C6F R
	   0000220F R
	   00001E01 R
	   00001B38 R
 00003812  000001DB R		DD do_FFLAG, do_FETCH 
	   00000922 R
 0000381A  00001F4C R		DD do_IF@, TOBPA
	   0000373B R
 00003822  00001F88 R		DD do_ELSE@, do_NUMBER@
	   00003786 R
 0000382A  00001FAC R		DD do_THEN@
				;
 0000382E  0000027C R		DD do_S_LEN, do_FETCH, do_IN, do_FETCH, do_MINUS        ; S_LEN @ _IN @ - 
	   00000922 R
	   0000025F R
	   00000922 R
	   00000A90 R
 00003842  00002D85 R		DD do_UNTIL@
 00003846  00000132 R		DD do_STATE, do_OFF, do_COMPF, do_OFF
	   000015AF R
	   00000515 R
	   000015AF R
 00003856  00001E01 R		DD do_CR, TIB, do_S_ADR, do_STORE
	   00001CA3 R
	   000004A4 R
	   00000938 R
 00003866  000008D6 R		DD do_PUSH0, do_DUP, do_S_LEN, do_STORE, do_IN, do_STORE
	   00000C37 R
	   0000027C R
	   00000938 R
	   0000025F R
	   00000938 R
 0000387E  00000862 R		DD do_SEMI
				;
 00003882			_COLON:         ; 
 00003882  000037A4 R		DD _LOAD        ; Link File Addess (LFA) Pointer to previous words
 00003886  000015CB R		DD do_COLN      ; CFA - Code Field Address
 0000388A  00 01 3A		DB 0, 1, ':'       ; NFA - NAME FIELD
 0000388D			do_COLON:
 0000388D  00000132 R		DD do_STATE, do_FETCH, do_IF@, do_S_ADR, do_FETCH, do_ELSE@, TIB, do_THEN@
	   00000922 R
	   00001F4C R
	   000004A4 R
	   00000922 R
	   00001F88 R
	   00001CA3 R
	   00001FAC R
 000038AD  00000C07 R		DD do_LIT, 32, do_WORD, do_COUNT
	   00000020
	   0000185D R
	   000013AB R
 000038BD  00000F9A R		DD do_2DUP, do_UPPERCASE, do_DROP
	   00001AC9 R
	   00000C22 R
 000038C9  00001D28 R		DD do_NEWHEADER, do_GCFA, do_COLN, do_NFA, do_LIT, 4, do_MINUS,  do_STORE
	   00002312 R
	   000015CB R
	   00000211 R
	   00000C07 R
	   00000004
	   00000A90 R
	   00000938 R
 000038E9  00000862 R		DD do_SEMI
				;
 000038ED			_LASTNFA:           ; (  -- NFA ) RETURNS NFA ADDRESS OF LAST WORD CREATED VERIFIED 231227
 000038ED  00003882 R		DD _COLON
 000038F1			LASTNFA: 
 000038F1  000038FE R		DD do_LASTNFA
 000038F5  00 07 4C 41 53	DB 0, 7, 'LASTNFA'
	   54 4E 46 41
 000038FE			do_LASTNFA:
 000038FE  68 00003908 R	PUSH $ + 10
 00003903  E9 FFFFDCE2		JMP do_DOCOL
 00003908  000008ED R		DD do_LAST, do_LIT, 9, do_PLUS
	   00000C07 R
	   00000009
	   00000A79 R
 00003918  00000862 R		DD do_SEMI
				;
 0000391C			_LOADFILE1:
 0000391C  000038ED R		DD _LASTNFA
 00003920			LOADFILE1: 
 00003920  0000392F R		DD do_ARRBLD
 00003924  00 09 4C 4F 41	DB 0, 9, 'LOADFILE1'
	   44 46 49 4C 45
	   31
 0000392F			do_ARRBLD:
 0000392F  68 00003939 R	PUSH $ + 10
 00003934  E9 FFFFDCB1		JMP do_DOCOL
 00003939  000008D6 R		DD do_PUSH0, do_STATE, do_ON, do_VALUE
	   00000132 R
	   00001594 R
	   0000292F R
 00003949  46 48 31		DB 'FH1'
 0000394C  00000132 R		DD do_STATE, do_OFF
	   000015AF R
 00003954  00000552 R		DD do_MsgF1, do_PUSH0, do_LIT, -2147483648, do_FILEOPEN
	   000008D6 R
	   00000C07 R
	   80000000
	   000023DB R
 00003968  00000C22 R		DD do_DROP, do_FILECLOSE, do_DROP
	   0000241E R
	   00000C22 R
 00003974  00000862 R		DD do_SEMI
				;
 00003978			_TESTING:
 00003978  0000391C R		DD _LOADFILE1
 0000397C			TEST1: 
 0000397C  00003987 R		DD TESTING
 00003980  00 05 54 45 53	DB 0, 5, 'TEST1'
	   54 31
 00003987			TESTING:
 00003987  68 00003991 R	PUSH $ + 10
 0000398C  E9 FFFFDC59		JMP do_DOCOL
 00003991  00000C07 R		DD do_LIT, 35, TV1@, do_STORE
	   00000023
	   00000EAF R
	   00000938 R
 000039A1  00000862 R		DD do_SEMI
				;
 000039A5			_COMPILEC:
 000039A5  00003978 R		DD _TESTING
 000039A9			COMPILEC: 
 000039A9  000015CB R		DD do_COLN
 000039AD  00 08 43 4F 4D	DB 0, 8, 'COMPILE,'
	   50 49 4C 45 2C
 000039B7  0000090B R		DD do_COMPILE
 000039BB  000027D0 R		DD do_COMMA
 000039BF  00000862 R		DD do_SEMI
				;
 000039C3			EOC:
				; #########################################################################
				;
 00000000			.data ; Data Section
				;
 00000000 44 53 42 55 46	DSB db 'DSBUFFER', 32 dup (0H) ; A buffer between the data stack and return stack
	   46 45 52
	   00000020 [
	    00
	   ]
 00000028  00000400 [		R0 db 1024 dup (0H) ; Return Stack Base of size 1024 
	    00
	   ]
 00000428 52 53 42 55 46	RSB db 'RSBUFFER', 32 dup (0H) ; Buffer between return stack and CONTROL STACK
	   46 45 52
	   00000020 [
	    00
	   ]
 00000450  00000400 [		C0 db 1024 DUP (0H) ; CONTROL WORDS STACK
	    00
	   ]
 00000850 43 53 42 55 46	CSB db 'CSBUFFER', 32 DUP (0H) ; Buffer between CONTROL stack and data area
	   46 45 52
	   00000020 [
	    00
	   ]
				; PAD db 160 dup (0H) ; Output buffer
				; TIB db 160 dup (0H) ; Input buffer
 00000878  000000A0 [		POC db 160 dup (0H) ; Pocket 
	    00
	   ]
				; SCRATCH db 160 DUP (0H) ; SCRATCH PAD FOR CONVERSIONS
 00000918  00000004 [		_SYSTIME DD 4 dup (0H) ; SYSTEM TIME  SEE STRUCTURE IN NOTES ABOVE 
	    00000000
	   ]
				; -----------------------------
 00000928 00000000		_EDI DD 0
 0000092C 00000000		_hMemory DD 0
 00000930 00000000		_IN DD 0
 00000934 00000000		_1IN DD 0
 00000938 00001CA3 R		_SOURCE DD TIB, 0
	   00000000
 00000940 00000000		ABORTFLAG DD 0
 00000944 0000000A		BASE DD 10          ; NUMERIC BASE IN USE DECIMAL IS DEFAULT
 00000948 00000001		BYEFLAG DD 1        ; EXIT FLAG
 0000094C 00000000		CFA DD 0            ; CODE FIELD ADDRESS
 00000950 00000000		COMPFQ DD 0         ; COMPILE FLAG = 1 IN COMPILE MODE
 00000954 0000084F R		CSP DD C0 + 1023    ; CONTROL STACK POINTER
 00000958 00000000		CURRENT DD 0
 0000095C 00000000		DCW DD 0            ; DICTIONARY WORD COUNT
 00000960 00000000		DOUBLEQ DD 0        ; double value
 00000964 FFFFFFFF		DPLOCATION DD -1    ; decimal point location
 00000968 00000000		DPR DD 0            ; END OF DICTIONARY POINTER
 0000096C 00000000		FCOUNTER DD 0       ; FIND COUNTER
 00000970 00000000		FFLAG DD 0          ; FIND FLAG
 00000974 00000000		gone dd 0
 00000978 00001B96 R		HLD DD PAD
 0000097C 00000000		KEYIN DD 0
 00000980 00000000		LATEST DD 0         ; LAST WORD IN DICTIONARY
 00000984 00000000		LFA DD 0            ; LINK FIELD ADDRESS
 00000988 00000000		MALLOCHADDR DD 0   ; heap address
 0000098C 00000000		MALLOCLINK  DD 0   ; head of single linked list
 00000990 00000104		MAXBUFFER DD 260
 00000994 000000FF		MAXCOUNTED DD 255
 00000998 000000FF		MAXSTRING DD 255
 0000099C 00011ECE R		MEMLIMIT DD USER_BASE+(1024*64)
 000009A0 00000000		NFA DD 0        ; NAME FIELD ADDRESS
 000009A4 00000000		PFA DD 0        ; PARAMETER FIELD ADDRESS
 000009A8 00000000		pMem DD 0
 000009AC 00000878 R		POCKET DD POC
 000009B0 00001EC1 R		PREVIOUS DD EOD
 000009B4 00000427 R		RSP DD R0 + 1023 ; RETURN STACK POINTER
 000009B8 00001CA3 R		S_ADR DD TIB
 000009BC 00000000		S1_ADR DD 0
 000009C0 00000000		SIGNFLAG DD 0
 000009C4 00000000		S_LEN DD 0
 000009C8 00000000		S1_LEN DD 0
 000009CC 00000008		SMAX DD 8
 000009D0 00000000		S0 DD 0         ; Stack base starting point pointer
 000009D4 00000000		STACKERROR DD 0 ; STACK STATUS
 000009D8 00000000		STATE DD 0      ; INTERPRETIVE OR COMPILE  0/1
 000009DC 00000000		TV1 DD 0        ; TEMPORARY VARIABLES
 000009E0 00000000		TV2 DD 0
 000009E4 00000000		TV3 DD 0
 000009E8 00000000		TV$ DD 0
 000009EC 00000000		VENUMQ DD 0
 000009F0 00000000		xpos DD 0       ; SCREEN COORDINATES
 000009F4 00000000		ypos DD 0
				; -----------------------------
 000009F8 20 20 20 20 20	Msg1 db  '        Fig-Forth vs 2.51', 13, 10, 0h
	   20 20 20 46 69
	   67 2D 46 6F 72
	   74 68 20 76 73
	   20 32 2E 35 31
	   0D 0A 00
 00000A14 20 20 20 20 20	Msg1A db '            FJRusso', 13, 10, 0h
	   20 20 20 20 20
	   20 20 46 4A 52
	   75 73 73 6F 0D
	   0A 00
 00000A2A 20 20 20 20 53	Msg2 db  '    Saturday, December 30, 2023' , 13, 10, 0h
	   61 74 75 72 64
	   61 79 2C 20 44
	   65 63 65 6D 62
	   65 72 20 33 30
	   2C 20 32 30 32
	   33 0D 0A 00
 00000A4C 20 73 64 66 6A	Msg3 db ' sdfj rjsdl; fFDKJ;SDFORSJ 34854356 lksirn 54kvf 35kfg ', 0h ; NOT USED
	   20 72 6A 73 64
	   6C 3B 20 66 46
	   44 4B 4A 3B 53
	   44 46 4F 52 53
	   4A 20 33 34 38
	   35 34 33 35 36
	   20 6C 6B 73 69
	   72 6E 20 35 34
	   6B 76 66 20 33
	   35 6B 66 67 20
	   00
 00000A84 20 41 49 46 56	Msg4 db ' AIFVJOI FAOJ AVFAO VOI54 fghgfh6U04R NFRRdfgbbgV NARV ', 0h ; NOT USED
	   4A 4F 49 20 46
	   41 4F 4A 20 41
	   56 46 41 4F 20
	   56 4F 49 35 34
	   20 66 67 68 67
	   66 68 36 55 30
	   34 52 20 4E 46
	   52 52 64 66 67
	   62 62 67 56 20
	   4E 41 52 56 20
	   00
 00000ABC 20 54 65 78 74	Msg5 db ' Text Interpreter entered ', 0h
	   20 49 6E 74 65
	   72 70 72 65 74
	   65 72 20 65 6E
	   74 65 72 65 64
	   20 00
 00000AD7 20 6F 6B 0D 0A	Msg6 db ' ok', 13, 10, 0h
	   00
 00000ADD 20 77 61 69 74	Msg7 db ' wait key -- ', 0h
	   20 6B 65 79 20
	   2D 2D 20 00
 00000AEB 20 45 78 69 74	Msg8 db ' Exiting FORTH', 13, 10, 0h
	   69 6E 67 20 46
	   4F 52 54 48 0D
	   0A 00
 00000AFC 20 46 69 67 20	Msg9 db ' Fig Forth Begining', 0h
	   46 6F 72 74 68
	   20 42 65 67 69
	   6E 69 6E 67 00
 00000B10 20 45 52 52 4F	Msg10 db ' ERROR OCCURED - ', 0h
	   52 20 4F 43 43
	   55 52 45 44 20
	   2D 20 00
 00000B22 20 2D 20 4E 4F	Msg11 db ' - NOT FOUND', 13, 10, 0h
	   54 20 46 4F 55
	   4E 44 0D 0A 00
 00000B31 20 44 61 74 61	Msg12 db ' Data Section - ', 0h
	   20 53 65 63 74
	   69 6F 6E 20 2D
	   20 00
 00000B42 20 43 6F 72 65	Msg13 db ' Core Space - ', 0h
	   20 53 70 61 63
	   65 20 2D 20 00
 00000B51 20 41 70 70 6C	Msg14 db ' Appl Space - ', 0h
	   20 53 70 61 63
	   65 20 2D 20 00
 00000B60 20 62 79 74 65	Msg15 db ' bytes used', 13, 10, 0h
	   73 20 75 73 65
	   64 0D 0A 00
 00000B6E 20 62 79 74 65	Msg16 db ' bytes free', 13, 10, 0h
	   73 20 66 72 65
	   65 0D 0A 00
 00000B7C 20 57 6F 72 64	Msg17 db ' Words in Dictionary - ',0h
	   73 20 69 6E 20
	   44 69 63 74 69
	   6F 6E 61 72 79
	   20 2D 20 00
 00000B94 20 46 61 69 6C	Msg18 db ' Failure to Allocate memory', 13, 10, 0h
	   75 72 65 20 74
	   6F 20 41 6C 6C
	   6F 63 61 74 65
	   20 6D 65 6D 6F
	   72 79 0D 0A 00
 00000BB2 20 50 72 6F 63	Msg19 db ' Process ABORTED ', 13, 10, 0h
	   65 73 73 20 41
	   42 4F 52 54 45
	   44 20 0D 0A 00
 00000BC6 20 50 72 65 73	Msg20 db ' Press ENTER to continue --- ', 0h
	   73 20 45 4E 54
	   45 52 20 74 6F
	   20 63 6F 6E 74
	   69 6E 75 65 20
	   2D 2D 2D 20 00
 00000BE4 20 50 72 6F 63	Msg21 db ' Process Terminated', 0H
	   65 73 73 20 54
	   65 72 6D 69 6E
	   61 74 65 64 00
 00000BF8 20 53 74 61 63	Msg22 db ' Stack Underflow ERROR', 0H
	   6B 20 55 6E 64
	   65 72 66 6C 6F
	   77 20 45 52 52
	   4F 52 00
 00000C0F 20 53 74 61 63	Msg23 db ' Stack Overflow ERROR', 0H
	   6B 20 4F 76 65
	   72 66 6C 6F 77
	   20 45 52 52 4F
	   52 00
				;
 00000C25 20 3F 20 00		MsgQ db ' ? ', 0H
 00000C29 62 75 69 6C 64	MsgF1 db 'build-array.f', 0H
	   2D 61 72 72 61
	   79 2E 66 00
 00000C37 20 65 6D 70 74	Mempty db ' empty ', 0h
	   79 20 00
 00000C3F 0D 0A 00		crlf$ db 13, 10, 0h
 00000C42 20 7C 20 00		SEP1$ db ' | ', 0h
 00000C46 20 00			SPACE$ db 20H,0H
 00000C48 30 31 32 33 34	HEX_TABLE db "0123456789ABCDEF"
	   35 36 37 38 39
	   41 42 43 44 45
	   46
 00000C58 20 30 31 2F 30	%Date       db  " &@Date ", 0H      ; DATE Compiled
	   31 2F 32 34 20
	   00
 00000C63 20 31 37 3A 34	%Time       db  " &@Time", 0H       ; TIME Compiled
	   32 3A 35 38 00
				;
 00000C6D 20 4E 6F 20 45	MESSAGES DB ' No Errors ', 13, 10, 0h,
	   72 72 6F 72 73
	   20 0D 0A 00 20
	   20 20 20 20 20
	   20 20 46 69 67
	   2D 46 6F 72 74
	   68 20 76 73 20
	   32 2E 35 31 0D
	   0A 00 20 20 20
	   20 20 20 20 20
	   20 20 20 20 46
	   4A 52 75 73 73
	   6F 0D 0A 00 20
	   20 20 20 20 54
	   68 75 72 73 64
	   61 79 2C 20 44
	   65 63 65 6D 62
	   65 72 20 32 38
	   2C 20 32 30 32
	   33 0D 0A 00 20
	   73 64 66 6A 20
	   72 6A 73 64 6C
	   3B 20 66 46 44
	   4B 4A 3B 53 44
	   46 4F 52 53 4A
	   20 33 34 38 35
	   34 33 35 36 20
	   6C 6B 73 69 72
	   6E 20 35 34 6B
	   76 66 20 33 35
	   6B 66 67 20 00
	   20 41 49 46 56
	   4A 4F 49 20 46
	   41 4F 4A 20 41
	   56 46 41 4F 20
	   56 4F 49 35 34
	   20 66 67 68 67
	   66 68 36 55 30
	   34 52 20 4E 46
	   52 52 64 66 67
	   62 62 67 56 20
	   4E 41 52 56 20
	   00 20 54 65 78
	   74 20 49 6E 74
	   65 72 70 72 65
	   74 65 72 20 65
	   6E 74 65 72 65
	   64 20 00 20 6F
	   6B 0D 0A 00 20
	   77 61 69 74 20
	   6B 65 79 20 2D
	   2D 20 00 20 45
	   78 69 74 69 6E
	   67 20 46 4F 52
	   54 48 0D 0A 00
	   20 46 69 67 20
	   46 6F 72 74 68
	   20 42 65 67 69
	   6E 69 6E 67 00
	   20 45 52 52 4F
	   52 20 4F 43 43
	   55 52 45 44 20
	   2D 20 00
				 '        Fig-Forth vs 2.51', 13, 10, 0h,
				 '            FJRusso', 13, 10, 0h,
				 '     Thursday, December 28, 2023' , 13, 10, 0h,
				 ' sdfj rjsdl; fFDKJ;SDFORSJ 34854356 lksirn 54kvf 35kfg ', 0h, ; NOT USED
				 ' AIFVJOI FAOJ AVFAO VOI54 fghgfh6U04R NFRRdfgbbgV NARV ', 0h, ; NOT USED
				 ' Text Interpreter entered ', 0h,
				 ' ok', 13, 10, 0h,
				 ' wait key -- ', 0h,
				 ' Exiting FORTH', 13, 10, 0h,
				 ' Fig Forth Begining', 0h,
				 ' ERROR OCCURED - ', 0h
 00000DA6 04 20 2D 20 4E	 MESSAGES2 DB ,
	   4F 54 20 46 4F
	   55 4E 44 0D 0A
	   00 20 44 61 74
	   61 20 53 65 63
	   74 69 6F 6E 20
	   2D 20 00 20 43
	   6F 72 65 20 53
	   70 61 63 65 20
	   2D 20 00 20 41
	   70 70 6C 20 53
	   70 61 63 65 20
	   2D 20 00 20 62
	   79 74 65 73 20
	   75 73 65 64 0D
	   0A 00 20 62 79
	   74 65 73 20 66
	   72 65 65 0D 0A
	   00 20 57 6F 72
	   64 73 20 69 6E
	   20 44 69 63 74
	   69 6F 6E 61 72
	   79 20 2D 20 00
	   20 46 61 69 6C
	   75 72 65 20 74
	   6F 20 41 6C 6C
	   6F 63 61 74 65
	   20 6D 65 6D 6F
	   72 79 0D 0A 00
	   20 50 72 6F 63
	   65 73 73 20 41
	   42 4F 52 54 45
	   44 20 0D 0A 00
	   20 50 72 65 73
	   73 20 45 4E 54
	   45 52 20 74 6F
	   20 63 6F 6E 74
	   69 6E 75 65 20
	   2D 2D 2D 20 00
	   20 50 72 6F 63
	   65 73 73 20 54
	   65 72 6D 69 6E
	   61 74 65 64 00
	   20 53 74 61 63
	   6B 20 55 6E 64
	   65 72 66 6C 6F
	   77 20 45 52 52
	   4F 52 00 20 53
	   74 61 63 6B 20
	   4F 76 65 72 66
	   6C 6F 77 20 45
	   52 52 4F 52 00
	   00
				 ' - NOT FOUND', 13, 10, 0h,
				 ' Data Section - ', 0h,
				 ' Core Space - ', 0h,
				 ' Appl Space - ', 0h,
				 ' bytes used', 13, 10, 0h,
				 ' bytes free', 13, 10, 0h,
				 ' Words in Dictionary - ',0h,
				 ' Failure to Allocate memory', 13, 10, 0h,
				 ' Process ABORTED ', 13, 10, 0h,
				 ' Press ENTER to continue --- ', 0h,
				 ' Process Terminated', 0H,
				 ' Stack Underflow ERROR', 0H,
				 ' Stack Overflow ERROR', 0H, 0H
				;
				; ********************
				; VARIABLES, CONSTANTS & VALUES 
				; ********************
 00000EAB 000039A5 R		_TV1@  DD _COMPILEC 
 00000EAF 00001629 R		TV1@ DD do_DOVAR
 00000EB3  00 04 54 56 31	DB 0, 4, 'TV1@'
	   40
 00000EB9  00000000		DD 0
				;
 00000EBD 00000EAB R		_TV2@  DD _TV1@ 
 00000EC1 00001629 R		TV2@ DD do_DOVAR
 00000EC5  00 04 54 56 32	DB 0, 4, 'TV2@'
	   40
 00000ECB  00000000		DD 0
				;
 00000ECF 00000EBD R		_TV3@  DD _TV2@ 
 00000ED3 00001629 R		TV3@ DD do_DOVAR
 00000ED7  00 04 54 56 33	DB 0, 4, 'TV3@'
	   40
 00000EDD  00000000		DD 0
				;
 00000EE1 00000ECF R		_SPACE DD _TV3@                  
 00000EE5 00001665 R		SPACE DD do_DOCON
 00000EE9  01 05 53 50 41	DB 1, 5, 'SPACE'
	   43 45
 00000EF0  00000020		DD 32
				;
 00000EF4 00000EE1 R		_BL DD _SPACE                   
 00000EF8 00001665 R		BLK DD do_DOCON
 00000EFC  01 03 42 4C 4B	DB 1, 3, 'BLK'
 00000F01  00000020		DD 32
				;
 00000F05 00000EF4 R		_FH1 DD _BL
 00000F09 0000292F R		FH1 DD do_VALUE
 00000F0D  00 03 46 48 31	DB 0, 3, 'FH1'
 00000F12  00000000		DD 0
				;
 00000F16 00000F05 R		_FH2 DD _FH1
 00000F1A 0000292F R		FH2 DD do_VALUE
 00000F1E  00 03 46 48 32	DB 0, 3, 'FH2'
 00000F23  00000000		DD 0
				;
 00000F27 00000F16 R		_FH3 DD _FH2
 00000F2B 0000292F R		FH3 DD do_VALUE
 00000F2F  00 03 46 48 32	DB 0, 3, 'FH2'
 00000F34  00000000		DD 0
				; ********************
				;  SYSTEM BUFFER AREA
				; ********************
 00000F38 00000F27 R		_FS1 DD _FH3     ; FILE 1 SIZE
 00000F3C 000016A0 R		FS1 DD do_DOVALUE
 00000F40  00 03 46 53 31	DB 0, 3, 'FS1'
 00000F45  00000000		DD 0
				;
 00000F49 00000F38 R		_FS2 DD _FS1     ; FILE 2 SIZE
 00000F4D 000016A0 R		FS2 DD do_DOVALUE
 00000F51  00 03 46 53 32	DB 0, 3, 'FS2'
 00000F56  00000000		DD 0
				;
 00000F5A 00000F49 R		_FS3 DD _FS2     ; FILE 3 SIZE
 00000F5E 000016A0 R		FS3 DD do_DOVALUE
 00000F62  00 03 46 53 33	DB 0, 3, 'FS3'
 00000F67  00000000		DD 0
				;
 00000F6B 00000F5A R		_FB1 DD _FS3     ; FILE 1 BUFFER
 00000F6F 00001629 R		FB1 DD do_DOVAR
 00000F73  00 03 46 42 31	DB 0, 3, 'FB1'
 00000F78  00000400 [		DB 1024 DUP (0H)
	    00
	   ]
				;
 00001378 00000F6B R		_FB2 DD _FB1     ; FILE 2 BUFFER
 0000137C 00001629 R		FB2 DD do_DOVAR
 00001380  00 03 46 42 32	DB 0, 3, 'FB2'
 00001385  00000400 [		DB 1024 DUP (0H)
	    00
	   ]
				;
 00001785 00001378 R		_FB3 DD _FB2     ; FILE 3 BUFFER
 00001789 00001629 R		FB3 DD do_DOVAR
 0000178D  00 03 46 42 33	DB 0, 3, 'FB3'
 00001792  00000400 [		DB 1024 DUP (0H)
	    00
	   ]
				;
 00001B92 00001785 R		_PAD DD _FB3     ; OUTPUT BUFFER
 00001B96 00001629 R		PAD DD do_DOVAR
 00001B9A  00 03 50 41 44	DB 0, 3, 'PAD'
 00001B9F  00000100 [		DB 256 DUP (0H)
	    00
	   ]
				;
 00001C9F 00001B92 R		_TIB DD _PAD     ; INPUT BUFFER
 00001CA3 00001629 R		TIB DD do_DOVAR
 00001CA7  00 03 54 49 42	DB 0, 3, 'TIB'
 00001CAC  00000100 [		DB 256 DUP (0H)
	    00
	   ]
				;
 00001DAC 00001C9F R		_SCRATCH DD _TIB       ; SCRATCH PAD FOR CONVERSIONS
 00001DB0 00001629 R		SCRATCH DD do_DOVAR
 00001DB4  00 07 53 43 52	DB 0, 7, 'SCRATCH'
	   41 54 43 48
 00001DBD  00000100 [		DB 256 DUP (0H)
	    00
	   ]
				;
 00001EBD 00001DAC R		_EOD DD _SCRATCH
 00001EC1 000016A0 R		EOD DD do_DOVALUE
 00001EC5  00 03 45 4F 44	DB 0, 3, 'EOD'
 00001ECA  00000000		DD 0
				;
 00001ECE 00000000		USER_BASE DD 0
 00001ED2  00003FEC [		DD 16364 dup (0H); Start of USER Area Dictionary 64k
	    00000000
	   ]

				END Start
				; #########################################################################
Microsoft (R) Macro Assembler Version 6.14.8444		    01/01/24 17:42:58
C:\Users\fjrus\source\repos\Fig-Forth\Fig-Forth.asm	     Symbols 2 - 1




Macros:

                N a m e                 Type

BRNEXT . . . . . . . . . . . . .	Proc
NEXTC  . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

RUN_SYNCH_PROCESS_EX . . . . . .	 00000014
  priority . . . . . . . . . . .	 00000000	 DWord
  timeout  . . . . . . . . . . .	 00000004	 DWord
  rvcreate . . . . . . . . . . .	 00000008	 DWord
  exitcode . . . . . . . . . . .	 0000000C	 DWord
  rvwait . . . . . . . . . . . .	 00000010	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00011E82 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000039C3 Para	  Public  'CODE'	

Symbols:

                N a m e                 Type     Value    Attr

@@01 . . . . . . . . . . . . . .	L Near	 00001B92 _TEXT	
@@10MX . . . . . . . . . . . . .	L Near	 000011C5 _TEXT	
@@11A  . . . . . . . . . . . . .	L Near	 00001F31 _TEXT	
@@1A . . . . . . . . . . . . . .	L Near	 00000CDD _TEXT	
@@1B . . . . . . . . . . . . . .	L Near	 000018A0 _TEXT	
@@1C . . . . . . . . . . . . . .	L Near	 00001957 _TEXT	
@@1D . . . . . . . . . . . . . .	L Near	 00001A03 _TEXT	
@@1E . . . . . . . . . . . . . .	L Near	 00001A56 _TEXT	
@@1F . . . . . . . . . . . . . .	L Near	 00001BEC _TEXT	
@@1HV  . . . . . . . . . . . . .	L Near	 00001FD1 _TEXT	
@@1H . . . . . . . . . . . . . .	L Near	 00001C61 _TEXT	
@@1K . . . . . . . . . . . . . .	L Near	 00001E30 _TEXT	
@@1L . . . . . . . . . . . . . .	L Near	 00001E6B _TEXT	
@@1MN  . . . . . . . . . . . . .	L Near	 0000116C _TEXT	
@@1MX  . . . . . . . . . . . . .	L Near	 000011A7 _TEXT	
@@1M . . . . . . . . . . . . . .	L Near	 00001EA2 _TEXT	
@@1SDJ . . . . . . . . . . . . .	L Near	 00001445 _TEXT	
@@1UMN . . . . . . . . . . . . .	L Near	 0000114F _TEXT	
@@1UMX . . . . . . . . . . . . .	L Near	 0000118A _TEXT	
@@1  . . . . . . . . . . . . . .	L Near	 00001083 _TEXT	
@@2B . . . . . . . . . . . . . .	L Near	 000018B4 _TEXT	
@@2C . . . . . . . . . . . . . .	L Near	 0000196E _TEXT	
@@2E . . . . . . . . . . . . . .	L Near	 00001A66 _TEXT	
@@2H . . . . . . . . . . . . . .	L Near	 00001C74 _TEXT	
@@3B . . . . . . . . . . . . . .	L Near	 000018B6 _TEXT	
@@3C . . . . . . . . . . . . . .	L Near	 00001970 _TEXT	
@@3D . . . . . . . . . . . . . .	L Near	 00001A05 _TEXT	
@@3E . . . . . . . . . . . . . .	L Near	 00001A77 _TEXT	
@@3H . . . . . . . . . . . . . .	L Near	 00001C9E _TEXT	
@@4B . . . . . . . . . . . . . .	L Near	 000018C6 _TEXT	
@@4C . . . . . . . . . . . . . .	L Near	 00001985 _TEXT	
@@4D . . . . . . . . . . . . . .	L Near	 00001A15 _TEXT	
@@4E . . . . . . . . . . . . . .	L Near	 00001A67 _TEXT	
@@4H . . . . . . . . . . . . . .	L Near	 00001CA7 _TEXT	
@@5A . . . . . . . . . . . . . .	L Near	 000018CD _TEXT	
@@5F . . . . . . . . . . . . . .	L Near	 00001C2E _TEXT	
@@6A . . . . . . . . . . . . . .	L Near	 000018D7 _TEXT	
@@6F1  . . . . . . . . . . . . .	L Near	 00001C10 _TEXT	
@@6F . . . . . . . . . . . . . .	L Near	 00001B9A _TEXT	
@@7A . . . . . . . . . . . . . .	L Near	 000018E8 _TEXT	
@@7C . . . . . . . . . . . . . .	L Near	 0000198A _TEXT	
@@7D . . . . . . . . . . . . . .	L Near	 00001A1A _TEXT	
@@8A . . . . . . . . . . . . . .	L Near	 00001904 _TEXT	
@@8C . . . . . . . . . . . . . .	L Near	 0000199A _TEXT	
@@8D . . . . . . . . . . . . . .	L Near	 00001A2B _TEXT	
@@9A . . . . . . . . . . . . . .	L Near	 0000189C _TEXT	
@@EXIT . . . . . . . . . . . . .	L Near	 000000A8 _TEXT	
@@W1 . . . . . . . . . . . . . .	L Near	 0000186E _TEXT	
@@loopA  . . . . . . . . . . . .	L Near	 00001EDD _TEXT	
@@loopB2H  . . . . . . . . . . .	L Near	 00002344 _TEXT	
@@loopB  . . . . . . . . . . . .	L Near	 00001EF4 _TEXT	
@@loop . . . . . . . . . . . . .	L Near	 00001EF1 _TEXT	
@ACCEPT  . . . . . . . . . . . .	L Near	 00000030 _TEXT	
@BU  . . . . . . . . . . . . . .	L Near	 00002D99 _TEXT	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DLOOP1  . . . . . . . . . . . .	L Near	 00003493 _TEXT	
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@EMSG  . . . . . . . . . . . . .	L Near	 0000204D _TEXT	
@IF1a  . . . . . . . . . . . . .	L Near	 00001F6E _TEXT	
@IF1 . . . . . . . . . . . . . .	L Near	 00001F71 _TEXT	
@IF  . . . . . . . . . . . . . .	L Near	 00001F59 _TEXT	
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@NEWNUMB . . . . . . . . . . . .	L Near	 00001D0A _TEXT	
@QS1 . . . . . . . . . . . . . .	L Near	 000022E2 _TEXT	
@QS2 . . . . . . . . . . . . . .	L Near	 000022F3 _TEXT	
@WDC1  . . . . . . . . . . . . .	L Near	 00002295 _TEXT	
@WDC2  . . . . . . . . . . . . .	L Near	 000022A3 _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ABORTFLAG  . . . . . . . . . . .	DWord	 00000940 _DATA	
ABORT  . . . . . . . . . . . . .	L Near	 00000008 _TEXT	
ACCEPT . . . . . . . . . . . . .	L Near	 00002F6E _TEXT	
ADDNULL  . . . . . . . . . . . .	L Near	 00001454 _TEXT	
ALLOT  . . . . . . . . . . . . .	L Near	 0000310F _TEXT	
ANEW . . . . . . . . . . . . . .	L Near	 00003255 _TEXT	
AddAtom  . . . . . . . . . . . .	Text   	 AddAtomA
AddLocalAlternateComputerName  .	Text   	 AddLocalAlternateComputerNameA
BASE . . . . . . . . . . . . . .	DWord	 00000944 _DATA	
BLANK  . . . . . . . . . . . . .	L Near	 00001803 _TEXT	
BLK  . . . . . . . . . . . . . .	DWord	 00000EF8 _DATA	
BODYOFF  . . . . . . . . . . . .	L Near	 00001834 _TEXT	
BYEFLAG  . . . . . . . . . . . .	DWord	 00000948 _DATA	
BYE  . . . . . . . . . . . . . .	L Near	 00002158 _TEXT	
BeginUpdateResource  . . . . . .	Text   	 BeginUpdateResourceA
BuildCommDCBAndTimeouts  . . . .	Text   	 BuildCommDCBAndTimeoutsA
BuildCommDCB . . . . . . . . . .	Text   	 BuildCommDCBA
C0 . . . . . . . . . . . . . . .	Byte	 00000450 _DATA	
CDECR  . . . . . . . . . . . . .	L Near	 0000156A _TEXT	
CELLMINUS  . . . . . . . . . . .	L Near	 00000DDB _TEXT	
CELLPLUS . . . . . . . . . . . .	L Near	 00000DC0 _TEXT	
CELLSMINUS . . . . . . . . . . .	L Near	 00000D9D _TEXT	
CELLSPLUS  . . . . . . . . . . .	L Near	 00000D80 _TEXT	
CFA  . . . . . . . . . . . . . .	DWord	 0000094C _DATA	
CFETCH . . . . . . . . . . . . .	L Near	 00000971 _TEXT	
CHARPLUS . . . . . . . . . . . .	L Near	 00000A53 _TEXT	
CINCR  . . . . . . . . . . . . .	L Near	 0000154C _TEXT	
CLS  . . . . . . . . . . . . . .	L Near	 00001DDC _TEXT	
CMAX0  . . . . . . . . . . . . .	L Near	 000023C1 _TEXT	
COLD . . . . . . . . . . . . . .	L Near	 000005A1 _TEXT	
COMPFQ . . . . . . . . . . . . .	DWord	 00000950 _DATA	
COMPILEC . . . . . . . . . . . .	L Near	 000039A9 _TEXT	
COMPILE  . . . . . . . . . . . .	L Near	 000008FE _TEXT	
COUNT  . . . . . . . . . . . . .	L Near	 0000139C _TEXT	
CPLUSSTORE . . . . . . . . . . .	L Near	 000009A0 _TEXT	
CR . . . . . . . . . . . . . . .	L Near	 00001DF5 _TEXT	
CSB  . . . . . . . . . . . . . .	Byte	 00000850 _DATA	
CSP  . . . . . . . . . . . . . .	DWord	 00000954 _DATA	
CSTORE . . . . . . . . . . . . .	L Near	 00000989 _TEXT	
CTYPE  . . . . . . . . . . . . .	L Near	 00003438 _TEXT	
CURRENT  . . . . . . . . . . . .	DWord	 00000958 _DATA	
CallNamedPipe  . . . . . . . . .	Text   	 CallNamedPipeA
CheckNameLegalDOS8Dot3 . . . . .	Text   	 CheckNameLegalDOS8Dot3A
CommConfigDialog . . . . . . . .	Text   	 CommConfigDialogA
CompareString  . . . . . . . . .	Text   	 CompareStringA
CopyFileEx . . . . . . . . . . .	Text   	 CopyFileExA
CopyFile . . . . . . . . . . . .	Text   	 CopyFileA
CreateActCtx . . . . . . . . . .	Text   	 CreateActCtxA
CreateDirectoryEx  . . . . . . .	Text   	 CreateDirectoryExA
CreateDirectory  . . . . . . . .	Text   	 CreateDirectoryA
CreateEvent  . . . . . . . . . .	Text   	 CreateEventA
CreateFileMapping  . . . . . . .	Text   	 CreateFileMappingA
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
CreateHardLink . . . . . . . . .	Text   	 CreateHardLinkA
CreateJobObject  . . . . . . . .	Text   	 CreateJobObjectA
CreateMailslot . . . . . . . . .	Text   	 CreateMailslotA
CreateMutex  . . . . . . . . . .	Text   	 CreateMutexA
CreateNamedPipe  . . . . . . . .	Text   	 CreateNamedPipeA
CreateProcess  . . . . . . . . .	Text   	 CreateProcessA
CreateSemaphore  . . . . . . . .	Text   	 CreateSemaphoreA
CreateWaitableTimer  . . . . . .	Text   	 CreateWaitableTimerA
D2DIVIDE . . . . . . . . . . . .	L Near	 00000B84 _TEXT	
D2TIMES  . . . . . . . . . . . .	L Near	 00000B68 _TEXT	
DABS . . . . . . . . . . . . . .	L Near	 00001E14 _TEXT	
DCW  . . . . . . . . . . . . . .	DWord	 0000095C _DATA	
DDOTR  . . . . . . . . . . . . .	L Near	 00002B0B _TEXT	
DO2VALUE . . . . . . . . . . . .	L Near	 00001714 _TEXT	
DOCOL  . . . . . . . . . . . . .	L Near	 000015DB _TEXT	
DOCON  . . . . . . . . . . . . .	L Near	 00001656 _TEXT	
DODEFER  . . . . . . . . . . . .	L Near	 00001679 _TEXT	
DODOES . . . . . . . . . . . . .	L Near	 000015FA _TEXT	
DOOFF  . . . . . . . . . . . . .	L Near	 00001737 _TEXT	
DOUBLEQ  . . . . . . . . . . . .	DWord	 00000960 _DATA	
DOUSER . . . . . . . . . . . . .	L Near	 00001639 _TEXT	
DOVALPLUSTORE  . . . . . . . . .	L Near	 000016E6 _TEXT	
DOVALUESTORE . . . . . . . . . .	L Near	 000016B9 _TEXT	
DOVALUE  . . . . . . . . . . . .	L Near	 0000168F _TEXT	
DOVAR  . . . . . . . . . . . . .	L Near	 0000161A _TEXT	
DPLOCATION . . . . . . . . . . .	DWord	 00000964 _DATA	
DPR  . . . . . . . . . . . . . .	DWord	 00000968 _DATA	
DROP . . . . . . . . . . . . . .	L Near	 00000C14 _TEXT	
DSB  . . . . . . . . . . . . . .	Byte	 00000000 _DATA	
DULT . . . . . . . . . . . . . .	L Near	 00001117 _TEXT	
DUPTOR . . . . . . . . . . . . .	L Near	 00000EF7 _TEXT	
Date . . . . . . . . . . . . . .	Byte	 00000C58 _DATA	
DefineDosDevice  . . . . . . . .	Text   	 DefineDosDeviceA
DeleteFile . . . . . . . . . . .	Text   	 DeleteFileA
DeleteVolumeMountPoint . . . . .	Text   	 DeleteVolumeMountPointA
DnsHostnameToComputerName  . . .	Text   	 DnsHostnameToComputerNameA
ENDOFLINE  . . . . . . . . . . .	L Near	 000000EE _TEXT	
EOCD . . . . . . . . . . . . . .	L Near	 0000262A _TEXT	
EOC  . . . . . . . . . . . . . .	L Near	 000039C3 _TEXT	
EOD  . . . . . . . . . . . . . .	DWord	 00001EC1 _DATA	
EOI  . . . . . . . . . . . . . .	L Near	 000000E1 _TEXT	
EQU0 . . . . . . . . . . . . . .	L Near	 00000FC3 _TEXT	
EXECUTE  . . . . . . . . . . . .	L Near	 00001FF5 _TEXT	
EndUpdateResource  . . . . . . .	Text   	 EndUpdateResourceA
EnumCalendarInfoEx . . . . . . .	Text   	 EnumCalendarInfoExA
EnumCalendarInfo . . . . . . . .	Text   	 EnumCalendarInfoA
EnumDateFormatsEx  . . . . . . .	Text   	 EnumDateFormatsExA
EnumDateFormats  . . . . . . . .	Text   	 EnumDateFormatsA
EnumLanguageGroupLocales . . . .	Text   	 EnumLanguageGroupLocalesA
EnumResourceLanguages  . . . . .	Text   	 EnumResourceLanguagesA
EnumResourceNames  . . . . . . .	Text   	 EnumResourceNamesA
EnumResourceTypes  . . . . . . .	Text   	 EnumResourceTypesA
EnumSystemCodePages  . . . . . .	Text   	 EnumSystemCodePagesA
EnumSystemLanguageGroups . . . .	Text   	 EnumSystemLanguageGroupsA
EnumSystemLocales  . . . . . . .	Text   	 EnumSystemLocalesA
EnumTimeFormats  . . . . . . . .	Text   	 EnumTimeFormatsA
EnumUILanguages  . . . . . . . .	Text   	 EnumUILanguagesA
EnumerateLocalComputerNames  . .	Text   	 EnumerateLocalComputerNamesA
ExpandEnvironmentStrings . . . .	Text   	 ExpandEnvironmentStringsA
FB1  . . . . . . . . . . . . . .	DWord	 00000F6F _DATA	
FB2  . . . . . . . . . . . . . .	DWord	 0000137C _DATA	
FB3  . . . . . . . . . . . . . .	DWord	 00001789 _DATA	
FCOUNTER . . . . . . . . . . . .	DWord	 0000096C _DATA	
FETCH  . . . . . . . . . . . . .	L Near	 00000917 _TEXT	
FFLAG  . . . . . . . . . . . . .	DWord	 00000970 _DATA	
FH1  . . . . . . . . . . . . . .	DWord	 00000F09 _DATA	
FH2  . . . . . . . . . . . . . .	DWord	 00000F1A _DATA	
FH3  . . . . . . . . . . . . . .	DWord	 00000F2B _DATA	
FILEEXIST  . . . . . . . . . . .	L Near	 00003607 _TEXT	
FILLJ  . . . . . . . . . . . . .	L Near	 000017D7 _TEXT	
FIND . . . . . . . . . . . . . .	L Near	 00001B2A _TEXT	
FORGET . . . . . . . . . . . . .	L Near	 00002FA8 _TEXT	
FROMR  . . . . . . . . . . . . .	L Near	 00000EC6 _TEXT	
FS1  . . . . . . . . . . . . . .	DWord	 00000F3C _DATA	
FS2  . . . . . . . . . . . . . .	DWord	 00000F4D _DATA	
FS3  . . . . . . . . . . . . . .	DWord	 00000F5E _DATA	
FatalAppExit . . . . . . . . . .	Text   	 FatalAppExitA
FillConsoleOutputCharacter . . .	Text   	 FillConsoleOutputCharacterA
FindActCtxSectionString  . . . .	Text   	 FindActCtxSectionStringA
FindAtom . . . . . . . . . . . .	Text   	 FindAtomA
FindFirstChangeNotification  . .	Text   	 FindFirstChangeNotificationA
FindFirstFileEx  . . . . . . . .	Text   	 FindFirstFileExA
FindFirstFile  . . . . . . . . .	Text   	 FindFirstFileA
FindFirstVolumeMountPoint  . . .	Text   	 FindFirstVolumeMountPointA
FindFirstVolume  . . . . . . . .	Text   	 FindFirstVolumeA
FindNextFile . . . . . . . . . .	Text   	 FindNextFileA
FindNextVolumeMountPoint . . . .	Text   	 FindNextVolumeMountPointA
FindNextVolume . . . . . . . . .	Text   	 FindNextVolumeA
FindResourceEx . . . . . . . . .	Text   	 FindResourceExA
FindResource . . . . . . . . . .	Text   	 FindResourceA
FoldString . . . . . . . . . . .	Text   	 FoldStringA
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
Forth_Thread . . . . . . . . . .	L Near	 00000000 _TEXT	
FreeEnvironmentStrings . . . . .	Text   	 FreeEnvironmentStringsA
GTNUMBER . . . . . . . . . . . .	L Near	 00001C3B _TEXT	
GetAtomName  . . . . . . . . . .	Text   	 GetAtomNameA
GetBinaryType  . . . . . . . . .	Text   	 GetBinaryTypeA
GetCPInfoEx  . . . . . . . . . .	Text   	 GetCPInfoExA
GetCalendarInfo  . . . . . . . .	Text   	 GetCalendarInfoA
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
GetCompressedFileSize  . . . . .	Text   	 GetCompressedFileSizeA
GetComputerNameEx  . . . . . . .	Text   	 GetComputerNameExA
GetComputerName  . . . . . . . .	Text   	 GetComputerNameA
GetConsoleTitle  . . . . . . . .	Text   	 GetConsoleTitleA
GetCurrencyFormat  . . . . . . .	Text   	 GetCurrencyFormatA
GetCurrentDirectory  . . . . . .	Text   	 GetCurrentDirectoryA
GetDateFormat  . . . . . . . . .	Text   	 GetDateFormatA
GetDefaultCommConfig . . . . . .	Text   	 GetDefaultCommConfigA
GetDiskFreeSpaceEx . . . . . . .	Text   	 GetDiskFreeSpaceExA
GetDiskFreeSpace . . . . . . . .	Text   	 GetDiskFreeSpaceA
GetDllDirectory  . . . . . . . .	Text   	 GetDllDirectoryA
GetDriveType . . . . . . . . . .	Text   	 GetDriveTypeA
GetEnvironmentStrings  . . . . .	Text   	 GetEnvironmentStringsA
GetEnvironmentVariable . . . . .	Text   	 GetEnvironmentVariableA
GetFileAttributesEx  . . . . . .	Text   	 GetFileAttributesExA
GetFileAttributes  . . . . . . .	Text   	 GetFileAttributesA
GetFirmwareEnvironmentVariable .	Text   	 GetFirmwareEnvironmentVariableA
GetFullPathName  . . . . . . . .	Text   	 GetFullPathNameA
GetGeoInfo . . . . . . . . . . .	Text   	 GetGeoInfoA
GetLocaleInfo  . . . . . . . . .	Text   	 GetLocaleInfoA
GetLogicalDriveStrings . . . . .	Text   	 GetLogicalDriveStringsA
GetLongPathName  . . . . . . . .	Text   	 GetLongPathNameA
GetModuleFileName  . . . . . . .	Text   	 GetModuleFileNameA
GetModuleHandleEx  . . . . . . .	Text   	 GetModuleHandleExA
GetModuleHandle  . . . . . . . .	Text   	 GetModuleHandleA
GetNamedPipeHandleState  . . . .	Text   	 GetNamedPipeHandleStateA
GetNumberFormat  . . . . . . . .	Text   	 GetNumberFormatA
GetPrivateProfileInt . . . . . .	Text   	 GetPrivateProfileIntA
GetPrivateProfileSectionNames  .	Text   	 GetPrivateProfileSectionNamesA
GetPrivateProfileSection . . . .	Text   	 GetPrivateProfileSectionA
GetPrivateProfileString  . . . .	Text   	 GetPrivateProfileStringA
GetPrivateProfileStruct  . . . .	Text   	 GetPrivateProfileStructA
GetProfileInt  . . . . . . . . .	Text   	 GetProfileIntA
GetProfileSection  . . . . . . .	Text   	 GetProfileSectionA
GetProfileString . . . . . . . .	Text   	 GetProfileStringA
GetShortPathName . . . . . . . .	Text   	 GetShortPathNameA
GetStartupInfo . . . . . . . . .	Text   	 GetStartupInfoA
GetStringTypeEx  . . . . . . . .	Text   	 GetStringTypeExA
GetStringType  . . . . . . . . .	Text   	 GetStringTypeA
GetSystemDirectory . . . . . . .	Text   	 GetSystemDirectoryA
GetSystemWindowsDirectory  . . .	Text   	 GetSystemWindowsDirectoryA
GetSystemWow64Directory  . . . .	Text   	 GetSystemWow64DirectoryA
GetTempFileName  . . . . . . . .	Text   	 GetTempFileNameA
GetTempPath  . . . . . . . . . .	Text   	 GetTempPathA
GetTimeFormat  . . . . . . . . .	Text   	 GetTimeFormatA
GetVersionEx . . . . . . . . . .	Text   	 GetVersionExA
GetVolumeInformation . . . . . .	Text   	 GetVolumeInformationA
GetVolumeNameForVolumeMountPoint .	Text   	 GetVolumeNameForVolumeMountPointA
GetVolumePathNamesForVolumeName 	Text   	 GetVolumePathNamesForVolumeNameA
GetVolumePathName  . . . . . . .	Text   	 GetVolumePathNameA
GetWindowsDirectory  . . . . . .	Text   	 GetWindowsDirectoryA
GlobalAddAtom  . . . . . . . . .	Text   	 GlobalAddAtomA
GlobalFindAtom . . . . . . . . .	Text   	 GlobalFindAtomA
GlobalGetAtomName  . . . . . . .	Text   	 GlobalGetAtomNameA
Gone . . . . . . . . . . . . . .	L Near	 0000017A _TEXT	
HASHV  . . . . . . . . . . . . .	L Near	 00001FB3 _TEXT	
HEX_TABLE  . . . . . . . . . . .	Byte	 00000C48 _DATA	
HEX  . . . . . . . . . . . . . .	L Near	 00002659 _TEXT	
HLD  . . . . . . . . . . . . . .	DWord	 00000978 _DATA	
HOLD . . . . . . . . . . . . . .	L Near	 00001E37 _TEXT	
IFDUP  . . . . . . . . . . . . .	L Near	 00000CC8 _TEXT	
IMMEDIATE  . . . . . . . . . . .	L Near	 00002BDE _TEXT	
INTERPRET  . . . . . . . . . . .	L Near	 000036FA _TEXT	
IsBadStringPtr . . . . . . . . .	Text   	 IsBadStringPtrA
KBREAD . . . . . . . . . . . . .	L Near	 00001D96 _TEXT	
KERNEL32_INC . . . . . . . . . .	Text   	 1
KEYIN  . . . . . . . . . . . . .	DWord	 0000097C _DATA	
KEY  . . . . . . . . . . . . . .	L Near	 000030D9 _TEXT	
LASTNFA  . . . . . . . . . . . .	L Near	 000038F1 _TEXT	
LATEST . . . . . . . . . . . . .	DWord	 00000980 _DATA	
LCMapString  . . . . . . . . . .	Text   	 LCMapStringA
LCOUNT . . . . . . . . . . . . .	L Near	 000013DB _TEXT	
LFA  . . . . . . . . . . . . . .	DWord	 00000984 _DATA	
LITERAL  . . . . . . . . . . . .	L Near	 000029A1 _TEXT	
LIT  . . . . . . . . . . . . . .	L Near	 00000BFA _TEXT	
LOADFILE1  . . . . . . . . . . .	L Near	 00003920 _TEXT	
LPOUND . . . . . . . . . . . . .	L Near	 00002BA8 _TEXT	
LRESOLVE . . . . . . . . . . . .	L Near	 00002D29 _TEXT	
LROT32 . . . . . . . . . . . . .	L Near	 00000BBC _TEXT	
LoadLibraryEx  . . . . . . . . .	Text   	 LoadLibraryExA
LoadLibrary  . . . . . . . . . .	Text   	 LoadLibraryA
MALLOCHADDR  . . . . . . . . . .	DWord	 00000988 _DATA	
MALLOCLINK . . . . . . . . . . .	DWord	 0000098C _DATA	
MASM32_INC . . . . . . . . . . .	Text   	 1
MAXBUFFER  . . . . . . . . . . .	DWord	 00000990 _DATA	
MAXCOUNTED . . . . . . . . . . .	DWord	 00000994 _DATA	
MAXSTRING  . . . . . . . . . . .	DWord	 00000998 _DATA	
MEMLIMIT . . . . . . . . . . . .	DWord	 0000099C _DATA	
MEMQ . . . . . . . . . . . . . .	L Near	 00000A1C _TEXT	
MESSAGES2  . . . . . . . . . . .	Byte	 00000DA6 _DATA	
MESSAGES . . . . . . . . . . . .	Byte	 00000C6D _DATA	
MINUSCELLS . . . . . . . . . . .	L Near	 00000E13 _TEXT	
MINUSROT . . . . . . . . . . . .	L Near	 00000CA1 _TEXT	
MINUS  . . . . . . . . . . . . .	L Near	 00000A85 _TEXT	
Mempty . . . . . . . . . . . . .	Byte	 00000C37 _DATA	
MoveFileEx . . . . . . . . . . .	Text   	 MoveFileExA
MoveFileWithProgress . . . . . .	Text   	 MoveFileWithProgressA
MoveFile . . . . . . . . . . . .	Text   	 MoveFileA
Msg10  . . . . . . . . . . . . .	Byte	 00000B10 _DATA	
Msg11  . . . . . . . . . . . . .	Byte	 00000B22 _DATA	
Msg12  . . . . . . . . . . . . .	Byte	 00000B31 _DATA	
Msg13  . . . . . . . . . . . . .	Byte	 00000B42 _DATA	
Msg14  . . . . . . . . . . . . .	Byte	 00000B51 _DATA	
Msg15  . . . . . . . . . . . . .	Byte	 00000B60 _DATA	
Msg16  . . . . . . . . . . . . .	Byte	 00000B6E _DATA	
Msg17  . . . . . . . . . . . . .	Byte	 00000B7C _DATA	
Msg18  . . . . . . . . . . . . .	Byte	 00000B94 _DATA	
Msg19  . . . . . . . . . . . . .	Byte	 00000BB2 _DATA	
Msg1A  . . . . . . . . . . . . .	Byte	 00000A14 _DATA	
Msg1 . . . . . . . . . . . . . .	Byte	 000009F8 _DATA	
Msg20  . . . . . . . . . . . . .	Byte	 00000BC6 _DATA	
Msg21  . . . . . . . . . . . . .	Byte	 00000BE4 _DATA	
Msg22  . . . . . . . . . . . . .	Byte	 00000BF8 _DATA	
Msg23  . . . . . . . . . . . . .	Byte	 00000C0F _DATA	
Msg2 . . . . . . . . . . . . . .	Byte	 00000A2A _DATA	
Msg3 . . . . . . . . . . . . . .	Byte	 00000A4C _DATA	
Msg4 . . . . . . . . . . . . . .	Byte	 00000A84 _DATA	
Msg5 . . . . . . . . . . . . . .	Byte	 00000ABC _DATA	
Msg6 . . . . . . . . . . . . . .	Byte	 00000AD7 _DATA	
Msg7 . . . . . . . . . . . . . .	Byte	 00000ADD _DATA	
Msg8 . . . . . . . . . . . . . .	Byte	 00000AEB _DATA	
Msg9 . . . . . . . . . . . . . .	Byte	 00000AFC _DATA	
MsgF1  . . . . . . . . . . . . .	Byte	 00000C29 _DATA	
MsgQ . . . . . . . . . . . . . .	Byte	 00000C25 _DATA	
NEWHEADER  . . . . . . . . . . .	L Near	 00001D15 _TEXT	
NEWNUMB  . . . . . . . . . . . .	L Near	 00001CE4 _TEXT	
NFA  . . . . . . . . . . . . . .	DWord	 000009A0 _DATA	
NIP  . . . . . . . . . . . . . .	L Near	 00000CE4 _TEXT	
NULL . . . . . . . . . . . . . .	L Near	 0000058C _TEXT	
NUMBER@  . . . . . . . . . . . .	L Near	 00003775 _TEXT	
NUMBERQ  . . . . . . . . . . . .	L Near	 00002A2E _TEXT	
NUMBER . . . . . . . . . . . . .	L Near	 00002A55 _TEXT	
NUMINIT  . . . . . . . . . . . .	L Near	 00001CAE _TEXT	
OVER . . . . . . . . . . . . . .	L Near	 00000C61 _TEXT	
OpenEvent  . . . . . . . . . . .	Text   	 OpenEventA
OpenFileMapping  . . . . . . . .	Text   	 OpenFileMappingA
OpenJobObject  . . . . . . . . .	Text   	 OpenJobObjectA
OpenMutex  . . . . . . . . . . .	Text   	 OpenMutexA
OpenSemaphore  . . . . . . . . .	Text   	 OpenSemaphoreA
OpenWaitableTimer  . . . . . . .	Text   	 OpenWaitableTimerA
OutputDebugString  . . . . . . .	Text   	 OutputDebugStringA
PAD  . . . . . . . . . . . . . .	DWord	 00001B96 _DATA	
PARSEINIT  . . . . . . . . . . .	L Near	 000019A3 _TEXT	
PARSENAME  . . . . . . . . . . .	L Near	 00001924 _TEXT	
PARSESTR . . . . . . . . . . . .	L Near	 00001A35 _TEXT	
PARSE  . . . . . . . . . . . . .	L Near	 000019CD _TEXT	
PCHARP . . . . . . . . . . . . .	L Near	 00002A08 _TEXT	
PFA  . . . . . . . . . . . . . .	DWord	 000009A4 _DATA	
PLUSCELLS  . . . . . . . . . . .	L Near	 00000DF6 _TEXT	
POCKET . . . . . . . . . . . . .	DWord	 000009AC _DATA	
POC  . . . . . . . . . . . . . .	Byte	 00000878 _DATA	
POUNDS . . . . . . . . . . . . .	L Near	 00002A7B _TEXT	
POUND  . . . . . . . . . . . . .	L Near	 00001E84 _TEXT	
PRENUMB  . . . . . . . . . . . .	L Near	 00003692 _TEXT	
PREVIOUS . . . . . . . . . . . .	DWord	 000009B0 _DATA	
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
QBYE . . . . . . . . . . . . . .	L Near	 00002177 _TEXT	
QPAIRS . . . . . . . . . . . . .	L Near	 00002CD6 _TEXT	
QUIT . . . . . . . . . . . . . .	L Near	 00002192 _TEXT	
QueryDosDevice . . . . . . . . .	Text   	 QueryDosDeviceA
R0 . . . . . . . . . . . . . . .	Byte	 00000028 _DATA	
RFETCH . . . . . . . . . . . . .	L Near	 00000EE0 _TEXT	
RFROMDROP  . . . . . . . . . . .	L Near	 00000F16 _TEXT	
ROT  . . . . . . . . . . . . . .	L Near	 00000C7B _TEXT	
RPFETCH  . . . . . . . . . . . .	L Near	 00000E80 _TEXT	
RPOUND . . . . . . . . . . . . .	L Near	 00002B76 _TEXT	
RPSTORE  . . . . . . . . . . . .	L Near	 00000E95 _TEXT	
RROT32 . . . . . . . . . . . . .	L Near	 00000BA0 _TEXT	
RSB  . . . . . . . . . . . . . .	Byte	 00000428 _DATA	
RSP  . . . . . . . . . . . . . .	DWord	 000009B4 _DATA	
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsoleOutputCharacter . . .	Text   	 ReadConsoleOutputCharacterA
ReadConsoleOutput  . . . . . . .	Text   	 ReadConsoleOutputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
RemoveDirectory  . . . . . . . .	Text   	 RemoveDirectoryA
RemoveLocalAlternateComputerName .	Text   	 RemoveLocalAlternateComputerNameA
ReplaceFile  . . . . . . . . . .	Text   	 ReplaceFileA
S0 . . . . . . . . . . . . . . .	DWord	 000009D0 _DATA	
S1_ADR . . . . . . . . . . . . .	DWord	 000009BC _DATA	
S1_LEN . . . . . . . . . . . . .	DWord	 000009C8 _DATA	
SCRATCH  . . . . . . . . . . . .	DWord	 00001DB0 _DATA	
SCRINIT  . . . . . . . . . . . .	L Near	 00000004 _TEXT	
SEM1 . . . . . . . . . . . . . .	L Near	 00000891 _TEXT	
SEP1$  . . . . . . . . . . . . .	Byte	 00000C42 _DATA	
SIGNFLAG . . . . . . . . . . . .	DWord	 000009C0 _DATA	
SIGN . . . . . . . . . . . . . .	L Near	 00002B42 _TEXT	
SMAX . . . . . . . . . . . . . .	DWord	 000009CC _DATA	
SOURCE_  . . . . . . . . . . . .	L Near	 00001751 _TEXT	
SPACE$ . . . . . . . . . . . . .	Byte	 00000C46 _DATA	
SPACES . . . . . . . . . . . . .	L Near	 00001E5A _TEXT	
SPACE  . . . . . . . . . . . . .	DWord	 00000EE5 _DATA	
SPFETCH  . . . . . . . . . . . .	L Near	 00000E54 _TEXT	
SPSTORE  . . . . . . . . . . . .	L Near	 00000E69 _TEXT	
STACKERROR . . . . . . . . . . .	DWord	 000009D4 _DATA	
STATE  . . . . . . . . . . . . .	DWord	 000009D8 _DATA	
SWAP . . . . . . . . . . . . . .	L Near	 00000C42 _TEXT	
SWFETCH  . . . . . . . . . . . .	L Near	 000009D0 _TEXT	
S_ADR  . . . . . . . . . . . . .	DWord	 000009B8 _DATA	
S_LEN  . . . . . . . . . . . . .	DWord	 000009C4 _DATA	
ScrollConsoleScreenBuffer  . . .	Text   	 ScrollConsoleScreenBufferA
SearchPath . . . . . . . . . . .	Text   	 SearchPathA
SetCalendarInfo  . . . . . . . .	Text   	 SetCalendarInfoA
SetComputerNameEx  . . . . . . .	Text   	 SetComputerNameExA
SetComputerName  . . . . . . . .	Text   	 SetComputerNameA
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
SetCurrentDirectory  . . . . . .	Text   	 SetCurrentDirectoryA
SetDefaultCommConfig . . . . . .	Text   	 SetDefaultCommConfigA
SetDllDirectory  . . . . . . . .	Text   	 SetDllDirectoryA
SetEnvironmentVariable . . . . .	Text   	 SetEnvironmentVariableA
SetFileAttributes  . . . . . . .	Text   	 SetFileAttributesA
SetFileShortName . . . . . . . .	Text   	 SetFileShortNameA
SetFirmwareEnvironmentVariable .	Text   	 SetFirmwareEnvironmentVariableA
SetLocalPrimaryComputerName  . .	Text   	 SetLocalPrimaryComputerNameA
SetLocaleInfo  . . . . . . . . .	Text   	 SetLocaleInfoA
SetVolumeLabel . . . . . . . . .	Text   	 SetVolumeLabelA
SetVolumeMountPoint  . . . . . .	Text   	 SetVolumeMountPointA
Start  . . . . . . . . . . . . .	L Near	 00000014 _TEXT	Public STDCALL
StoD . . . . . . . . . . . . . .	L Near	 00000D33 _TEXT	
TEST1  . . . . . . . . . . . . .	L Near	 0000397C _TEXT	
TESTING  . . . . . . . . . . . .	L Near	 00003987 _TEXT	
TI1  . . . . . . . . . . . . . .	L Near	 00000026 _TEXT	
TIB  . . . . . . . . . . . . . .	DWord	 00001CA3 _DATA	
TOBODY . . . . . . . . . . . . .	L Near	 00001819 _TEXT	
TOBPA  . . . . . . . . . . . . .	L Near	 0000373B _TEXT	
TONUMBER . . . . . . . . . . . .	L Near	 00003779 _TEXT	
TOR  . . . . . . . . . . . . . .	L Near	 00000EAC _TEXT	
TO . . . . . . . . . . . . . . .	L Near	 0000318D _TEXT	
TUCK . . . . . . . . . . . . . .	L Near	 00000CFB _TEXT	
TV$  . . . . . . . . . . . . . .	DWord	 000009E8 _DATA	
TV1@ . . . . . . . . . . . . . .	DWord	 00000EAF _DATA	
TV1  . . . . . . . . . . . . . .	DWord	 000009DC _DATA	
TV2@ . . . . . . . . . . . . . .	DWord	 00000EC1 _DATA	
TV2  . . . . . . . . . . . . . .	DWord	 000009E0 _DATA	
TV3@ . . . . . . . . . . . . . .	DWord	 00000ED3 _DATA	
TV3  . . . . . . . . . . . . . .	DWord	 000009E4 _DATA	
Time . . . . . . . . . . . . . .	Byte	 00000C63 _DATA	
U2DIVIDE . . . . . . . . . . . .	L Near	 00000B20 _TEXT	
UGT  . . . . . . . . . . . . . .	L Near	 000010FD _TEXT	
ULT  . . . . . . . . . . . . . .	L Near	 000010E3 _TEXT	
UMIN . . . . . . . . . . . . . .	L Near	 00001139 _TEXT	
UNDERPLUS  . . . . . . . . . . .	L Near	 00000A9C _TEXT	
USER_BASE  . . . . . . . . . . .	DWord	 00001ECE _DATA	
UpdateResource . . . . . . . . .	Text   	 UpdateResourceA
VALUE  . . . . . . . . . . . . .	L Near	 00002924 _TEXT	
VENUMQ . . . . . . . . . . . . .	DWord	 000009EC _DATA	
VerLanguageName  . . . . . . . .	Text   	 VerLanguageNameA
VerifyVersionInfo  . . . . . . .	Text   	 VerifyVersionInfoA
WCOUNT . . . . . . . . . . . . .	L Near	 000013BA _TEXT	
WFETCH . . . . . . . . . . . . .	L Near	 000009B8 _TEXT	
WPLUSSTORE . . . . . . . . . . .	L Near	 00000A02 _TEXT	
WSTORE . . . . . . . . . . . . .	L Near	 000009E9 _TEXT	
WaitNamedPipe  . . . . . . . . .	Text   	 WaitNamedPipeA
WriteConsoleInput  . . . . . . .	Text   	 WriteConsoleInputA
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsoleOutput . . . . . . .	Text   	 WriteConsoleOutputA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
WritePrivateProfileSection . . .	Text   	 WritePrivateProfileSectionA
WritePrivateProfileString  . . .	Text   	 WritePrivateProfileStringA
WritePrivateProfileStruct  . . .	Text   	 WritePrivateProfileStructA
WriteProfileSection  . . . . . .	Text   	 WriteProfileSectionA
WriteProfileString . . . . . . .	Text   	 WriteProfileStringA
ZCOUNT . . . . . . . . . . . . .	L Near	 000013FB _TEXT	
_0GT . . . . . . . . . . . . . .	L Near	 00001012 _TEXT	
_0LT . . . . . . . . . . . . . .	L Near	 00000FFA _TEXT	
_0MAX  . . . . . . . . . . . . .	L Near	 000011AF _TEXT	
_0NE . . . . . . . . . . . . . .	L Near	 00000FDD _TEXT	
_1IN . . . . . . . . . . . . . .	DWord	 00000934 _DATA	
_1MINUS  . . . . . . . . . . . .	L Near	 00000B50 _TEXT	
_1PLUS . . . . . . . . . . . . .	L Near	 00000B38 _TEXT	
_2DIVIDE . . . . . . . . . . . .	L Near	 00000B09 _TEXT	
_2DROP . . . . . . . . . . . . .	L Near	 00000FAA _TEXT	
_2DUP  . . . . . . . . . . . . .	L Near	 00000F8C _TEXT	
_2FETCH  . . . . . . . . . . . .	L Near	 00001217 _TEXT	
_2NIP  . . . . . . . . . . . . .	L Near	 0000124B _TEXT	
_2OVER . . . . . . . . . . . . .	L Near	 00001298 _TEXT	
_2RFETCH . . . . . . . . . . . .	L Near	 00000F72 _TEXT	
_2RFROM  . . . . . . . . . . . .	L Near	 00000F52 _TEXT	
_2ROT  . . . . . . . . . . . . .	L Near	 000012BA _TEXT	
_2STORE  . . . . . . . . . . . .	L Near	 00001231 _TEXT	
_2SWAP . . . . . . . . . . . . .	L Near	 00001268 _TEXT	
_2TIMES  . . . . . . . . . . . .	L Near	 00000AF2 _TEXT	
_2TOR  . . . . . . . . . . . . .	L Near	 00000F30 _TEXT	
_3DROP . . . . . . . . . . . . .	L Near	 000012E2 _TEXT	
_3DUP  . . . . . . . . . . . . .	L Near	 00001314 _TEXT	
_4DROP . . . . . . . . . . . . .	L Near	 000012FB _TEXT	
_4DUP  . . . . . . . . . . . . .	L Near	 00001335 _TEXT	
_ABORT@  . . . . . . . . . . . .	L Near	 00000714 _TEXT	
_ABORTFLAG . . . . . . . . . . .	L Near	 00000414 _TEXT	
_ABORT . . . . . . . . . . . . .	L Near	 000006C7 _TEXT	
_ABS . . . . . . . . . . . . . .	L Near	 00000AD3 _TEXT	
_ABT1  . . . . . . . . . . . . .	L Near	 00000620 _TEXT	
_ABT2  . . . . . . . . . . . . .	L Near	 00000680 _TEXT	
_ACCEPT  . . . . . . . . . . . .	L Near	 00002F6A _TEXT	
_ALIGN . . . . . . . . . . . . .	L Near	 0000260C _TEXT	
_ALLOCATE  . . . . . . . . . . .	L Near	 00002594 _TEXT	
_ALLOT . . . . . . . . . . . . .	L Near	 0000310B _TEXT	
_AND . . . . . . . . . . . . . .	L Near	 00001479 _TEXT	
_ANEW  . . . . . . . . . . . . .	L Near	 00003251 _TEXT	
_BASE  . . . . . . . . . . . . .	L Near	 00000140 _TEXT	
_BEGIN@  . . . . . . . . . . . .	L Near	 00002D4D _TEXT	
_BEGIN . . . . . . . . . . . . .	L Near	 00002CF8 _TEXT	
_BETWEEN . . . . . . . . . . . .	L Near	 000011F0 _TEXT	
_BEXT  . . . . . . . . . . . . .	L Near	 00002360 _TEXT	
_BINARY  . . . . . . . . . . . .	L Near	 00002684 _TEXT	
_BL  . . . . . . . . . . . . . .	DWord	 00000EF4 _DATA	
_BPA . . . . . . . . . . . . . .	L Near	 00003737 _TEXT	
_BTOH  . . . . . . . . . . . . .	L Near	 0000231F _TEXT	
_BYE . . . . . . . . . . . . . .	L Near	 0000214B _TEXT	
_CCOMMA  . . . . . . . . . . . .	L Near	 00002824 _TEXT	
_CELLS . . . . . . . . . . . . .	L Near	 00000D65 _TEXT	
_CELL  . . . . . . . . . . . . .	L Near	 00000D4E _TEXT	
_CFA . . . . . . . . . . . . . .	L Near	 0000021E _TEXT	
_CHAR  . . . . . . . . . . . . .	L Near	 000029C8 _TEXT	
_CMAX  . . . . . . . . . . . . .	L Near	 0000239F _TEXT	
_CMOVE . . . . . . . . . . . . .	L Near	 0000178F _TEXT	
_COLD  . . . . . . . . . . . . .	L Near	 00000593 _TEXT	
_COLON . . . . . . . . . . . . .	L Near	 00003882 _TEXT	
_COMMA . . . . . . . . . . . . .	L Near	 000027C5 _TEXT	
_COMMENT1  . . . . . . . . . . .	L Near	 00003654 _TEXT	
_COMMENT2  . . . . . . . . . . .	L Near	 00003673 _TEXT	
_COMPF . . . . . . . . . . . . .	L Near	 00000505 _TEXT	
_COMPILEC  . . . . . . . . . . .	L Near	 000039A5 _TEXT	
_COMPILE . . . . . . . . . . . .	L Near	 000008FA _TEXT	
_CONHEAD . . . . . . . . . . . .	L Near	 0000287C _TEXT	
_CONSTANT  . . . . . . . . . . .	L Near	 000028A2 _TEXT	
_CREATE  . . . . . . . . . . . .	L Near	 0000284E _TEXT	
_CRLF  . . . . . . . . . . . . .	L Near	 00000381 _TEXT	
_CTYPE . . . . . . . . . . . . .	L Near	 00003434 _TEXT	
_DCW . . . . . . . . . . . . . .	L Near	 00000311 _TEXT	
_DDOT  . . . . . . . . . . . . .	L Near	 00002ADD _TEXT	
_DECIMAL . . . . . . . . . . . .	L Near	 0000262A _TEXT	
_DECR  . . . . . . . . . . . . .	L Near	 00001533 _TEXT	
_DEPTH . . . . . . . . . . . . .	L Near	 00000E32 _TEXT	
_DOCOLN  . . . . . . . . . . . .	L Near	 000015BD _TEXT	
_DOTP  . . . . . . . . . . . . .	L Near	 00003022 _TEXT	
_DPR . . . . . . . . . . . . . .	L Near	 000001B1 _TEXT	
_DUMP  . . . . . . . . . . . . .	L Near	 00003481 _TEXT	
_EDI . . . . . . . . . . . . . .	DWord	 00000928 _DATA	
_ELSE@ . . . . . . . . . . . . .	L Near	 00001F78 _TEXT	
_ELSE  . . . . . . . . . . . . .	L Near	 00002C31 _TEXT	
_EMIT  . . . . . . . . . . . . .	L Near	 0000276E _TEXT	
_EMSG  . . . . . . . . . . . . .	L Near	 00002009 _TEXT	
_EOD . . . . . . . . . . . . . .	DWord	 00001EBD _DATA	
_EQU . . . . . . . . . . . . . .	L Near	 00001030 _TEXT	
_ERASE . . . . . . . . . . . . .	L Near	 000017F0 _TEXT	
_Endless . . . . . . . . . . . .	L Near	 0000211F _TEXT	
_FB1 . . . . . . . . . . . . . .	DWord	 00000F6B _DATA	
_FB2 . . . . . . . . . . . . . .	DWord	 00001378 _DATA	
_FB3 . . . . . . . . . . . . . .	DWord	 00001785 _DATA	
_FCOUNTER  . . . . . . . . . . .	L Near	 00000452 _TEXT	
_FH1 . . . . . . . . . . . . . .	DWord	 00000F05 _DATA	
_FH2 . . . . . . . . . . . . . .	DWord	 00000F16 _DATA	
_FH3 . . . . . . . . . . . . . .	DWord	 00000F27 _DATA	
_FILECLOSE . . . . . . . . . . .	L Near	 0000240A _TEXT	
_FILECREATE  . . . . . . . . . .	L Near	 00002430 _TEXT	
_FILEEXIST . . . . . . . . . . .	L Near	 00003603 _TEXT	
_FILEOPEN  . . . . . . . . . . .	L Near	 000023C8 _TEXT	
_FILL  . . . . . . . . . . . . .	L Near	 000017BC _TEXT	
_FINDFLAG  . . . . . . . . . . .	L Near	 000001CC _TEXT	
_FORGET  . . . . . . . . . . . .	L Near	 00002FA4 _TEXT	
_FPARMSRW  . . . . . . . . . . .	L Near	 0000249F _TEXT	
_FS1 . . . . . . . . . . . . . .	DWord	 00000F38 _DATA	
_FS2 . . . . . . . . . . . . . .	DWord	 00000F49 _DATA	
_FS3 . . . . . . . . . . . . . .	DWord	 00000F5A _DATA	
_GCFA  . . . . . . . . . . . . .	L Near	 00002304 _TEXT	
_GETADDR . . . . . . . . . . . .	L Near	 00000BD8 _TEXT	
_GTE . . . . . . . . . . . . . .	L Near	 000010C7 _TEXT	
_GT  . . . . . . . . . . . . . .	L Near	 00001090 _TEXT	
_GetFileSize . . . . . . . . . .	L Near	 00002476 _TEXT	
_HEADER_ . . . . . . . . . . . .	L Near	 00001775 _TEXT	
_HEADER  . . . . . . . . . . . .	L Near	 000026DF _TEXT	
_HERE  . . . . . . . . . . . . .	L Near	 00001A9A _TEXT	
_HLD . . . . . . . . . . . . . .	L Near	 00000108 _TEXT	
_IF@ . . . . . . . . . . . . . .	L Near	 00001F3E _TEXT	
_IF  . . . . . . . . . . . . . .	L Near	 00002C13 _TEXT	
_IMMEDIATE . . . . . . . . . . .	L Near	 00002BDA _TEXT	
_INCR  . . . . . . . . . . . . .	L Near	 0000151A _TEXT	
_INTERPRET . . . . . . . . . . .	L Near	 000036F6 _TEXT	
_INVERT  . . . . . . . . . . . .	L Near	 000014C3 _TEXT	
_IN  . . . . . . . . . . . . . .	DWord	 00000930 _DATA	
_KEYIN . . . . . . . . . . . . .	L Near	 0000032C _TEXT	
_KEYQ  . . . . . . . . . . . . .	L Near	 000030E9 _TEXT	
_KEY . . . . . . . . . . . . . .	L Near	 000030D5 _TEXT	
_LASTNFA . . . . . . . . . . . .	L Near	 000038ED _TEXT	
_LAST  . . . . . . . . . . . . .	L Near	 000008DF _TEXT	
_LATEST  . . . . . . . . . . . .	L Near	 00000560 _TEXT	
_LFA . . . . . . . . . . . . . .	L Near	 000001E9 _TEXT	
_LITERAL . . . . . . . . . . . .	L Near	 0000299D _TEXT	
_LMARK . . . . . . . . . . . . .	L Near	 00002C8C _TEXT	
_LOADFILE1 . . . . . . . . . . .	L Near	 0000391C _TEXT	
_LOAD  . . . . . . . . . . . . .	L Near	 000037A4 _TEXT	
_LOWERCASE . . . . . . . . . . .	L Near	 00001AF0 _TEXT	
_LSHIFT  . . . . . . . . . . . .	L Near	 000014DE _TEXT	
_LTE . . . . . . . . . . . . . .	L Near	 000010AB _TEXT	
_LT  . . . . . . . . . . . . . .	L Near	 00001068 _TEXT	
_MALADDR . . . . . . . . . . . .	L Near	 00000472 _TEXT	
_MALLOC  . . . . . . . . . . . .	L Near	 0000257D _TEXT	
_MAX . . . . . . . . . . . . . .	L Near	 00001192 _TEXT	
_MESSAGES  . . . . . . . . . . .	L Near	 00000523 _TEXT	
_MIN . . . . . . . . . . . . . .	L Near	 00001157 _TEXT	
_MMULT . . . . . . . . . . . . .	L Near	 00001360 _TEXT	
_MSG22 . . . . . . . . . . . . .	L Near	 000003D5 _TEXT	
_MSG3  . . . . . . . . . . . . .	L Near	 0000039D _TEXT	
_MSG4  . . . . . . . . . . . . .	L Near	 000003B9 _TEXT	
_MULT  . . . . . . . . . . . . .	L Near	 0000137F _TEXT	
_MsgF1 . . . . . . . . . . . . .	L Near	 00000543 _TEXT	
_NEGATE  . . . . . . . . . . . .	L Near	 00000AB8 _TEXT	
_NEQ . . . . . . . . . . . . . .	L Near	 0000104C _TEXT	
_NFA . . . . . . . . . . . . . .	L Near	 00000204 _TEXT	
_NIF . . . . . . . . . . . . . .	L Near	 00002C71 _TEXT	
_NOOP  . . . . . . . . . . . . .	L Near	 00001A85 _TEXT	
_NULL  . . . . . . . . . . . . .	L Near	 0000057E _TEXT	
_NUMBER  . . . . . . . . . . . .	L Near	 00002A51 _TEXT	
_OCTAL . . . . . . . . . . . . .	L Near	 000026B2 _TEXT	
_OFF . . . . . . . . . . . . . .	L Near	 000015A2 _TEXT	
_ON  . . . . . . . . . . . . . .	L Near	 00001588 _TEXT	
_OR  . . . . . . . . . . . . . .	L Near	 00001492 _TEXT	
_PAD . . . . . . . . . . . . . .	DWord	 00001B92 _DATA	
_PAUSE . . . . . . . . . . . . .	L Near	 0000308D _TEXT	
_PDDOTP  . . . . . . . . . . . .	L Near	 00002AAD _TEXT	
_PDOTP . . . . . . . . . . . . .	L Near	 00002055 _TEXT	
_PFA . . . . . . . . . . . . . .	L Near	 00000238 _TEXT	
_PLUS  . . . . . . . . . . . . .	L Near	 00000A6E _TEXT	
_POC . . . . . . . . . . . . . .	L Near	 00000196 _TEXT	
_PRINT . . . . . . . . . . . . .	L Near	 0000273D _TEXT	
_PTO . . . . . . . . . . . . . .	L Near	 000031BF _TEXT	
_PUSH0 . . . . . . . . . . . . .	L Near	 000008CB _TEXT	
_PUSH1 . . . . . . . . . . . . .	L Near	 0000089E _TEXT	
_QBYE  . . . . . . . . . . . . .	L Near	 00002169 _TEXT	
_QCOMP . . . . . . . . . . . . .	L Near	 00002CAD _TEXT	
_QMISSING  . . . . . . . . . . .	L Near	 00002132 _TEXT	
_QSTACK  . . . . . . . . . . . .	L Near	 000022B1 _TEXT	
_QUIT  . . . . . . . . . . . . .	L Near	 00002184 _TEXT	
_READFILE  . . . . . . . . . . .	L Near	 000024BD _TEXT	
_RO  . . . . . . . . . . . . . .	L Near	 000004B2 _TEXT	
_RSHIFT  . . . . . . . . . . . .	L Near	 000014FC _TEXT	
_RS  . . . . . . . . . . . . . .	L Near	 000008B2 _TEXT	
_RW  . . . . . . . . . . . . . .	L Near	 000004D4 _TEXT	
_S0  . . . . . . . . . . . . . .	L Near	 000002A6 _TEXT	
_SCRATCH . . . . . . . . . . . .	DWord	 00001DAC _DATA	
_SCRINIT . . . . . . . . . . . .	L Near	 0000073C _TEXT	
_SEMI  . . . . . . . . . . . . .	L Near	 00000857 _TEXT	
_SEP1  . . . . . . . . . . . . .	L Near	 00000435 _TEXT	
_SOURCE  . . . . . . . . . . . .	DWord	 00000938 _DATA	
_SPACE . . . . . . . . . . . . .	DWord	 00000EE1 _DATA	
_SP  . . . . . . . . . . . . . .	L Near	 00002078 _TEXT	
_STACKERROR  . . . . . . . . . .	L Near	 000003F2 _TEXT	
_STATE . . . . . . . . . . . . .	L Near	 00000123 _TEXT	
_STRINGADJ . . . . . . . . . . .	L Near	 00001428 _TEXT	
_SYSTIME . . . . . . . . . . . .	DWord	 00000918 _DATA	
_S_ADR . . . . . . . . . . . . .	L Near	 00000495 _TEXT	
_S_LEN . . . . . . . . . . . . .	L Near	 0000026D _TEXT	
_S_MAX . . . . . . . . . . . . .	L Near	 0000028A _TEXT	
_TESTING . . . . . . . . . . . .	L Near	 00003978 _TEXT	
_THEN@ . . . . . . . . . . . . .	L Near	 00001F9C _TEXT	
_THEN  . . . . . . . . . . . . .	L Near	 00002C51 _TEXT	
_TIB . . . . . . . . . . . . . .	DWord	 00001C9F _DATA	
_TICK  . . . . . . . . . . . . .	L Near	 00003158 _TEXT	
_TO  . . . . . . . . . . . . . .	L Near	 00003189 _TEXT	
_TV1@  . . . . . . . . . . . . .	DWord	 00000EAB _DATA	
_TV1 . . . . . . . . . . . . . .	L Near	 000002C0 _TEXT	
_TV2@  . . . . . . . . . . . . .	DWord	 00000EBD _DATA	
_TV2 . . . . . . . . . . . . . .	L Near	 000002DB _TEXT	
_TV3@  . . . . . . . . . . . . .	DWord	 00000ECF _DATA	
_TV3 . . . . . . . . . . . . . .	L Near	 000002F6 _TEXT	
_TYPE  . . . . . . . . . . . . .	L Near	 00002201 _TEXT	
_UB  . . . . . . . . . . . . . .	L Near	 000004E5 _TEXT	
_UMAX  . . . . . . . . . . . . .	L Near	 00001174 _TEXT	
_UNTIL@  . . . . . . . . . . . .	L Near	 00002D74 _TEXT	
_UNTIL . . . . . . . . . . . . .	L Near	 00002DAD _TEXT	
_UPPERCASE . . . . . . . . . . .	L Near	 00001AB6 _TEXT	
_VALUE . . . . . . . . . . . . .	L Near	 00002920 _TEXT	
_VARHEAD . . . . . . . . . . . .	L Near	 000028CE _TEXT	
_VARIABLE  . . . . . . . . . . .	L Near	 000028F4 _TEXT	
_WCOMMA  . . . . . . . . . . . .	L Near	 000027F2 _TEXT	
_WDCOUNT . . . . . . . . . . . .	L Near	 00002278 _TEXT	
_WITHIN  . . . . . . . . . . . .	L Near	 000011CD _TEXT	
_WORDS . . . . . . . . . . . . .	L Near	 000032A1 _TEXT	
_WORD  . . . . . . . . . . . . .	L Near	 0000184F _TEXT	
_WO  . . . . . . . . . . . . . .	L Near	 000004C3 _TEXT	
_WRITEFILE . . . . . . . . . . .	L Near	 000024EC _TEXT	
_XOR . . . . . . . . . . . . . .	L Near	 000014AA _TEXT	
_ZCOMMAQ . . . . . . . . . . . .	L Near	 000031F6 _TEXT	
__IN . . . . . . . . . . . . . .	L Near	 00000252 _TEXT	
__UNTIL  . . . . . . . . . . . .	L Near	 00001F11 _TEXT	
_dotR  . . . . . . . . . . . . .	L Near	 00002DE2 _TEXT	
_dotS  . . . . . . . . . . . . .	L Near	 00002E0C _TEXT	
_dwtoa . . . . . . . . . . . . .	L Near	 000021AA _TEXT	
_fileposition  . . . . . . . . .	L Near	 00002517 _TEXT	
_free  . . . . . . . . . . . . .	L Near	 000025E9 _TEXT	
_hMemory . . . . . . . . . . . .	DWord	 0000092C _DATA	
_ms  . . . . . . . . . . . . . .	L Near	 00002224 _TEXT	
_pMem  . . . . . . . . . . . . .	L Near	 00000365 _TEXT	
_qmark . . . . . . . . . . . . .	L Near	 000027A4 _TEXT	
_repositionfile  . . . . . . . .	L Near	 00002549 _TEXT	
_stdout  . . . . . . . . . . . .	L Near	 000021E2 _TEXT	
_udw2str . . . . . . . . . . . .	L Near	 000021C5 _TEXT	
cmpsi  . . . . . . . . . . . . .	Text   	 szCmpi
cmpstr . . . . . . . . . . . . .	Text   	 szCmp
crlf$  . . . . . . . . . . . . .	Byte	 00000C3F _DATA	
do_0GT . . . . . . . . . . . . .	L Near	 0000101E _TEXT	
do_0LT . . . . . . . . . . . . .	L Near	 00001006 _TEXT	
do_0MAX  . . . . . . . . . . . .	L Near	 000011BD _TEXT	
do_0NE . . . . . . . . . . . . .	L Near	 00000FEA _TEXT	
do_1MINUS  . . . . . . . . . . .	L Near	 00000B5C _TEXT	
do_1PLUS . . . . . . . . . . . .	L Near	 00000B44 _TEXT	
do_2DIVIDE . . . . . . . . . . .	L Near	 00000B15 _TEXT	
do_2DROP . . . . . . . . . . . .	L Near	 00000FB9 _TEXT	
do_2DUP  . . . . . . . . . . . .	L Near	 00000F9A _TEXT	
do_2FETCH  . . . . . . . . . . .	L Near	 00001223 _TEXT	
do_2NIP  . . . . . . . . . . . .	L Near	 00001259 _TEXT	
do_2OVER . . . . . . . . . . . .	L Near	 000012A7 _TEXT	
do_2RFETCH . . . . . . . . . . .	L Near	 00000F7F _TEXT	
do_2RFROM  . . . . . . . . . . .	L Near	 00000F5F _TEXT	
do_2ROT  . . . . . . . . . . . .	L Near	 000012C8 _TEXT	
do_2STORE  . . . . . . . . . . .	L Near	 0000123D _TEXT	
do_2SWAP . . . . . . . . . . . .	L Near	 00001277 _TEXT	
do_2TIMES  . . . . . . . . . . .	L Near	 00000AFE _TEXT	
do_2TOR  . . . . . . . . . . . .	L Near	 00000F3D _TEXT	
do_3DROP . . . . . . . . . . . .	L Near	 000012F1 _TEXT	
do_3DUP  . . . . . . . . . . . .	L Near	 00001322 _TEXT	
do_4DROP . . . . . . . . . . . .	L Near	 0000130A _TEXT	
do_4DUP  . . . . . . . . . . . .	L Near	 00001343 _TEXT	
do_?COMP . . . . . . . . . . . .	L Near	 00002CBC _TEXT	
do_?MISSING  . . . . . . . . . .	L Near	 00002144 _TEXT	
do_?PAIRS  . . . . . . . . . . .	L Near	 00002CE6 _TEXT	
do_ABFLG . . . . . . . . . . . .	L Near	 00000427 _TEXT	
do_ABORT@  . . . . . . . . . . .	L Near	 00000725 _TEXT	
do_ABORT . . . . . . . . . . . .	L Near	 000006D6 _TEXT	
do_ABS . . . . . . . . . . . . .	L Near	 00000AE0 _TEXT	
do_ABT1  . . . . . . . . . . . .	L Near	 0000062E _TEXT	
do_ABT2  . . . . . . . . . . . .	L Near	 0000068E _TEXT	
do_ACCEPT  . . . . . . . . . . .	L Near	 00002F7A _TEXT	
do_ADDNULL . . . . . . . . . . .	L Near	 00001463 _TEXT	
do_ALIGN . . . . . . . . . . . .	L Near	 0000261B _TEXT	
do_ALLOCATE  . . . . . . . . . .	L Near	 000025A6 _TEXT	
do_ALLOT . . . . . . . . . . . .	L Near	 0000311A _TEXT	
do_AND . . . . . . . . . . . . .	L Near	 00001486 _TEXT	
do_ARRBLD  . . . . . . . . . . .	L Near	 0000392F _TEXT	
do_BASE  . . . . . . . . . . . .	L Near	 0000014E _TEXT	
do_BEGIN@  . . . . . . . . . . .	L Near	 00002D5E _TEXT	
do_BEGIN . . . . . . . . . . . .	L Near	 00002D07 _TEXT	
do_BETWEEN . . . . . . . . . . .	L Near	 00001201 _TEXT	
do_BEXT  . . . . . . . . . . . .	L Near	 0000236E _TEXT	
do_BINARY  . . . . . . . . . . .	L Near	 00002694 _TEXT	
do_BLANK . . . . . . . . . . . .	L Near	 00001812 _TEXT	
do_BODYOFF . . . . . . . . . . .	L Near	 00001843 _TEXT	
do_BTOH  . . . . . . . . . . . .	L Near	 0000232D _TEXT	
do_CCOMMA  . . . . . . . . . . .	L Near	 00002830 _TEXT	
do_CDECR . . . . . . . . . . . .	L Near	 00001579 _TEXT	
do_CELLMINUS . . . . . . . . . .	L Near	 00000DEA _TEXT	
do_CELLPLUS  . . . . . . . . . .	L Near	 00000DCF _TEXT	
do_CELLSMINUS  . . . . . . . . .	L Near	 00000DAD _TEXT	
do_CELLSPLUS . . . . . . . . . .	L Near	 00000D90 _TEXT	
do_CELLS . . . . . . . . . . . .	L Near	 00000D74 _TEXT	
do_CELL  . . . . . . . . . . . .	L Near	 00000D5C _TEXT	
do_CFA . . . . . . . . . . . . .	L Near	 0000022B _TEXT	
do_CFETCH  . . . . . . . . . . .	L Near	 0000097D _TEXT	
do_CHARPLUS  . . . . . . . . . .	L Near	 00000A62 _TEXT	
do_CHARS . . . . . . . . . . . .	L Near	 00000A4C _TEXT	
do_CHAR  . . . . . . . . . . . .	L Near	 000029D6 _TEXT	
do_CINCR . . . . . . . . . . . .	L Near	 0000155B _TEXT	
do_CLS . . . . . . . . . . . . .	L Near	 00001DE9 _TEXT	
do_CMAX  . . . . . . . . . . . .	L Near	 000023AD _TEXT	
do_CMOVE . . . . . . . . . . . .	L Near	 0000179E _TEXT	
do_COLN  . . . . . . . . . . . .	L Near	 000015CB _TEXT	
do_COLON . . . . . . . . . . . .	L Near	 0000388D _TEXT	
do_COMMA . . . . . . . . . . . .	L Near	 000027D0 _TEXT	
do_COMPF . . . . . . . . . . . .	L Near	 00000515 _TEXT	
do_COMPILE . . . . . . . . . . .	L Near	 0000090B _TEXT	
do_CONHEAD . . . . . . . . . . .	L Near	 0000288D _TEXT	
do_CONSTANT  . . . . . . . . . .	L Near	 000028B4 _TEXT	
do_COUNT . . . . . . . . . . . .	L Near	 000013AB _TEXT	
do_CPLUSSTORE  . . . . . . . . .	L Near	 000009AD _TEXT	
do_CREATE  . . . . . . . . . . .	L Near	 0000285E _TEXT	
do_CRLF  . . . . . . . . . . . .	L Near	 0000038F _TEXT	
do_CR  . . . . . . . . . . . . .	L Near	 00001E01 _TEXT	
do_CSTORE  . . . . . . . . . . .	L Near	 00000995 _TEXT	
do_CTYPE . . . . . . . . . . . .	L Near	 00003443 _TEXT	
do_D2DIVIDE  . . . . . . . . . .	L Near	 00000B91 _TEXT	
do_D2TIMES . . . . . . . . . . .	L Near	 00000B75 _TEXT	
do_DABS  . . . . . . . . . . . .	L Near	 00001E22 _TEXT	
do_DCW . . . . . . . . . . . . .	L Near	 0000031E _TEXT	
do_DDOTR . . . . . . . . . . . .	L Near	 00002B18 _TEXT	
do_DDOT  . . . . . . . . . . . .	L Near	 00002AE9 _TEXT	
do_DECIMAL . . . . . . . . . . .	L Near	 0000263B _TEXT	
do_DECR  . . . . . . . . . . . .	L Near	 00001541 _TEXT	
do_DEPTH . . . . . . . . . . . .	L Near	 00000E41 _TEXT	
do_DO2VALUE  . . . . . . . . . .	L Near	 00001726 _TEXT	
do_DOCOL . . . . . . . . . . . .	L Near	 000015EA _TEXT	
do_DOCON . . . . . . . . . . . .	L Near	 00001665 _TEXT	
do_DODEFER . . . . . . . . . . .	L Near	 0000168A _TEXT	
do_DODOES  . . . . . . . . . . .	L Near	 0000160A _TEXT	
do_DOOFF . . . . . . . . . . . .	L Near	 00001746 _TEXT	
do_DOTP  . . . . . . . . . . . .	L Near	 0000302E _TEXT	
do_DOUSER  . . . . . . . . . . .	L Near	 00001649 _TEXT	
do_DOVALUE . . . . . . . . . . .	L Near	 000016A0 _TEXT	
do_DOVAR . . . . . . . . . . . .	L Near	 00001629 _TEXT	
do_DPR . . . . . . . . . . . . .	L Near	 000001BE _TEXT	
do_DROP  . . . . . . . . . . . .	L Near	 00000C22 _TEXT	
do_DULT  . . . . . . . . . . . .	L Near	 00001124 _TEXT	
do_DUPTOR  . . . . . . . . . . .	L Near	 00000F06 _TEXT	
do_DUP . . . . . . . . . . . . .	L Near	 00000C37 _TEXT	
do_ELSE@ . . . . . . . . . . . .	L Near	 00001F88 _TEXT	
do_ELSE  . . . . . . . . . . . .	L Near	 00002C3F _TEXT	
do_EMIT  . . . . . . . . . . . .	L Near	 0000277C _TEXT	
do_EMSG  . . . . . . . . . . . .	L Near	 00002018 _TEXT	
do_ENDOFLINE . . . . . . . . . .	L Near	 00000101 _TEXT	
do_EQU0  . . . . . . . . . . . .	L Near	 00000FCF _TEXT	
do_EQU . . . . . . . . . . . . .	L Near	 0000103B _TEXT	
do_ERASE . . . . . . . . . . . .	L Near	 000017FF _TEXT	
do_EXECUTE . . . . . . . . . . .	L Near	 00002006 _TEXT	
do_Endless . . . . . . . . . . .	L Near	 00002130 _TEXT	
do_FCOUNTER  . . . . . . . . . .	L Near	 00000464 _TEXT	
do_FETCH . . . . . . . . . . . .	L Near	 00000922 _TEXT	
do_FFLAG . . . . . . . . . . . .	L Near	 000001DB _TEXT	
do_FILECLOSE . . . . . . . . . .	L Near	 0000241E _TEXT	
do_FILECREATE  . . . . . . . . .	L Near	 00002445 _TEXT	
do_FILEOPEN  . . . . . . . . . .	L Near	 000023DB _TEXT	
do_FILEPOSITION  . . . . . . . .	L Near	 0000252E _TEXT	
do_FILEQ . . . . . . . . . . . .	L Near	 00003616 _TEXT	
do_FILL  . . . . . . . . . . . .	L Near	 000017CA _TEXT	
do_FIND  . . . . . . . . . . . .	L Near	 00001B38 _TEXT	
do_FORGET  . . . . . . . . . . .	L Near	 00002FB4 _TEXT	
do_FPARMSRW  . . . . . . . . . .	L Near	 000024B1 _TEXT	
do_FREE  . . . . . . . . . . . .	L Near	 000025F7 _TEXT	
do_FROMR . . . . . . . . . . . .	L Near	 00000ED2 _TEXT	
do_GCFA  . . . . . . . . . . . .	L Near	 00002312 _TEXT	
do_GETADDR . . . . . . . . . . .	L Near	 00000BE9 _TEXT	
do_GFS . . . . . . . . . . . . .	L Near	 00002489 _TEXT	
do_GTE . . . . . . . . . . . . .	L Near	 000010D3 _TEXT	
do_GTNUMBER  . . . . . . . . . .	L Near	 00001C4D _TEXT	
do_GT  . . . . . . . . . . . . .	L Near	 0000109B _TEXT	
do_Gone  . . . . . . . . . . . .	L Near	 00000188 _TEXT	
do_HASHV . . . . . . . . . . . .	L Near	 00001FC2 _TEXT	
do_HEADER  . . . . . . . . . . .	L Near	 000026EF _TEXT	
do_HERE  . . . . . . . . . . . .	L Near	 00001AA8 _TEXT	
do_HEX . . . . . . . . . . . . .	L Near	 00002666 _TEXT	
do_HLD . . . . . . . . . . . . .	L Near	 00000115 _TEXT	
do_HMEM  . . . . . . . . . . . .	L Near	 00000357 _TEXT	
do_HOLD  . . . . . . . . . . . .	L Near	 00001E45 _TEXT	
do_I2HEX . . . . . . . . . . . .	L Near	 00001ECF _TEXT	
do_IF@ . . . . . . . . . . . . .	L Near	 00001F4C _TEXT	
do_IFDUP . . . . . . . . . . . .	L Near	 00000CD6 _TEXT	
do_IF  . . . . . . . . . . . . .	L Near	 00002C1F _TEXT	
do_IMMEDIATE . . . . . . . . . .	L Near	 00002BED _TEXT	
do_INCR  . . . . . . . . . . . .	L Near	 00001528 _TEXT	
do_INTERPRET . . . . . . . . . .	L Near	 00003709 _TEXT	
do_INVERT  . . . . . . . . . . .	L Near	 000014D3 _TEXT	
do_IN  . . . . . . . . . . . . .	L Near	 0000025F _TEXT	
do_KBREAD  . . . . . . . . . . .	L Near	 00001DA6 _TEXT	
do_KEYIN . . . . . . . . . . . .	L Near	 0000033B _TEXT	
do_KEYQ  . . . . . . . . . . . .	L Near	 000030F7 _TEXT	
do_KEY . . . . . . . . . . . . .	L Near	 000030E2 _TEXT	
do_LASTNFA . . . . . . . . . . .	L Near	 000038FE _TEXT	
do_LAST  . . . . . . . . . . . .	L Near	 000008ED _TEXT	
do_LATEST  . . . . . . . . . . .	L Near	 00000570 _TEXT	
do_LCOUNT  . . . . . . . . . . .	L Near	 000013EB _TEXT	
do_LFA . . . . . . . . . . . . .	L Near	 000001F6 _TEXT	
do_LITERAL . . . . . . . . . . .	L Near	 000029AE _TEXT	
do_LIT . . . . . . . . . . . . .	L Near	 00000C07 _TEXT	
do_LMARK . . . . . . . . . . . .	L Near	 00002C9B _TEXT	
do_LOAD  . . . . . . . . . . . .	L Near	 000037B2 _TEXT	
do_LOWERCASE . . . . . . . . . .	L Near	 00001B03 _TEXT	
do_LPOUND  . . . . . . . . . . .	L Near	 00002BB4 _TEXT	
do_LRESOLVE  . . . . . . . . . .	L Near	 00002D3B _TEXT	
do_LROT32  . . . . . . . . . . .	L Near	 00000BCC _TEXT	
do_LSHIFT  . . . . . . . . . . .	L Near	 000014EE _TEXT	
do_LTE . . . . . . . . . . . . .	L Near	 000010B7 _TEXT	
do_LT  . . . . . . . . . . . . .	L Near	 00001073 _TEXT	
do_MALADDR . . . . . . . . . . .	L Near	 00000487 _TEXT	
do_MALLOC  . . . . . . . . . . .	L Near	 0000258D _TEXT	
do_MAX . . . . . . . . . . . . .	L Near	 0000119F _TEXT	
do_MEMQ  . . . . . . . . . . . .	L Near	 00000A2A _TEXT	
do_MESSAGES  . . . . . . . . . .	L Near	 00000535 _TEXT	
do_MINUSCELLS  . . . . . . . . .	L Near	 00000E23 _TEXT	
do_MINUSROT  . . . . . . . . . .	L Near	 00000CAF _TEXT	
do_MINUSSTORE  . . . . . . . . .	L Near	 00000966 _TEXT	
do_MINUS . . . . . . . . . . . .	L Near	 00000A90 _TEXT	
do_MIN . . . . . . . . . . . . .	L Near	 00001164 _TEXT	
do_MMULT . . . . . . . . . . . .	L Near	 0000136C _TEXT	
do_MSG22 . . . . . . . . . . . .	L Near	 000003E4 _TEXT	
do_MSG3  . . . . . . . . . . . .	L Near	 000003AB _TEXT	
do_MSG4  . . . . . . . . . . . .	L Near	 000003C7 _TEXT	
do_MS  . . . . . . . . . . . . .	L Near	 00002231 _TEXT	
do_MULT  . . . . . . . . . . . .	L Near	 0000138A _TEXT	
do_MsgF1 . . . . . . . . . . . .	L Near	 00000552 _TEXT	
do_NEGATE  . . . . . . . . . . .	L Near	 00000AC8 _TEXT	
do_NEQ . . . . . . . . . . . . .	L Near	 00001058 _TEXT	
do_NEWHEADER . . . . . . . . . .	L Near	 00001D28 _TEXT	
do_NEWNUMB . . . . . . . . . . .	L Near	 00001CF5 _TEXT	
do_NFA . . . . . . . . . . . . .	L Near	 00000211 _TEXT	
do_NIF . . . . . . . . . . . . .	L Near	 00002C7E _TEXT	
do_NIP . . . . . . . . . . . . .	L Near	 00000CF1 _TEXT	
do_NOOP  . . . . . . . . . . . .	L Near	 00001A93 _TEXT	
do_NUMBER? . . . . . . . . . . .	L Near	 00002A3F _TEXT	
do_NUMBER@ . . . . . . . . . . .	L Near	 00003786 _TEXT	
do_NUMBER  . . . . . . . . . . .	L Near	 00002A61 _TEXT	
do_NUMINIT . . . . . . . . . . .	L Near	 00001CBF _TEXT	
do_OCTAL . . . . . . . . . . . .	L Near	 000026C1 _TEXT	
do_OFF . . . . . . . . . . . . .	L Near	 000015AF _TEXT	
do_ON  . . . . . . . . . . . . .	L Near	 00001594 _TEXT	
do_OR  . . . . . . . . . . . . .	L Near	 0000149E _TEXT	
do_OVER  . . . . . . . . . . . .	L Near	 00000C6F _TEXT	
do_PARSEINIT . . . . . . . . . .	L Near	 000019B6 _TEXT	
do_PARSENAME . . . . . . . . . .	L Near	 00001937 _TEXT	
do_PARSESTR  . . . . . . . . . .	L Near	 00001A48 _TEXT	
do_PARSE . . . . . . . . . . . .	L Near	 000019DC _TEXT	
do_PAUSE . . . . . . . . . . . .	L Near	 0000309C _TEXT	
do_PCHARP  . . . . . . . . . . .	L Near	 00002A18 _TEXT	
do_PDDOTP  . . . . . . . . . . .	L Near	 00002ABB _TEXT	
do_PDOTP . . . . . . . . . . . .	L Near	 00002063 _TEXT	
do_PFA . . . . . . . . . . . . .	L Near	 00000245 _TEXT	
do_PICK  . . . . . . . . . . . .	L Near	 00000D27 _TEXT	
do_PLUSCELLS . . . . . . . . . .	L Near	 00000E06 _TEXT	
do_PLUSSTORE . . . . . . . . . .	L Near	 0000094F _TEXT	
do_PLUS  . . . . . . . . . . . .	L Near	 00000A79 _TEXT	
do_PMEM  . . . . . . . . . . . .	L Near	 00000373 _TEXT	
do_PNUMBERP  . . . . . . . . . .	L Near	 000036A4 _TEXT	
do_POC . . . . . . . . . . . . .	L Near	 000001A3 _TEXT	
do_POUNDS  . . . . . . . . . . .	L Near	 00002A87 _TEXT	
do_POUND . . . . . . . . . . . .	L Near	 00001E8F _TEXT	
do_PRINT . . . . . . . . . . . .	L Near	 00002748 _TEXT	
do_PTO . . . . . . . . . . . . .	L Near	 000031CC _TEXT	
do_PUSH0 . . . . . . . . . . . .	L Near	 000008D6 _TEXT	
do_PUSH1 . . . . . . . . . . . .	L Near	 000008A9 _TEXT	
do_QMARK . . . . . . . . . . . .	L Near	 000027AF _TEXT	
do_QSTACK  . . . . . . . . . . .	L Near	 000022C1 _TEXT	
do_READFILE  . . . . . . . . . .	L Near	 000024D0 _TEXT	
do_REPOSITIONFILE  . . . . . . .	L Near	 00002562 _TEXT	
do_RFETCH  . . . . . . . . . . .	L Near	 00000EEC _TEXT	
do_RFROMDROP . . . . . . . . . .	L Near	 00000F26 _TEXT	
do_ROT . . . . . . . . . . . . .	L Near	 00000C88 _TEXT	
do_RPFETCH . . . . . . . . . . .	L Near	 00000E8D _TEXT	
do_RPOUND  . . . . . . . . . . .	L Near	 00002B82 _TEXT	
do_RPSTORE . . . . . . . . . . .	L Near	 00000EA2 _TEXT	
do_RROT32  . . . . . . . . . . .	L Near	 00000BB0 _TEXT	
do_RSHIFT  . . . . . . . . . . .	L Near	 0000150C _TEXT	
do_RS  . . . . . . . . . . . . .	L Near	 000008BE _TEXT	
do_S0  . . . . . . . . . . . . .	L Near	 000002B2 _TEXT	
do_SCRINIT . . . . . . . . . . .	L Near	 0000074D _TEXT	
do_SEMI  . . . . . . . . . . . .	L Near	 00000862 _TEXT	
do_SEP1  . . . . . . . . . . . .	L Near	 00000444 _TEXT	
do_SERROR  . . . . . . . . . . .	L Near	 00000406 _TEXT	
do_SIGN  . . . . . . . . . . . .	L Near	 00002B50 _TEXT	
do_SMAX  . . . . . . . . . . . .	L Near	 00000298 _TEXT	
do_SOURCE_ . . . . . . . . . . .	L Near	 00001761 _TEXT	
do_SPACES  . . . . . . . . . . .	L Near	 00001E6A _TEXT	
do_SPFETCH . . . . . . . . . . .	L Near	 00000E61 _TEXT	
do_SPSTORE . . . . . . . . . . .	L Near	 00000E76 _TEXT	
do_SP  . . . . . . . . . . . . .	L Near	 00002084 _TEXT	
do_STATE . . . . . . . . . . . .	L Near	 00000132 _TEXT	
do_STDOUT  . . . . . . . . . . .	L Near	 000021F2 _TEXT	
do_STORE . . . . . . . . . . . .	L Near	 00000938 _TEXT	
do_STRINGADJ . . . . . . . . . .	L Near	 00001439 _TEXT	
do_SWAP  . . . . . . . . . . . .	L Near	 00000C50 _TEXT	
do_SWFETCH . . . . . . . . . . .	L Near	 000009DD _TEXT	
do_S_ADR . . . . . . . . . . . .	L Near	 000004A4 _TEXT	
do_S_LEN . . . . . . . . . . . .	L Near	 0000027C _TEXT	
do_StoD  . . . . . . . . . . . .	L Near	 00000D40 _TEXT	
do_THEN@ . . . . . . . . . . . .	L Near	 00001FAC _TEXT	
do_THEN  . . . . . . . . . . . .	L Near	 00002C5F _TEXT	
do_TICK  . . . . . . . . . . . .	L Near	 00003163 _TEXT	
do_TOBODY  . . . . . . . . . . .	L Near	 00001828 _TEXT	
do_TOR . . . . . . . . . . . . .	L Near	 00000EB8 _TEXT	
do_TO  . . . . . . . . . . . . .	L Near	 00003195 _TEXT	
do_TUCK  . . . . . . . . . . . .	L Near	 00000D09 _TEXT	
do_TV1 . . . . . . . . . . . . .	L Near	 000002CD _TEXT	
do_TV2 . . . . . . . . . . . . .	L Near	 000002E8 _TEXT	
do_TV3 . . . . . . . . . . . . .	L Near	 00000303 _TEXT	
do_TYPE  . . . . . . . . . . . .	L Near	 0000220F _TEXT	
do_U2DIVIDE  . . . . . . . . . .	L Near	 00000B2D _TEXT	
do_UB  . . . . . . . . . . . . .	L Near	 000004F7 _TEXT	
do_UGT . . . . . . . . . . . . .	L Near	 00001109 _TEXT	
do_ULT . . . . . . . . . . . . .	L Near	 000010EF _TEXT	
do_UMAX  . . . . . . . . . . . .	L Near	 00001182 _TEXT	
do_UMIN  . . . . . . . . . . . .	L Near	 00001147 _TEXT	
do_UNDERPLUS . . . . . . . . . .	L Near	 00000AAC _TEXT	
do_UNTIL@  . . . . . . . . . . .	L Near	 00002D85 _TEXT	
do_UNTIL . . . . . . . . . . . .	L Near	 00002DBC _TEXT	
do_UPPERCASE . . . . . . . . . .	L Near	 00001AC9 _TEXT	
do_VALPLUSTORE . . . . . . . . .	L Near	 000016F9 _TEXT	
do_VALUESTORE  . . . . . . . . .	L Near	 000016CB _TEXT	
do_VALUE . . . . . . . . . . . .	L Near	 0000292F _TEXT	
do_VARHEAD . . . . . . . . . . .	L Near	 000028DF _TEXT	
do_VARIABLE  . . . . . . . . . .	L Near	 00002906 _TEXT	
do_WCOMMA  . . . . . . . . . . .	L Near	 000027FE _TEXT	
do_WCOUNT  . . . . . . . . . . .	L Near	 000013CA _TEXT	
do_WDCOUNT . . . . . . . . . . .	L Near	 00002289 _TEXT	
do_WFETCH  . . . . . . . . . . .	L Near	 000009C4 _TEXT	
do_WITHIN  . . . . . . . . . . .	L Near	 000011DD _TEXT	
do_WORD  . . . . . . . . . . . .	L Near	 0000185D _TEXT	
do_WPLUSSTORE  . . . . . . . . .	L Near	 00000A0F _TEXT	
do_WRITEFILE . . . . . . . . . .	L Near	 00002500 _TEXT	
do_WSTORE  . . . . . . . . . . .	L Near	 000009F5 _TEXT	
do_XOR . . . . . . . . . . . . .	L Near	 000014B7 _TEXT	
do_ZCOMMAQ . . . . . . . . . . .	L Near	 0000325F _TEXT	
do_ZCOMM . . . . . . . . . . . .	L Near	 00003203 _TEXT	
do_ZCOUNT  . . . . . . . . . . .	L Near	 0000140B _TEXT	
do__HEADER_  . . . . . . . . . .	L Near	 00001787 _TEXT	
do__UNTIL  . . . . . . . . . . .	L Near	 00001F21 _TEXT	
do_dotR  . . . . . . . . . . . .	L Near	 00002DEE _TEXT	
do_dotS  . . . . . . . . . . . .	L Near	 00002E18 _TEXT	
do_dwtoa . . . . . . . . . . . .	L Near	 000021B9 _TEXT	
do_udw2str . . . . . . . . . . .	L Near	 000021D6 _TEXT	
do_venum . . . . . . . . . . . .	L Near	 0000016C _TEXT	
else1  . . . . . . . . . . . . .	L Near	 00001F95 _TEXT	
gone . . . . . . . . . . . . . .	DWord	 00000974 _DATA	
hMemory  . . . . . . . . . . . .	L Near	 00000349 _TEXT	
h_CHARS  . . . . . . . . . . . .	L Near	 00000A3D _TEXT	
h_DUP  . . . . . . . . . . . . .	L Near	 00000C2A _TEXT	
h_MINUSSTORE . . . . . . . . . .	L Near	 0000095A _TEXT	
h_PICK . . . . . . . . . . . . .	L Near	 00000D19 _TEXT	
h_PLUSSTORE  . . . . . . . . . .	L Near	 00000943 _TEXT	
h_STORE  . . . . . . . . . . . .	L Near	 0000092D _TEXT	
itohex . . . . . . . . . . . . .	L Near	 00001EC0 _TEXT	
lcase  . . . . . . . . . . . . .	Text   	 szLower
lnstr  . . . . . . . . . . . . .	Text   	 szLen
lstrcat  . . . . . . . . . . . .	Text   	 lstrcatA
lstrcmpi . . . . . . . . . . . .	Text   	 lstrcmpiA
lstrcmp  . . . . . . . . . . . .	Text   	 lstrcmpA
lstrcpyn . . . . . . . . . . . .	Text   	 lstrcpynA
lstrcpy  . . . . . . . . . . . .	Text   	 lstrcpyA
lstrlen  . . . . . . . . . . . .	Text   	 lstrlenA
lstr . . . . . . . . . . . . . .	Text   	 szLeft
ltrim  . . . . . . . . . . . . .	Text   	 szLtrim
midstr . . . . . . . . . . . . .	Text   	 szMid
pMem . . . . . . . . . . . . . .	DWord	 000009A8 _DATA	
revstr . . . . . . . . . . . . .	Text   	 szRev
rstr . . . . . . . . . . . . . .	Text   	 szRight
rtrim  . . . . . . . . . . . . .	Text   	 szRtrim
trim . . . . . . . . . . . . . .	Text   	 szTrim
ucase  . . . . . . . . . . . . .	Text   	 szUpper
venum  . . . . . . . . . . . . .	L Near	 0000015C _TEXT	
xpos . . . . . . . . . . . . . .	DWord	 000009F0 _DATA	
ypos . . . . . . . . . . . . . .	DWord	 000009F4 _DATA	

	   0 Warnings
	   0 Errors
